(() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x + '" is not supported');
  });
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };

  // node_modules/alasql/dist/alasql.min.js
  var require_alasql_min = __commonJS({
    "node_modules/alasql/dist/alasql.min.js"(exports, module) {
      "use strict";
      !function(e, t) {
        "function" == typeof define && define.amd ? define([], t) : "object" == typeof exports ? module.exports = t() : e.alasql = t();
      }(exports, function() {
        function U() {
          return null;
        }
        var F, e, t, s, _, P, q, G, j, V, B, H, n, J, Y, W, X, K, Q, z, Z, e1, t1, s1, n1, r1, a1, i1, o1, u1, l1, c1, h1, d1, f1, p1, b1, E1, g1, m1, T1, S1, A1, y1, r, a, i, o, u, l, c, v1, N1, O1, C1, h, d, R1, f, I1, w1, p, $1, x1, k1, b, E, g, L1, D1, M1, U1, m, T, S, A, y, v, N, O, C, R, I, F1, _1, P1, w, q1, G1, j1, $, x, V1, B1, H1, J1, Y1, W1, X1, K1, Q1, z1, Z1, e2, t2, s2, n2, r2, a2, i2, k, o2, u2, l2, c2, h2, d2, f2, p2, b2, E2, g2, m2, T2, S2, A2, y2, v2, N2, O2, C2, R2, I2, w2, $2, x2, k2, L2, D2, M2, U2, F2, _2, P2, q2, G2, j2, V2, B2, H2, J2, Y2, W2, X2, K2, Q2, z2, Z2, ee, te, se, ne, re, ae, ie, oe, ue, le, ce, he, de, fe, pe, be, Ee, ge, me, Te, Se, Ae, ye, ve, Ne, Oe, Ce, Re, Ie, we, $e, xe, ke, Le, De, Me, Ue, Fe, _e, Pe, qe, Ge, je, Ve, Be, He, Je, Ye, We, Xe, Ke, Qe, ze, Ze, et, tt, st, nt, rt, at, it, ot, ut, lt, ct, ht, dt, ft, pt, bt, Et, gt, mt, Tt, St, At, yt, vt, Nt, Ot, Ct, Rt, It, wt, $t, xt, kt, Lt, Dt, Mt, Ut, Ft, _t, Pt, qt, Gt, jt, Vt, Bt, Ht, Jt, Yt, Wt, Xt, Kt, Qt, zt, Zt, e3, t3, s3, n3, r3, a3, i3, o3, u3, l3, c3, h3, d3, f3, p3, b3, E3, g3, m3, T3, S3, A3, y3, v3, N3, O3, C3, R3, I3, w3, $3, x3, k3, L3, D3, M3, U3, F3, _3, P3, q3, G3, j3, V3, B3, H3, J3, Y3, W3, X3, K3, Q3, z3, Z3, e4, t4, s4, n4, r4, a4, i4, o4, u4, l4, c4, h4, d4, f4, p4, b4, E4, g4, m4, T4, S4, A4, y4, v4, N4, O4, C4, R4, I4, w4, $4, x4, k4, L4, D4, M4, U4, F4, _4, P4, q4, G4, j4, V4, B4, H4, J4, Y4, W4, X4, K4, Q4, z4, Z4, es, ts, ss, ns, rs, as, is, os, us, ls, cs, hs, ds, L = function(e5, t5, s5, n5) {
          if (t5 = t5 || [], "function" == typeof importScripts || !L.webworker)
            return 0 === arguments.length ? new M.Select({ columns: [new M.Column({ columnid: "*" })], from: [new M.ParamValue({ param: 0 })] }) : 1 === arguments.length && e5.constructor === Array ? L.promise(e5) : ("function" == typeof t5 && (n5 = s5, s5 = t5, t5 = []), "object" != typeof t5 && (t5 = [t5]), "string" == typeof e5 && "#" === e5[0] && "object" == typeof document ? e5 = document.querySelector(e5).textContent : "object" == typeof e5 && e5 instanceof HTMLElement ? e5 = e5.textContent : "function" == typeof e5 && (e5 = e5.toString(), e5 = (/\/\*([\S\s]+)\*\//m.exec(e5) || ["", "Function given as SQL. Plese Provide SQL string or have a /* ... */ syle comment with SQL in the function."])[1]), L.exec(e5, t5, s5, n5));
          n5 = L.lastid++, L.buffer[n5] = s5, L.webworker.postMessage({ id: n5, sql: e5, params: t5 });
        }, fs = (L.version = "4.0.3", L.build = "develop-37eea424", L.debug = void 0, gn = [1, 108], Sn = [1, 107], y1 = [10, 310, 606, 767], r = [10, 310, 314, 606, 767], a = [1, 115], i = [1, 116], o = [1, 117], u = [1, 118], l = [1, 119], c = [1, 120], Gs = [130, 357, 414], v1 = [1, 128], N1 = [1, 127], O1 = [1, 135], C1 = [1, 165], h = [1, 176], d = [1, 179], R1 = [1, 174], f = [1, 182], I1 = [1, 186], w1 = [1, 161], p = [1, 183], $1 = [1, 170], x1 = [1, 172], k1 = [1, 175], b = [1, 184], E = [1, 201], g = [1, 202], L1 = [1, 167], D1 = [1, 194], M1 = [1, 189], U1 = [1, 190], m = [1, 195], T = [1, 196], S = [1, 197], A = [1, 198], y = [1, 199], v = [1, 200], N = [1, 203], O = [1, 204], C = [1, 177], R = [1, 178], I = [1, 180], F1 = [1, 181], _1 = [1, 187], P1 = [1, 193], w = [1, 185], q1 = [1, 188], G1 = [1, 173], j1 = [1, 171], $ = [1, 192], x = [1, 205], V1 = [2, 4, 5], B1 = [2, 476], H1 = [1, 208], J1 = [1, 213], Y1 = [1, 222], W1 = [1, 218], X1 = [10, 72, 78, 93, 98, 118, 128, 162, 168, 169, 183, 198, 232, 249, 251, 310, 314, 606, 767], K1 = [2, 4, 5, 10, 72, 76, 77, 78, 112, 115, 116, 118, 122, 123, 124, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 145, 146, 148, 149, 150, 152, 154, 156, 162, 164, 166, 168, 169, 170, 171, 172, 173, 175, 183, 185, 187, 198, 244, 245, 284, 285, 286, 287, 288, 289, 290, 291, 310, 314, 424, 428, 606, 767], Q1 = [2, 4, 5, 10, 53, 72, 74, 76, 77, 78, 89, 93, 95, 98, 99, 107, 112, 115, 116, 118, 122, 123, 124, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 145, 146, 148, 149, 150, 152, 154, 156, 162, 164, 166, 168, 169, 170, 171, 172, 173, 175, 179, 180, 181, 183, 185, 187, 189, 198, 206, 208, 222, 223, 224, 225, 226, 227, 228, 229, 232, 239, 244, 245, 246, 247, 249, 251, 270, 271, 284, 285, 286, 287, 288, 289, 290, 291, 293, 300, 304, 310, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 334, 335, 336, 337, 339, 342, 343, 400, 404, 405, 408, 410, 412, 413, 421, 422, 424, 428, 438, 440, 441, 443, 444, 445, 446, 447, 451, 452, 455, 456, 468, 474, 509, 511, 512, 521, 606, 767], z1 = [1, 251], Z1 = [1, 258], e2 = [1, 267], t2 = [1, 272], s2 = [1, 271], n2 = [2, 4, 5, 10, 72, 77, 78, 93, 98, 107, 118, 128, 131, 132, 137, 143, 145, 149, 152, 154, 156, 162, 168, 169, 179, 180, 181, 183, 198, 232, 244, 245, 249, 251, 269, 270, 274, 275, 277, 284, 285, 286, 287, 288, 289, 290, 291, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 306, 307, 310, 314, 316, 321, 424, 428, 606, 767], r2 = [2, 162], a2 = [1, 283], i2 = [10, 74, 78, 310, 314, 509, 606, 767], k = [2, 4, 5, 10, 53, 72, 74, 76, 77, 78, 89, 93, 95, 98, 99, 107, 112, 115, 116, 118, 122, 123, 124, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 145, 146, 148, 149, 150, 152, 154, 156, 162, 164, 166, 168, 169, 170, 171, 172, 173, 175, 179, 180, 181, 183, 185, 187, 189, 193, 198, 206, 208, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 239, 244, 245, 246, 247, 249, 251, 270, 271, 284, 285, 286, 287, 288, 289, 290, 291, 293, 300, 301, 304, 306, 310, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 334, 335, 336, 337, 339, 342, 343, 347, 348, 360, 372, 373, 374, 377, 378, 390, 393, 400, 404, 405, 406, 407, 408, 409, 410, 412, 413, 421, 422, 424, 428, 430, 437, 438, 440, 441, 443, 444, 445, 446, 447, 451, 452, 455, 456, 468, 474, 509, 511, 512, 518, 519, 520, 521, 606, 767], o2 = [2, 4, 5, 10, 53, 72, 89, 124, 146, 156, 189, 270, 271, 293, 310, 339, 342, 343, 400, 404, 405, 408, 410, 412, 413, 421, 422, 438, 440, 441, 443, 444, 445, 446, 447, 451, 452, 455, 456, 509, 511, 512, 521, 606, 767], u2 = [1, 564], l2 = [1, 566], c2 = [2, 508], h2 = [1, 572], d2 = [1, 583], f2 = [1, 586], p2 = [1, 587], b2 = [10, 78, 89, 132, 137, 146, 189, 300, 310, 314, 474, 606, 767], E2 = [10, 74, 310, 314, 606, 767], g2 = [2, 572], m2 = [1, 605], T2 = [2, 4, 5, 156], S2 = [1, 643], A2 = [1, 615], y2 = [1, 649], v2 = [1, 650], N2 = [1, 623], O2 = [1, 634], C2 = [1, 621], R2 = [1, 629], I2 = [1, 622], w2 = [1, 630], $2 = [1, 632], x2 = [1, 624], k2 = [1, 625], L2 = [1, 644], D2 = [1, 641], M2 = [1, 642], U2 = [1, 618], F2 = [1, 620], _2 = [1, 612], P2 = [1, 613], q2 = [1, 614], G2 = [1, 616], j2 = [1, 617], V2 = [1, 619], B2 = [1, 626], H2 = [1, 627], J2 = [1, 631], Y2 = [1, 633], W2 = [1, 635], X2 = [1, 636], K2 = [1, 637], Q2 = [1, 638], z2 = [1, 639], Z2 = [1, 645], ee = [1, 646], te = [1, 647], se = [1, 648], ne = [2, 290], re = [2, 4, 5, 10, 53, 72, 74, 76, 77, 78, 89, 93, 95, 98, 99, 107, 112, 115, 116, 118, 122, 123, 124, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 145, 146, 148, 149, 150, 152, 154, 156, 162, 164, 166, 168, 169, 170, 171, 172, 173, 175, 179, 180, 181, 183, 185, 187, 189, 198, 206, 208, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 239, 244, 245, 246, 247, 249, 251, 270, 271, 284, 285, 286, 287, 288, 289, 290, 291, 293, 300, 301, 304, 310, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 334, 335, 336, 337, 339, 342, 343, 347, 360, 372, 373, 377, 378, 400, 404, 405, 408, 410, 412, 413, 421, 422, 424, 428, 430, 438, 440, 441, 443, 444, 445, 446, 447, 451, 452, 455, 456, 468, 474, 509, 511, 512, 521, 606, 767], ae = [2, 364], ie = [1, 671], oe = [1, 681], ue = [2, 4, 5, 10, 53, 72, 74, 76, 77, 78, 89, 93, 95, 98, 99, 107, 112, 115, 116, 118, 122, 123, 124, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 145, 146, 148, 149, 150, 152, 154, 156, 162, 164, 166, 168, 169, 170, 171, 172, 173, 175, 179, 180, 181, 183, 185, 187, 189, 198, 206, 208, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 239, 244, 245, 246, 247, 249, 251, 270, 271, 284, 285, 286, 287, 288, 289, 290, 291, 293, 300, 304, 310, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 334, 335, 336, 337, 339, 342, 343, 400, 404, 405, 408, 410, 412, 413, 421, 422, 424, 428, 430, 438, 440, 441, 443, 444, 445, 446, 447, 451, 452, 455, 456, 468, 474, 509, 511, 512, 521, 606, 767], le = [1, 697], ce = [1, 706], he = [1, 705], de = [2, 4, 5, 10, 72, 74, 78, 93, 98, 118, 128, 162, 168, 169, 206, 208, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 249, 251, 310, 314, 606, 767], fe = [10, 72, 74, 78, 93, 98, 118, 128, 162, 168, 169, 206, 208, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 249, 251, 310, 314, 606, 767], pe = [2, 202], be = [1, 728], Ee = [10, 72, 78, 93, 98, 118, 128, 162, 168, 169, 183, 232, 249, 251, 310, 314, 606, 767], rn = [2, 163], an = [1, 731], ge = [2, 4, 5, 112], me = [1, 744], Te = [1, 763], Se = [1, 743], Ae = [1, 742], ye = [1, 737], ve = [1, 738], Ne = [1, 740], Oe = [1, 741], Ce = [1, 745], Re = [1, 746], Ie = [1, 747], we = [1, 748], $e = [1, 749], xe = [1, 750], ke = [1, 751], Le = [1, 752], De = [1, 753], Me = [1, 754], Ue = [1, 755], Fe = [1, 756], _e = [1, 757], Pe = [1, 758], qe = [1, 759], Ge = [1, 760], je = [1, 762], Ve = [1, 764], Be = [1, 765], He = [1, 766], Je = [1, 767], Ye = [1, 768], We = [1, 769], Xe = [1, 770], Ke = [1, 773], Qe = [1, 774], ze = [1, 775], Ze = [1, 776], et = [1, 777], tt = [1, 778], st = [1, 779], nt = [1, 780], rt = [1, 781], at = [1, 782], it = [1, 783], ot = [1, 784], ut = [74, 89, 189], lt = [10, 74, 78, 154, 187, 230, 301, 310, 314, 347, 360, 372, 373, 377, 378, 606, 767], ct = [1, 801], ht = [10, 74, 78, 304, 310, 314, 606, 767], dt = [1, 802], ft = [1, 808], pt = [1, 809], bt = [1, 813], Et = [10, 74, 78, 310, 314, 606, 767], gt = [2, 4, 5, 77, 131, 132, 137, 143, 145, 149, 152, 154, 156, 179, 180, 181, 244, 245, 269, 270, 274, 275, 277, 284, 285, 286, 287, 288, 289, 290, 291, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 306, 307, 316, 321, 424, 428], mt = [10, 72, 78, 93, 98, 107, 118, 128, 162, 168, 169, 183, 198, 232, 249, 251, 310, 314, 606, 767], Tt = [2, 4, 5, 10, 72, 77, 78, 93, 98, 107, 118, 128, 131, 132, 137, 143, 145, 149, 152, 154, 156, 162, 164, 168, 169, 179, 180, 181, 183, 185, 187, 195, 198, 232, 244, 245, 249, 251, 269, 270, 274, 275, 277, 284, 285, 286, 287, 288, 289, 290, 291, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 306, 307, 310, 314, 316, 321, 424, 428, 606, 767], St = [2, 4, 5, 132, 300], At = [1, 848], yt = [10, 74, 76, 78, 310, 314, 606, 767], vt = [2, 743], Nt = [10, 74, 76, 78, 132, 139, 141, 145, 152, 310, 314, 424, 428, 606, 767], Ot = [2, 1166], Ct = [10, 74, 76, 78, 139, 141, 145, 152, 310, 314, 424, 428, 606, 767], Rt = [10, 74, 76, 78, 139, 141, 145, 310, 314, 424, 428, 606, 767], It = [10, 74, 78, 139, 141, 310, 314, 606, 767], wt = [10, 78, 89, 132, 146, 189, 300, 310, 314, 474, 606, 767], $t = [339, 342, 343], xt = [2, 769], kt = [1, 873], Lt = [1, 874], Dt = [1, 875], Mt = [1, 876], Ut = [1, 885], Ft = [1, 884], _t = [164, 166, 338], Pt = [2, 449], qt = [1, 940], Gt = [2, 4, 5, 77, 131, 156, 293, 294, 295, 296, 297], jt = [1, 955], Vt = [2, 4, 5, 10, 53, 72, 74, 76, 77, 78, 89, 93, 95, 98, 99, 107, 112, 118, 122, 124, 128, 129, 130, 131, 132, 134, 135, 137, 139, 140, 141, 142, 143, 145, 146, 148, 149, 150, 152, 154, 156, 162, 164, 166, 168, 169, 170, 171, 172, 173, 175, 179, 181, 183, 185, 187, 189, 198, 206, 208, 222, 223, 224, 225, 226, 227, 228, 229, 232, 239, 244, 245, 246, 247, 249, 251, 270, 271, 284, 285, 286, 287, 288, 289, 290, 291, 293, 300, 304, 310, 312, 313, 314, 315, 317, 318, 319, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 334, 335, 336, 337, 339, 342, 343, 400, 404, 405, 408, 410, 412, 413, 421, 422, 424, 428, 438, 440, 441, 443, 444, 445, 446, 447, 451, 452, 455, 456, 468, 474, 509, 511, 512, 521, 606, 767], Bt = [2, 4, 5, 10, 53, 72, 74, 76, 77, 78, 89, 93, 95, 98, 99, 107, 112, 115, 116, 118, 122, 123, 124, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 145, 146, 148, 149, 150, 152, 154, 156, 162, 164, 166, 168, 169, 170, 171, 172, 173, 175, 179, 180, 181, 183, 185, 187, 189, 198, 206, 208, 222, 223, 224, 225, 226, 227, 228, 229, 232, 239, 244, 245, 246, 247, 249, 251, 270, 271, 284, 285, 286, 287, 288, 289, 290, 291, 293, 300, 304, 310, 312, 313, 314, 315, 316, 317, 318, 319, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 334, 335, 336, 337, 339, 342, 343, 400, 404, 405, 408, 410, 412, 413, 421, 422, 424, 428, 438, 440, 441, 443, 444, 445, 446, 447, 451, 452, 455, 456, 468, 474, 509, 511, 512, 521, 606, 767], Ht = [2, 380], Jt = [1, 962], Yt = [310, 312, 314], Wt = [74, 304], Xt = [74, 304, 430], Kt = [1, 969], Qt = [2, 4, 5, 10, 53, 72, 74, 76, 78, 89, 93, 95, 98, 99, 107, 112, 115, 116, 118, 122, 123, 124, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 145, 146, 148, 149, 150, 152, 154, 156, 162, 164, 166, 168, 169, 170, 171, 172, 173, 175, 179, 180, 181, 183, 185, 187, 189, 198, 206, 208, 222, 223, 224, 225, 226, 227, 228, 229, 232, 239, 244, 245, 246, 247, 249, 251, 270, 271, 284, 285, 286, 287, 288, 289, 290, 291, 293, 300, 304, 310, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 334, 335, 336, 337, 339, 342, 343, 400, 404, 405, 408, 410, 412, 413, 421, 422, 424, 428, 438, 440, 441, 443, 444, 445, 446, 447, 451, 452, 455, 456, 468, 474, 509, 511, 512, 521, 606, 767], zt = [74, 430], Zt = [1, 982], e3 = [1, 981], t3 = [1, 988], s3 = [10, 72, 78, 93, 98, 118, 128, 162, 168, 169, 232, 249, 251, 310, 314, 606, 767], n3 = [1, 1014], r3 = [10, 72, 78, 310, 314, 606, 767], a3 = [1, 1020], i3 = [1, 1021], o3 = [1, 1022], u3 = [2, 4, 5, 10, 72, 74, 76, 77, 78, 112, 115, 116, 118, 122, 123, 124, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 145, 146, 148, 149, 150, 152, 154, 156, 162, 164, 166, 168, 169, 170, 171, 172, 173, 175, 179, 180, 181, 183, 185, 187, 198, 244, 245, 284, 285, 286, 287, 288, 289, 290, 291, 310, 314, 424, 428, 606, 767], l3 = [1, 1072], c3 = [1, 1071], h3 = [1, 1085], d3 = [1, 1084], f3 = [1, 1092], p3 = [10, 72, 74, 78, 93, 98, 107, 118, 128, 162, 168, 169, 183, 198, 232, 249, 251, 310, 314, 606, 767], b3 = [1, 1124], E3 = [10, 78, 89, 146, 189, 310, 314, 474, 606, 767], g3 = [1, 1144], m3 = [1, 1143], T3 = [1, 1142], S3 = [2, 4, 5, 10, 53, 72, 74, 76, 77, 78, 89, 93, 95, 98, 99, 107, 112, 115, 116, 118, 122, 123, 124, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 145, 146, 148, 149, 150, 152, 154, 156, 162, 164, 166, 168, 169, 170, 171, 172, 173, 175, 179, 180, 181, 183, 185, 187, 189, 198, 206, 208, 222, 223, 224, 225, 226, 227, 228, 229, 230, 232, 239, 244, 245, 246, 247, 249, 251, 270, 271, 284, 285, 286, 287, 288, 289, 290, 291, 293, 300, 301, 304, 310, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 334, 335, 336, 337, 339, 342, 343, 347, 360, 372, 373, 377, 378, 400, 404, 405, 408, 410, 412, 413, 421, 422, 424, 428, 438, 440, 441, 443, 444, 445, 446, 447, 451, 452, 455, 456, 468, 474, 509, 511, 512, 521, 606, 767], A3 = [1, 1158], y3 = [2, 4, 5, 10, 53, 72, 74, 76, 77, 78, 89, 93, 95, 98, 99, 107, 112, 118, 122, 124, 128, 129, 130, 131, 132, 134, 135, 137, 139, 140, 143, 145, 146, 148, 149, 150, 152, 154, 156, 162, 164, 166, 168, 169, 170, 171, 172, 173, 175, 181, 183, 185, 187, 189, 198, 206, 208, 222, 223, 224, 225, 226, 227, 228, 229, 232, 239, 244, 245, 246, 247, 249, 251, 270, 271, 284, 285, 286, 287, 288, 289, 290, 291, 293, 300, 304, 310, 312, 313, 314, 315, 317, 318, 319, 324, 325, 326, 327, 328, 329, 330, 334, 335, 336, 337, 339, 342, 343, 400, 404, 405, 408, 410, 412, 413, 421, 422, 424, 428, 438, 440, 441, 443, 444, 445, 446, 447, 451, 452, 455, 456, 468, 474, 509, 511, 512, 521, 606, 767], v3 = [2, 4, 5, 10, 53, 72, 74, 76, 77, 78, 89, 93, 95, 98, 99, 107, 112, 118, 122, 124, 128, 129, 130, 131, 132, 134, 135, 137, 139, 140, 143, 145, 146, 148, 149, 150, 152, 154, 156, 162, 164, 166, 168, 169, 170, 171, 172, 173, 175, 181, 183, 185, 187, 189, 198, 206, 208, 222, 223, 224, 225, 226, 227, 228, 229, 232, 239, 244, 245, 246, 247, 249, 251, 270, 271, 284, 285, 286, 287, 288, 289, 290, 291, 293, 300, 304, 310, 312, 313, 314, 315, 317, 319, 324, 325, 326, 327, 328, 329, 330, 334, 335, 336, 337, 339, 342, 343, 400, 404, 405, 408, 410, 412, 413, 421, 422, 424, 428, 438, 440, 441, 443, 444, 445, 446, 447, 451, 452, 455, 456, 468, 474, 509, 511, 512, 521, 606, 767], N3 = [2, 4, 5, 10, 53, 72, 74, 76, 77, 78, 89, 93, 95, 98, 99, 107, 112, 118, 122, 124, 128, 129, 130, 131, 132, 133, 134, 135, 137, 138, 139, 140, 141, 142, 143, 145, 146, 148, 149, 150, 152, 154, 156, 162, 164, 166, 168, 169, 170, 171, 172, 173, 175, 179, 180, 181, 183, 185, 187, 189, 198, 206, 208, 222, 223, 224, 225, 226, 227, 228, 229, 232, 239, 244, 245, 246, 247, 249, 251, 270, 271, 284, 285, 286, 287, 288, 289, 290, 291, 293, 300, 304, 310, 312, 313, 314, 315, 317, 318, 319, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 334, 335, 336, 337, 339, 342, 343, 400, 404, 405, 408, 410, 412, 413, 421, 422, 424, 428, 438, 440, 441, 443, 444, 445, 446, 447, 451, 452, 455, 456, 468, 474, 509, 511, 512, 521, 606, 767], O3 = [2, 4, 5, 10, 53, 72, 74, 76, 77, 78, 89, 93, 95, 98, 99, 107, 112, 118, 122, 124, 128, 129, 130, 131, 132, 134, 135, 137, 139, 140, 141, 142, 143, 145, 146, 148, 149, 150, 152, 154, 156, 162, 164, 166, 168, 169, 170, 171, 172, 173, 175, 181, 183, 185, 187, 189, 198, 206, 208, 222, 223, 224, 225, 226, 227, 228, 229, 232, 239, 244, 245, 246, 247, 249, 251, 270, 271, 284, 285, 286, 287, 288, 289, 290, 291, 293, 300, 304, 310, 312, 313, 314, 315, 317, 318, 319, 322, 323, 324, 325, 326, 327, 328, 329, 330, 334, 335, 336, 337, 339, 342, 343, 400, 404, 405, 408, 410, 412, 413, 421, 422, 424, 428, 438, 440, 441, 443, 444, 445, 446, 447, 451, 452, 455, 456, 468, 474, 509, 511, 512, 521, 606, 767], C3 = [2, 4, 5, 10, 53, 72, 74, 76, 77, 78, 89, 93, 95, 98, 99, 107, 118, 122, 124, 128, 129, 130, 131, 132, 134, 135, 137, 139, 140, 143, 145, 146, 148, 149, 150, 152, 154, 156, 162, 164, 166, 168, 169, 170, 171, 172, 173, 175, 181, 183, 185, 187, 189, 198, 206, 208, 222, 223, 224, 225, 226, 227, 228, 229, 232, 239, 244, 245, 246, 247, 249, 251, 270, 271, 284, 285, 286, 287, 288, 289, 290, 291, 293, 300, 304, 310, 312, 313, 314, 318, 324, 325, 326, 327, 328, 329, 330, 334, 335, 337, 339, 342, 343, 400, 404, 405, 408, 410, 412, 413, 421, 422, 424, 428, 438, 440, 441, 443, 444, 445, 446, 447, 451, 452, 455, 456, 468, 474, 509, 511, 512, 521, 606, 767], R3 = [2, 411], I3 = [2, 4, 5, 10, 53, 72, 74, 76, 77, 78, 89, 93, 95, 98, 107, 118, 122, 128, 129, 130, 131, 132, 134, 135, 137, 143, 145, 146, 148, 149, 150, 152, 156, 162, 164, 166, 168, 169, 170, 171, 172, 173, 175, 181, 183, 185, 187, 189, 198, 206, 208, 222, 223, 224, 225, 226, 227, 228, 229, 232, 239, 244, 245, 246, 247, 249, 251, 270, 271, 284, 285, 286, 287, 288, 289, 290, 291, 293, 300, 304, 310, 312, 313, 314, 318, 334, 335, 337, 339, 342, 343, 400, 404, 405, 408, 410, 412, 413, 421, 422, 424, 428, 438, 440, 441, 443, 444, 445, 446, 447, 451, 452, 455, 456, 468, 474, 509, 511, 512, 521, 606, 767], w3 = [2, 288], $3 = [2, 4, 5, 10, 53, 72, 74, 76, 77, 78, 89, 93, 95, 98, 99, 107, 112, 115, 116, 118, 122, 123, 124, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 145, 146, 148, 149, 150, 152, 154, 156, 162, 164, 166, 168, 169, 170, 171, 172, 173, 175, 179, 180, 181, 183, 185, 187, 189, 198, 206, 208, 222, 223, 224, 225, 226, 227, 228, 229, 232, 239, 244, 245, 246, 247, 249, 251, 270, 271, 284, 285, 286, 287, 288, 289, 290, 291, 293, 300, 304, 310, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 334, 335, 336, 337, 339, 342, 343, 400, 404, 405, 408, 410, 412, 413, 421, 422, 424, 428, 430, 438, 440, 441, 443, 444, 445, 446, 447, 451, 452, 455, 456, 468, 474, 509, 511, 512, 521, 606, 767], x3 = [10, 78, 310, 314, 606, 767], k3 = [1, 1194], L3 = [10, 77, 78, 143, 145, 152, 181, 306, 310, 314, 424, 428, 606, 767], D3 = [10, 74, 78, 310, 312, 314, 468, 606, 767], M3 = [1, 1205], U3 = [10, 72, 78, 118, 128, 162, 168, 169, 232, 249, 251, 310, 314, 606, 767], F3 = [10, 72, 74, 78, 93, 98, 118, 128, 162, 168, 169, 183, 198, 232, 249, 251, 310, 314, 606, 767], _3 = [2, 4, 5, 72, 76, 77, 78, 112, 115, 116, 118, 122, 123, 124, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 145, 146, 148, 149, 150, 152, 154, 156, 162, 164, 166, 168, 169, 170, 171, 172, 173, 175, 185, 187, 244, 245, 284, 285, 286, 287, 288, 289, 290, 291, 424, 428], P3 = [2, 4, 5, 72, 74, 76, 77, 78, 112, 115, 116, 118, 122, 123, 124, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 145, 146, 148, 149, 150, 152, 154, 156, 162, 164, 166, 168, 169, 170, 171, 172, 173, 175, 185, 187, 244, 245, 284, 285, 286, 287, 288, 289, 290, 291, 424, 428], q3 = [2, 1090], G3 = [2, 4, 5, 72, 74, 76, 77, 112, 115, 116, 118, 122, 123, 124, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 145, 146, 148, 149, 150, 152, 154, 156, 162, 164, 166, 168, 169, 170, 171, 172, 173, 175, 185, 187, 244, 245, 284, 285, 286, 287, 288, 289, 290, 291, 424, 428], j3 = [1, 1257], V3 = [10, 74, 78, 128, 310, 312, 314, 468, 606, 767], B3 = [115, 116, 124], H3 = [2, 589], J3 = [1, 1286], Y3 = [76, 139], W3 = [2, 729], X3 = [1, 1303], K3 = [1, 1304], Q3 = [2, 4, 5, 10, 53, 72, 76, 89, 124, 146, 156, 189, 230, 270, 271, 293, 310, 314, 339, 342, 343, 400, 404, 405, 408, 410, 412, 413, 421, 422, 438, 440, 441, 443, 444, 445, 446, 447, 451, 452, 455, 456, 509, 511, 512, 521, 606, 767], z3 = [2, 333], Z3 = [1, 1328], e4 = [1, 1342], t4 = [1, 1344], s4 = [2, 492], n4 = [74, 78], r4 = [10, 310, 312, 314, 468, 606, 767], a4 = [10, 72, 78, 118, 162, 168, 169, 232, 249, 251, 310, 314, 606, 767], i4 = [1, 1360], o4 = [1, 1364], u4 = [1, 1365], l4 = [1, 1367], c4 = [1, 1368], h4 = [1, 1369], d4 = [1, 1370], f4 = [1, 1371], p4 = [1, 1372], b4 = [1, 1373], E4 = [1, 1374], g4 = [10, 72, 74, 78, 93, 98, 118, 128, 162, 168, 169, 206, 208, 222, 223, 224, 225, 226, 227, 228, 229, 232, 249, 251, 310, 314, 606, 767], m4 = [1, 1399], T4 = [10, 72, 78, 118, 162, 168, 169, 249, 251, 310, 314, 606, 767], S4 = [10, 72, 78, 93, 98, 118, 128, 162, 168, 169, 206, 208, 222, 223, 224, 225, 226, 227, 228, 229, 232, 249, 251, 310, 314, 606, 767], A4 = [1, 1497], y4 = [1, 1499], v4 = [2, 4, 5, 77, 143, 145, 152, 156, 181, 293, 294, 295, 296, 297, 306, 424, 428], N4 = [1, 1513], O4 = [10, 72, 74, 78, 162, 168, 169, 249, 251, 310, 314, 606, 767], C4 = [1, 1531], R4 = [1, 1533], I4 = [1, 1534], w4 = [1, 1530], $4 = [1, 1529], x4 = [1, 1528], k4 = [1, 1535], L4 = [1, 1525], D4 = [1, 1526], M4 = [1, 1527], U4 = [1, 1553], F4 = [2, 4, 5, 10, 53, 72, 89, 124, 146, 156, 189, 270, 271, 293, 310, 314, 339, 342, 343, 400, 404, 405, 408, 410, 412, 413, 421, 422, 438, 440, 441, 443, 444, 445, 446, 447, 451, 452, 455, 456, 509, 511, 512, 521, 606, 767], _4 = [1, 1564], P4 = [1, 1572], q4 = [1, 1571], G4 = [10, 72, 78, 162, 168, 169, 249, 251, 310, 314, 606, 767], j4 = [10, 72, 78, 93, 98, 118, 128, 162, 168, 169, 206, 208, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 249, 251, 310, 314, 606, 767], V4 = [2, 4, 5, 10, 72, 78, 93, 98, 118, 128, 162, 168, 169, 206, 208, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 249, 251, 310, 314, 606, 767], B4 = [1, 1632], H4 = [1, 1634], J4 = [1, 1631], Y4 = [1, 1633], W4 = [187, 193, 372, 373, 374, 377], X4 = [2, 520], K4 = [1, 1639], Q4 = [1, 1658], z4 = [10, 72, 78, 162, 168, 169, 310, 314, 606, 767], Z4 = [1, 1668], es = [1, 1669], ts = [1, 1670], ss = [1, 1691], ns = [4, 10, 247, 310, 314, 347, 360, 606, 767], rs = [1, 1739], as = [10, 72, 74, 78, 118, 162, 168, 169, 239, 249, 251, 310, 314, 606, 767], is = [2, 4, 5, 77], os = [1, 1833], us = [1, 1845], ls = [1, 1864], cs = [10, 72, 78, 162, 168, 169, 310, 314, 419, 606, 767], hs = [10, 74, 78, 230, 310, 314, 606, 767], _ = { trace: function() {
        }, yy: {}, symbols_: { error: 2, Literal: 3, LITERAL: 4, BRALITERAL: 5, NonReserved: 6, LiteralWithSpaces: 7, main: 8, Statements: 9, EOF: 10, Statements_group0: 11, AStatement: 12, ExplainStatement: 13, EXPLAIN: 14, QUERY: 15, PLAN: 16, Statement: 17, AlterTable: 18, AttachDatabase: 19, Call: 20, CreateDatabase: 21, CreateIndex: 22, CreateGraph: 23, CreateTable: 24, CreateView: 25, CreateEdge: 26, CreateVertex: 27, Declare: 28, Delete: 29, DetachDatabase: 30, DropDatabase: 31, DropIndex: 32, DropTable: 33, DropView: 34, If: 35, Insert: 36, Merge: 37, Reindex: 38, RenameTable: 39, Select: 40, ShowCreateTable: 41, ShowColumns: 42, ShowDatabases: 43, ShowIndex: 44, ShowTables: 45, TruncateTable: 46, WithSelect: 47, CreateTrigger: 48, DropTrigger: 49, BeginTransaction: 50, CommitTransaction: 51, RollbackTransaction: 52, EndTransaction: 53, UseDatabase: 54, Update: 55, JavaScript: 56, Source: 57, Assert: 58, While: 59, Continue: 60, Break: 61, BeginEnd: 62, Print: 63, Require: 64, SetVariable: 65, ExpressionStatement: 66, AddRule: 67, Query: 68, Echo: 69, CreateFunction: 70, CreateAggregate: 71, WITH: 72, WithTablesList: 73, COMMA: 74, WithTable: 75, AS: 76, LPAR: 77, RPAR: 78, SelectClause: 79, Select_option0: 80, IntoClause: 81, FromClause: 82, Select_option1: 83, WhereClause: 84, GroupClause: 85, OrderClause: 86, LimitClause: 87, UnionClause: 88, SEARCH: 89, Select_repetition0: 90, Select_option2: 91, PivotClause: 92, PIVOT: 93, Expression: 94, FOR: 95, PivotClause_option0: 96, PivotClause_option1: 97, UNPIVOT: 98, IN: 99, ColumnsList: 100, PivotClause_option2: 101, PivotClause2: 102, AsList: 103, AsLiteral: 104, AsPart: 105, RemoveClause: 106, REMOVE: 107, RemoveClause_option0: 108, RemoveColumnsList: 109, RemoveColumn: 110, Column: 111, LIKE: 112, StringValue: 113, ArrowDot: 114, ARROW: 115, DOT: 116, SearchSelector: 117, ORDER: 118, BY: 119, OrderExpressionsList: 120, SearchSelector_option0: 121, DOTDOT: 122, CARET: 123, EQ: 124, SearchSelector_repetition_plus0: 125, SearchSelector_repetition_plus1: 126, SearchSelector_option1: 127, WHERE: 128, OF: 129, CLASS: 130, NUMBER: 131, STRING: 132, SLASH: 133, VERTEX: 134, EDGE: 135, EXCLAMATION: 136, SHARP: 137, MODULO: 138, GT: 139, LT: 140, GTGT: 141, LTLT: 142, DOLLAR: 143, Json: 144, AT: 145, SET: 146, SetColumnsList: 147, TO: 148, VALUE: 149, ROW: 150, ExprList: 151, COLON: 152, PlusStar: 153, NOT: 154, SearchSelector_repetition2: 155, IF: 156, SearchSelector_repetition3: 157, Aggregator: 158, SearchSelector_repetition4: 159, SearchSelector_group0: 160, SearchSelector_repetition5: 161, UNION: 162, SearchSelectorList: 163, ALL: 164, SearchSelector_repetition6: 165, ANY: 166, SearchSelector_repetition7: 167, INTERSECT: 168, EXCEPT: 169, AND: 170, OR: 171, PATH: 172, RETURN: 173, ResultColumns: 174, REPEAT: 175, SearchSelector_repetition8: 176, SearchSelectorList_repetition0: 177, SearchSelectorList_repetition1: 178, PLUS: 179, STAR: 180, QUESTION: 181, SearchFrom: 182, FROM: 183, SelectModifier: 184, DISTINCT: 185, TopClause: 186, UNIQUE: 187, SelectClause_option0: 188, SELECT: 189, COLUMN: 190, MATRIX: 191, TEXTSTRING: 192, INDEX: 193, RECORDSET: 194, TOP: 195, NumValue: 196, TopClause_option0: 197, INTO: 198, Table: 199, FuncValue: 200, ParamValue: 201, VarValue: 202, FromTablesList: 203, JoinTablesList: 204, ApplyClause: 205, CROSS: 206, APPLY: 207, OUTER: 208, FromTable: 209, FromTable_option0: 210, FromTable_option1: 211, INDEXED: 212, INSERTED: 213, FromString: 214, JoinTable: 215, JoinMode: 216, JoinTableAs: 217, OnClause: 218, JoinTableAs_option0: 219, JoinTableAs_option1: 220, JoinModeMode: 221, NATURAL: 222, JOIN: 223, INNER: 224, LEFT: 225, RIGHT: 226, FULL: 227, SEMI: 228, ANTI: 229, ON: 230, USING: 231, GROUP: 232, GroupExpressionsList: 233, HavingClause: 234, GroupExpression: 235, GROUPING: 236, ROLLUP: 237, CUBE: 238, HAVING: 239, CORRESPONDING: 240, OrderExpression: 241, NullsOrder: 242, NULLS: 243, FIRST: 244, LAST: 245, DIRECTION: 246, COLLATE: 247, NOCASE: 248, LIMIT: 249, OffsetClause: 250, OFFSET: 251, LimitClause_option0: 252, FETCH: 253, LimitClause_option1: 254, LimitClause_option2: 255, LimitClause_option3: 256, ResultColumn: 257, Star: 258, AggrValue: 259, Op: 260, LogicValue: 261, NullValue: 262, ExistsValue: 263, CaseValue: 264, CastClause: 265, ArrayValue: 266, NewClause: 267, Expression_group0: 268, CURRENT_TIMESTAMP: 269, JAVASCRIPT: 270, CREATE: 271, FUNCTION: 272, AGGREGATE: 273, NEW: 274, CAST: 275, ColumnType: 276, CONVERT: 277, PrimitiveValue: 278, OverClause: 279, OVER: 280, OverPartitionClause: 281, OverOrderByClause: 282, PARTITION: 283, SUM: 284, TOTAL: 285, COUNT: 286, MIN: 287, MAX: 288, AVG: 289, AGGR: 290, ARRAY: 291, FuncValue_option0: 292, REPLACE: 293, DATEADD: 294, DATEDIFF: 295, TIMESTAMPDIFF: 296, INTERVAL: 297, TRUE: 298, FALSE: 299, NSTRING: 300, NULL: 301, EXISTS: 302, ARRAYLBRA: 303, RBRA: 304, ParamValue_group0: 305, BRAQUESTION: 306, CASE: 307, WhensList: 308, ElseClause: 309, END: 310, When: 311, WHEN: 312, THEN: 313, ELSE: 314, REGEXP: 315, TILDA: 316, GLOB: 317, ESCAPE: 318, NOT_LIKE: 319, BARBAR: 320, MINUS: 321, AMPERSAND: 322, BAR: 323, GE: 324, LE: 325, EQEQ: 326, EQEQEQ: 327, NE: 328, NEEQEQ: 329, NEEQEQEQ: 330, CondOp: 331, AllSome: 332, ColFunc: 333, BETWEEN: 334, NOT_BETWEEN: 335, IS: 336, DOUBLECOLON: 337, SOME: 338, UPDATE: 339, SetColumn: 340, SetColumn_group0: 341, DELETE: 342, INSERT: 343, Into: 344, Values: 345, ValuesListsList: 346, DEFAULT: 347, VALUES: 348, ValuesList: 349, Value: 350, DateValue: 351, TemporaryClause: 352, TableClass: 353, IfNotExists: 354, CreateTableDefClause: 355, CreateTableOptionsClause: 356, TABLE: 357, CreateTableOptions: 358, CreateTableOption: 359, IDENTITY: 360, TEMP: 361, ColumnDefsList: 362, ConstraintsList: 363, Constraint: 364, ConstraintName: 365, PrimaryKey: 366, ForeignKey: 367, UniqueKey: 368, IndexKey: 369, Check: 370, CONSTRAINT: 371, CHECK: 372, PRIMARY: 373, KEY: 374, PrimaryKey_option0: 375, ColsList: 376, FOREIGN: 377, REFERENCES: 378, ForeignKey_option0: 379, OnForeignKeyClause: 380, ParColsList: 381, OnDeleteClause: 382, OnUpdateClause: 383, NO: 384, ACTION: 385, UniqueKey_option0: 386, UniqueKey_option1: 387, ColumnDef: 388, ColumnConstraintsClause: 389, ColumnConstraints: 390, SingularColumnType: 391, NumberMax: 392, ENUM: 393, MAXNUM: 394, ColumnConstraintsList: 395, ColumnConstraint: 396, ParLiteral: 397, ColumnConstraint_option0: 398, ColumnConstraint_option1: 399, DROP: 400, DropTable_group0: 401, IfExists: 402, TablesList: 403, ALTER: 404, RENAME: 405, ADD: 406, MODIFY: 407, ATTACH: 408, DATABASE: 409, DETACH: 410, AsClause: 411, USE: 412, SHOW: 413, VIEW: 414, CreateView_option0: 415, CreateView_option1: 416, SubqueryRestriction: 417, READ: 418, ONLY: 419, OPTION: 420, SOURCE: 421, ASSERT: 422, JsonObject: 423, ATLBRA: 424, JsonArray: 425, JsonValue: 426, JsonPrimitiveValue: 427, LCUR: 428, JsonPropertiesList: 429, RCUR: 430, JsonElementsList: 431, JsonProperty: 432, OnOff: 433, SetPropsList: 434, AtDollar: 435, SetProp: 436, OFF: 437, COMMIT: 438, TRANSACTION: 439, ROLLBACK: 440, BEGIN: 441, ElseStatement: 442, WHILE: 443, CONTINUE: 444, BREAK: 445, PRINT: 446, REQUIRE: 447, StringValuesList: 448, PluginsList: 449, Plugin: 450, ECHO: 451, DECLARE: 452, DeclaresList: 453, DeclareItem: 454, TRUNCATE: 455, MERGE: 456, MergeInto: 457, MergeUsing: 458, MergeOn: 459, MergeMatchedList: 460, OutputClause: 461, MergeMatched: 462, MergeNotMatched: 463, MATCHED: 464, MergeMatchedAction: 465, MergeNotMatchedAction: 466, TARGET: 467, OUTPUT: 468, CreateVertex_option0: 469, CreateVertex_option1: 470, CreateVertex_option2: 471, CreateVertexSet: 472, SharpValue: 473, CONTENT: 474, CreateEdge_option0: 475, GRAPH: 476, GraphList: 477, GraphVertexEdge: 478, GraphElement: 479, GraphVertexEdge_option0: 480, GraphVertexEdge_option1: 481, GraphElementVar: 482, GraphVertexEdge_option2: 483, GraphVertexEdge_option3: 484, GraphVertexEdge_option4: 485, GraphVar: 486, GraphAsClause: 487, GraphAtClause: 488, GraphElement2: 489, GraphElement2_option0: 490, GraphElement2_option1: 491, GraphElement2_option2: 492, GraphElement2_option3: 493, GraphElement_option0: 494, GraphElement_option1: 495, GraphElement_option2: 496, SharpLiteral: 497, GraphElement_option3: 498, GraphElement_option4: 499, GraphElement_option5: 500, ColonLiteral: 501, DeleteVertex: 502, DeleteVertex_option0: 503, DeleteEdge: 504, DeleteEdge_option0: 505, DeleteEdge_option1: 506, DeleteEdge_option2: 507, Term: 508, COLONDASH: 509, TermsList: 510, QUESTIONDASH: 511, CALL: 512, TRIGGER: 513, BeforeAfter: 514, InsertDeleteUpdate: 515, CreateTrigger_option0: 516, CreateTrigger_option1: 517, BEFORE: 518, AFTER: 519, INSTEAD: 520, REINDEX: 521, A: 522, ABSENT: 523, ABSOLUTE: 524, ACCORDING: 525, ADA: 526, ADMIN: 527, ALWAYS: 528, ASC: 529, ASSERTION: 530, ASSIGNMENT: 531, ATTRIBUTE: 532, ATTRIBUTES: 533, BASE64: 534, BERNOULLI: 535, BLOCKED: 536, BOM: 537, BREADTH: 538, C: 539, CASCADE: 540, CATALOG: 541, CATALOG_NAME: 542, CHAIN: 543, CHARACTERISTICS: 544, CHARACTERS: 545, CHARACTER_SET_CATALOG: 546, CHARACTER_SET_NAME: 547, CHARACTER_SET_SCHEMA: 548, CLASS_ORIGIN: 549, COBOL: 550, COLLATION: 551, COLLATION_CATALOG: 552, COLLATION_NAME: 553, COLLATION_SCHEMA: 554, COLUMNS: 555, COLUMN_NAME: 556, COMMAND_FUNCTION: 557, COMMAND_FUNCTION_CODE: 558, COMMITTED: 559, CONDITION_NUMBER: 560, CONNECTION: 561, CONNECTION_NAME: 562, CONSTRAINTS: 563, CONSTRAINT_CATALOG: 564, CONSTRAINT_NAME: 565, CONSTRAINT_SCHEMA: 566, CONSTRUCTOR: 567, CONTROL: 568, CURSOR_NAME: 569, DATA: 570, DATETIME_INTERVAL_CODE: 571, DATETIME_INTERVAL_PRECISION: 572, DB: 573, DEFAULTS: 574, DEFERRABLE: 575, DEFERRED: 576, DEFINED: 577, DEFINER: 578, DEGREE: 579, DEPTH: 580, DERIVED: 581, DESC: 582, DESCRIPTOR: 583, DIAGNOSTICS: 584, DISPATCH: 585, DOCUMENT: 586, DOMAIN: 587, DYNAMIC_FUNCTION: 588, DYNAMIC_FUNCTION_CODE: 589, EMPTY: 590, ENCODING: 591, ENFORCED: 592, EXCLUDE: 593, EXCLUDING: 594, EXPRESSION: 595, FILE: 596, FINAL: 597, FLAG: 598, FOLLOWING: 599, FORTRAN: 600, FOUND: 601, FS: 602, G: 603, GENERAL: 604, GENERATED: 605, GO: 606, GOTO: 607, GRANTED: 608, HEX: 609, HIERARCHY: 610, ID: 611, IGNORE: 612, IMMEDIATE: 613, IMMEDIATELY: 614, IMPLEMENTATION: 615, INCLUDING: 616, INCREMENT: 617, INDENT: 618, INITIALLY: 619, INPUT: 620, INSTANCE: 621, INSTANTIABLE: 622, INTEGRITY: 623, INVOKER: 624, ISOLATION: 625, K: 626, KEY_MEMBER: 627, KEY_TYPE: 628, LENGTH: 629, LEVEL: 630, LIBRARY: 631, LINK: 632, LOCATION: 633, LOCATOR: 634, M: 635, MAP: 636, MAPPING: 637, MAXVALUE: 638, MESSAGE_LENGTH: 639, MESSAGE_OCTET_LENGTH: 640, MESSAGE_TEXT: 641, MINVALUE: 642, MORE: 643, MUMPS: 644, NAME: 645, NAMES: 646, NAMESPACE: 647, NESTING: 648, NEXT: 649, NFC: 650, NFD: 651, NFKC: 652, NFKD: 653, NIL: 654, NORMALIZED: 655, NULLABLE: 656, OBJECT: 657, OCTETS: 658, OPTIONS: 659, ORDERING: 660, ORDINALITY: 661, OTHERS: 662, OVERRIDING: 663, P: 664, PAD: 665, PARAMETER_MODE: 666, PARAMETER_NAME: 667, PARAMETER_ORDINAL_POSITION: 668, PARAMETER_SPECIFIC_CATALOG: 669, PARAMETER_SPECIFIC_NAME: 670, PARAMETER_SPECIFIC_SCHEMA: 671, PARTIAL: 672, PASCAL: 673, PASSING: 674, PASSTHROUGH: 675, PERMISSION: 676, PLACING: 677, PLI: 678, PRECEDING: 679, PRESERVE: 680, PRIOR: 681, PRIVILEGES: 682, PUBLIC: 683, RECOVERY: 684, RELATIVE: 685, REPEATABLE: 686, REQUIRING: 687, RESPECT: 688, RESTART: 689, RESTORE: 690, RESTRICT: 691, RETURNED_CARDINALITY: 692, RETURNED_LENGTH: 693, RETURNED_OCTET_LENGTH: 694, RETURNED_SQLSTATE: 695, RETURNING: 696, ROLE: 697, ROUTINE: 698, ROUTINE_CATALOG: 699, ROUTINE_NAME: 700, ROUTINE_SCHEMA: 701, ROW_COUNT: 702, SCALE: 703, SCHEMA: 704, SCHEMA_NAME: 705, SCOPE_CATALOG: 706, SCOPE_NAME: 707, SCOPE_SCHEMA: 708, SECTION: 709, SECURITY: 710, SELECTIVE: 711, SELF: 712, SEQUENCE: 713, SERIALIZABLE: 714, SERVER: 715, SERVER_NAME: 716, SESSION: 717, SETS: 718, SIMPLE: 719, SIZE: 720, SPACE: 721, SPECIFIC_NAME: 722, STANDALONE: 723, STATE: 724, STATEMENT: 725, STRIP: 726, STRUCTURE: 727, STYLE: 728, SUBCLASS_ORIGIN: 729, T: 730, TABLE_NAME: 731, TEMPORARY: 732, TIES: 733, TOKEN: 734, TOP_LEVEL_COUNT: 735, TRANSACTIONS_COMMITTED: 736, TRANSACTIONS_ROLLED_BACK: 737, TRANSACTION_ACTIVE: 738, TRANSFORM: 739, TRANSFORMS: 740, TRIGGER_CATALOG: 741, TRIGGER_NAME: 742, TRIGGER_SCHEMA: 743, TYPE: 744, UNBOUNDED: 745, UNCOMMITTED: 746, UNDER: 747, UNLINK: 748, UNNAMED: 749, UNTYPED: 750, URI: 751, USAGE: 752, USER_DEFINED_TYPE_CATALOG: 753, USER_DEFINED_TYPE_CODE: 754, USER_DEFINED_TYPE_NAME: 755, USER_DEFINED_TYPE_SCHEMA: 756, VALID: 757, VERSION: 758, WHITESPACE: 759, WORK: 760, WRAPPER: 761, WRITE: 762, XMLDECLARATION: 763, XMLSCHEMA: 764, YES: 765, ZONE: 766, SEMICOLON: 767, PERCENT: 768, ROWS: 769, FuncValue_option0_group0: 770, $accept: 0, $end: 1 }, terminals_: { 2: "error", 4: "LITERAL", 5: "BRALITERAL", 10: "EOF", 14: "EXPLAIN", 15: "QUERY", 16: "PLAN", 53: "EndTransaction", 72: "WITH", 74: "COMMA", 76: "AS", 77: "LPAR", 78: "RPAR", 89: "SEARCH", 93: "PIVOT", 95: "FOR", 98: "UNPIVOT", 99: "IN", 107: "REMOVE", 112: "LIKE", 115: "ARROW", 116: "DOT", 118: "ORDER", 119: "BY", 122: "DOTDOT", 123: "CARET", 124: "EQ", 128: "WHERE", 129: "OF", 130: "CLASS", 131: "NUMBER", 132: "STRING", 133: "SLASH", 134: "VERTEX", 135: "EDGE", 136: "EXCLAMATION", 137: "SHARP", 138: "MODULO", 139: "GT", 140: "LT", 141: "GTGT", 142: "LTLT", 143: "DOLLAR", 145: "AT", 146: "SET", 148: "TO", 149: "VALUE", 150: "ROW", 152: "COLON", 154: "NOT", 156: "IF", 162: "UNION", 164: "ALL", 166: "ANY", 168: "INTERSECT", 169: "EXCEPT", 170: "AND", 171: "OR", 172: "PATH", 173: "RETURN", 175: "REPEAT", 179: "PLUS", 180: "STAR", 181: "QUESTION", 183: "FROM", 185: "DISTINCT", 187: "UNIQUE", 189: "SELECT", 190: "COLUMN", 191: "MATRIX", 192: "TEXTSTRING", 193: "INDEX", 194: "RECORDSET", 195: "TOP", 198: "INTO", 206: "CROSS", 207: "APPLY", 208: "OUTER", 212: "INDEXED", 213: "INSERTED", 222: "NATURAL", 223: "JOIN", 224: "INNER", 225: "LEFT", 226: "RIGHT", 227: "FULL", 228: "SEMI", 229: "ANTI", 230: "ON", 231: "USING", 232: "GROUP", 236: "GROUPING", 237: "ROLLUP", 238: "CUBE", 239: "HAVING", 240: "CORRESPONDING", 243: "NULLS", 244: "FIRST", 245: "LAST", 246: "DIRECTION", 247: "COLLATE", 248: "NOCASE", 249: "LIMIT", 251: "OFFSET", 253: "FETCH", 269: "CURRENT_TIMESTAMP", 270: "JAVASCRIPT", 271: "CREATE", 272: "FUNCTION", 273: "AGGREGATE", 274: "NEW", 275: "CAST", 277: "CONVERT", 280: "OVER", 283: "PARTITION", 284: "SUM", 285: "TOTAL", 286: "COUNT", 287: "MIN", 288: "MAX", 289: "AVG", 290: "AGGR", 291: "ARRAY", 293: "REPLACE", 294: "DATEADD", 295: "DATEDIFF", 296: "TIMESTAMPDIFF", 297: "INTERVAL", 298: "TRUE", 299: "FALSE", 300: "NSTRING", 301: "NULL", 302: "EXISTS", 303: "ARRAYLBRA", 304: "RBRA", 306: "BRAQUESTION", 307: "CASE", 310: "END", 312: "WHEN", 313: "THEN", 314: "ELSE", 315: "REGEXP", 316: "TILDA", 317: "GLOB", 318: "ESCAPE", 319: "NOT_LIKE", 320: "BARBAR", 321: "MINUS", 322: "AMPERSAND", 323: "BAR", 324: "GE", 325: "LE", 326: "EQEQ", 327: "EQEQEQ", 328: "NE", 329: "NEEQEQ", 330: "NEEQEQEQ", 334: "BETWEEN", 335: "NOT_BETWEEN", 336: "IS", 337: "DOUBLECOLON", 338: "SOME", 339: "UPDATE", 342: "DELETE", 343: "INSERT", 347: "DEFAULT", 348: "VALUES", 351: "DateValue", 357: "TABLE", 360: "IDENTITY", 361: "TEMP", 371: "CONSTRAINT", 372: "CHECK", 373: "PRIMARY", 374: "KEY", 377: "FOREIGN", 378: "REFERENCES", 384: "NO", 385: "ACTION", 390: "ColumnConstraints", 393: "ENUM", 394: "MAXNUM", 400: "DROP", 404: "ALTER", 405: "RENAME", 406: "ADD", 407: "MODIFY", 408: "ATTACH", 409: "DATABASE", 410: "DETACH", 412: "USE", 413: "SHOW", 414: "VIEW", 418: "READ", 419: "ONLY", 420: "OPTION", 421: "SOURCE", 422: "ASSERT", 424: "ATLBRA", 428: "LCUR", 430: "RCUR", 437: "OFF", 438: "COMMIT", 439: "TRANSACTION", 440: "ROLLBACK", 441: "BEGIN", 443: "WHILE", 444: "CONTINUE", 445: "BREAK", 446: "PRINT", 447: "REQUIRE", 451: "ECHO", 452: "DECLARE", 455: "TRUNCATE", 456: "MERGE", 464: "MATCHED", 467: "TARGET", 468: "OUTPUT", 474: "CONTENT", 476: "GRAPH", 509: "COLONDASH", 511: "QUESTIONDASH", 512: "CALL", 513: "TRIGGER", 518: "BEFORE", 519: "AFTER", 520: "INSTEAD", 521: "REINDEX", 522: "A", 523: "ABSENT", 524: "ABSOLUTE", 525: "ACCORDING", 526: "ADA", 527: "ADMIN", 528: "ALWAYS", 529: "ASC", 530: "ASSERTION", 531: "ASSIGNMENT", 532: "ATTRIBUTE", 533: "ATTRIBUTES", 534: "BASE64", 535: "BERNOULLI", 536: "BLOCKED", 537: "BOM", 538: "BREADTH", 539: "C", 540: "CASCADE", 541: "CATALOG", 542: "CATALOG_NAME", 543: "CHAIN", 544: "CHARACTERISTICS", 545: "CHARACTERS", 546: "CHARACTER_SET_CATALOG", 547: "CHARACTER_SET_NAME", 548: "CHARACTER_SET_SCHEMA", 549: "CLASS_ORIGIN", 550: "COBOL", 551: "COLLATION", 552: "COLLATION_CATALOG", 553: "COLLATION_NAME", 554: "COLLATION_SCHEMA", 555: "COLUMNS", 556: "COLUMN_NAME", 557: "COMMAND_FUNCTION", 558: "COMMAND_FUNCTION_CODE", 559: "COMMITTED", 560: "CONDITION_NUMBER", 561: "CONNECTION", 562: "CONNECTION_NAME", 563: "CONSTRAINTS", 564: "CONSTRAINT_CATALOG", 565: "CONSTRAINT_NAME", 566: "CONSTRAINT_SCHEMA", 567: "CONSTRUCTOR", 568: "CONTROL", 569: "CURSOR_NAME", 570: "DATA", 571: "DATETIME_INTERVAL_CODE", 572: "DATETIME_INTERVAL_PRECISION", 573: "DB", 574: "DEFAULTS", 575: "DEFERRABLE", 576: "DEFERRED", 577: "DEFINED", 578: "DEFINER", 579: "DEGREE", 580: "DEPTH", 581: "DERIVED", 582: "DESC", 583: "DESCRIPTOR", 584: "DIAGNOSTICS", 585: "DISPATCH", 586: "DOCUMENT", 587: "DOMAIN", 588: "DYNAMIC_FUNCTION", 589: "DYNAMIC_FUNCTION_CODE", 590: "EMPTY", 591: "ENCODING", 592: "ENFORCED", 593: "EXCLUDE", 594: "EXCLUDING", 595: "EXPRESSION", 596: "FILE", 597: "FINAL", 598: "FLAG", 599: "FOLLOWING", 600: "FORTRAN", 601: "FOUND", 602: "FS", 603: "G", 604: "GENERAL", 605: "GENERATED", 606: "GO", 607: "GOTO", 608: "GRANTED", 609: "HEX", 610: "HIERARCHY", 611: "ID", 612: "IGNORE", 613: "IMMEDIATE", 614: "IMMEDIATELY", 615: "IMPLEMENTATION", 616: "INCLUDING", 617: "INCREMENT", 618: "INDENT", 619: "INITIALLY", 620: "INPUT", 621: "INSTANCE", 622: "INSTANTIABLE", 623: "INTEGRITY", 624: "INVOKER", 625: "ISOLATION", 626: "K", 627: "KEY_MEMBER", 628: "KEY_TYPE", 629: "LENGTH", 630: "LEVEL", 631: "LIBRARY", 632: "LINK", 633: "LOCATION", 634: "LOCATOR", 635: "M", 636: "MAP", 637: "MAPPING", 638: "MAXVALUE", 639: "MESSAGE_LENGTH", 640: "MESSAGE_OCTET_LENGTH", 641: "MESSAGE_TEXT", 642: "MINVALUE", 643: "MORE", 644: "MUMPS", 645: "NAME", 646: "NAMES", 647: "NAMESPACE", 648: "NESTING", 649: "NEXT", 650: "NFC", 651: "NFD", 652: "NFKC", 653: "NFKD", 654: "NIL", 655: "NORMALIZED", 656: "NULLABLE", 657: "OBJECT", 658: "OCTETS", 659: "OPTIONS", 660: "ORDERING", 661: "ORDINALITY", 662: "OTHERS", 663: "OVERRIDING", 664: "P", 665: "PAD", 666: "PARAMETER_MODE", 667: "PARAMETER_NAME", 668: "PARAMETER_ORDINAL_POSITION", 669: "PARAMETER_SPECIFIC_CATALOG", 670: "PARAMETER_SPECIFIC_NAME", 671: "PARAMETER_SPECIFIC_SCHEMA", 672: "PARTIAL", 673: "PASCAL", 674: "PASSING", 675: "PASSTHROUGH", 676: "PERMISSION", 677: "PLACING", 678: "PLI", 679: "PRECEDING", 680: "PRESERVE", 681: "PRIOR", 682: "PRIVILEGES", 683: "PUBLIC", 684: "RECOVERY", 685: "RELATIVE", 686: "REPEATABLE", 687: "REQUIRING", 688: "RESPECT", 689: "RESTART", 690: "RESTORE", 691: "RESTRICT", 692: "RETURNED_CARDINALITY", 693: "RETURNED_LENGTH", 694: "RETURNED_OCTET_LENGTH", 695: "RETURNED_SQLSTATE", 696: "RETURNING", 697: "ROLE", 698: "ROUTINE", 699: "ROUTINE_CATALOG", 700: "ROUTINE_NAME", 701: "ROUTINE_SCHEMA", 702: "ROW_COUNT", 703: "SCALE", 704: "SCHEMA", 705: "SCHEMA_NAME", 706: "SCOPE_CATALOG", 707: "SCOPE_NAME", 708: "SCOPE_SCHEMA", 709: "SECTION", 710: "SECURITY", 711: "SELECTIVE", 712: "SELF", 713: "SEQUENCE", 714: "SERIALIZABLE", 715: "SERVER", 716: "SERVER_NAME", 717: "SESSION", 718: "SETS", 719: "SIMPLE", 720: "SIZE", 721: "SPACE", 722: "SPECIFIC_NAME", 723: "STANDALONE", 724: "STATE", 725: "STATEMENT", 726: "STRIP", 727: "STRUCTURE", 728: "STYLE", 729: "SUBCLASS_ORIGIN", 730: "T", 731: "TABLE_NAME", 732: "TEMPORARY", 733: "TIES", 734: "TOKEN", 735: "TOP_LEVEL_COUNT", 736: "TRANSACTIONS_COMMITTED", 737: "TRANSACTIONS_ROLLED_BACK", 738: "TRANSACTION_ACTIVE", 739: "TRANSFORM", 740: "TRANSFORMS", 741: "TRIGGER_CATALOG", 742: "TRIGGER_NAME", 743: "TRIGGER_SCHEMA", 744: "TYPE", 745: "UNBOUNDED", 746: "UNCOMMITTED", 747: "UNDER", 748: "UNLINK", 749: "UNNAMED", 750: "UNTYPED", 751: "URI", 752: "USAGE", 753: "USER_DEFINED_TYPE_CATALOG", 754: "USER_DEFINED_TYPE_CODE", 755: "USER_DEFINED_TYPE_NAME", 756: "USER_DEFINED_TYPE_SCHEMA", 757: "VALID", 758: "VERSION", 759: "WHITESPACE", 760: "WORK", 761: "WRAPPER", 762: "WRITE", 763: "XMLDECLARATION", 764: "XMLSCHEMA", 765: "YES", 766: "ZONE", 767: "SEMICOLON", 768: "PERCENT", 769: "ROWS" }, productions_: [0, [3, 1], [3, 1], [3, 2], [7, 1], [7, 2], [8, 2], [9, 3], [9, 1], [9, 1], [13, 2], [13, 4], [12, 1], [17, 0], [17, 1], [17, 1], [17, 1], [17, 1], [17, 1], [17, 1], [17, 1], [17, 1], [17, 1], [17, 1], [17, 1], [17, 1], [17, 1], [17, 1], [17, 1], [17, 1], [17, 1], [17, 1], [17, 1], [17, 1], [17, 1], [17, 1], [17, 1], [17, 1], [17, 1], [17, 1], [17, 1], [17, 1], [17, 1], [17, 1], [17, 1], [17, 1], [17, 1], [17, 1], [17, 1], [17, 1], [17, 1], [17, 1], [17, 1], [17, 1], [17, 1], [17, 1], [17, 1], [17, 1], [17, 1], [17, 1], [17, 1], [17, 1], [17, 1], [17, 1], [17, 1], [17, 1], [17, 1], [17, 1], [47, 3], [73, 3], [73, 1], [75, 5], [40, 10], [40, 4], [92, 8], [92, 11], [102, 4], [104, 2], [104, 1], [103, 3], [103, 1], [105, 1], [105, 3], [106, 3], [109, 3], [109, 1], [110, 1], [110, 2], [114, 1], [114, 1], [117, 1], [117, 5], [117, 5], [117, 1], [117, 2], [117, 1], [117, 2], [117, 2], [117, 3], [117, 4], [117, 4], [117, 4], [117, 4], [117, 4], [117, 1], [117, 1], [117, 1], [117, 1], [117, 1], [117, 1], [117, 2], [117, 2], [117, 2], [117, 1], [117, 1], [117, 1], [117, 1], [117, 1], [117, 1], [117, 2], [117, 3], [117, 4], [117, 3], [117, 1], [117, 4], [117, 2], [117, 2], [117, 4], [117, 4], [117, 4], [117, 4], [117, 4], [117, 5], [117, 4], [117, 4], [117, 4], [117, 4], [117, 4], [117, 4], [117, 4], [117, 4], [117, 6], [163, 3], [163, 1], [153, 1], [153, 1], [153, 1], [182, 2], [79, 4], [79, 4], [79, 4], [79, 3], [184, 1], [184, 2], [184, 2], [184, 2], [184, 2], [184, 2], [184, 2], [184, 2], [186, 3], [186, 4], [186, 0], [81, 0], [81, 2], [81, 2], [81, 2], [81, 2], [81, 2], [82, 2], [82, 3], [82, 5], [82, 0], [205, 6], [205, 7], [205, 6], [205, 7], [203, 1], [203, 3], [209, 4], [209, 5], [209, 3], [209, 3], [209, 2], [209, 3], [209, 1], [209, 3], [209, 2], [209, 3], [209, 1], [209, 1], [209, 2], [209, 3], [209, 1], [209, 1], [209, 2], [209, 3], [209, 1], [209, 2], [209, 3], [214, 1], [199, 3], [199, 1], [204, 2], [204, 2], [204, 1], [204, 1], [215, 3], [217, 1], [217, 2], [217, 3], [217, 3], [217, 2], [217, 3], [217, 4], [217, 5], [217, 1], [217, 2], [217, 3], [217, 1], [217, 2], [217, 3], [216, 1], [216, 2], [221, 1], [221, 2], [221, 2], [221, 3], [221, 2], [221, 3], [221, 2], [221, 3], [221, 2], [221, 2], [221, 2], [218, 2], [218, 2], [218, 0], [84, 0], [84, 2], [85, 0], [85, 4], [233, 1], [233, 3], [235, 5], [235, 4], [235, 4], [235, 1], [234, 0], [234, 2], [88, 0], [88, 2], [88, 3], [88, 2], [88, 2], [88, 3], [88, 4], [88, 3], [88, 3], [86, 0], [86, 3], [120, 1], [120, 3], [242, 2], [242, 2], [241, 1], [241, 2], [241, 3], [241, 3], [241, 4], [87, 0], [87, 3], [87, 8], [250, 0], [250, 2], [174, 3], [174, 1], [257, 3], [257, 2], [257, 3], [257, 2], [257, 3], [257, 2], [257, 1], [258, 5], [258, 3], [258, 1], [111, 5], [111, 3], [111, 3], [111, 1], [94, 1], [94, 1], [94, 1], [94, 1], [94, 1], [94, 1], [94, 1], [94, 1], [94, 1], [94, 1], [94, 1], [94, 1], [94, 1], [94, 1], [94, 1], [94, 1], [94, 1], [94, 1], [94, 3], [94, 3], [94, 3], [94, 1], [94, 1], [56, 1], [70, 5], [71, 5], [267, 2], [267, 2], [265, 6], [265, 8], [265, 6], [265, 8], [278, 1], [278, 1], [278, 1], [278, 1], [278, 1], [278, 1], [278, 1], [259, 5], [259, 6], [259, 6], [279, 0], [279, 4], [279, 4], [279, 5], [281, 3], [282, 3], [158, 1], [158, 1], [158, 1], [158, 1], [158, 1], [158, 1], [158, 1], [158, 1], [158, 1], [158, 1], [200, 5], [200, 3], [200, 4], [200, 4], [200, 8], [200, 8], [200, 8], [200, 8], [200, 8], [200, 3], [151, 1], [151, 3], [196, 1], [261, 1], [261, 1], [113, 1], [113, 1], [262, 1], [202, 2], [263, 4], [266, 3], [201, 2], [201, 2], [201, 1], [201, 1], [264, 5], [264, 4], [308, 2], [308, 1], [311, 4], [309, 2], [309, 0], [260, 3], [260, 3], [260, 3], [260, 3], [260, 5], [260, 3], [260, 5], [260, 3], [260, 3], [260, 3], [260, 3], [260, 3], [260, 3], [260, 3], [260, 3], [260, 3], [260, 3], [260, 3], [260, 3], [260, 3], [260, 5], [260, 3], [260, 3], [260, 3], [260, 5], [260, 3], [260, 3], [260, 3], [260, 3], [260, 3], [260, 3], [260, 3], [260, 3], [260, 3], [260, 3], [260, 3], [260, 6], [260, 6], [260, 3], [260, 3], [260, 2], [260, 2], [260, 2], [260, 2], [260, 2], [260, 3], [260, 5], [260, 6], [260, 5], [260, 6], [260, 4], [260, 5], [260, 3], [260, 4], [260, 3], [260, 4], [260, 3], [260, 3], [260, 3], [260, 3], [260, 3], [333, 1], [333, 1], [333, 4], [331, 1], [331, 1], [331, 1], [331, 1], [331, 1], [331, 1], [332, 1], [332, 1], [332, 1], [55, 6], [55, 4], [147, 1], [147, 3], [340, 3], [340, 4], [29, 5], [29, 3], [36, 5], [36, 4], [36, 7], [36, 6], [36, 5], [36, 4], [36, 5], [36, 8], [36, 7], [36, 4], [36, 6], [36, 7], [345, 1], [345, 1], [344, 0], [344, 1], [346, 3], [346, 1], [346, 1], [346, 5], [346, 3], [346, 3], [349, 1], [349, 3], [350, 1], [350, 1], [350, 1], [350, 1], [350, 1], [350, 1], [100, 1], [100, 3], [24, 9], [24, 5], [353, 1], [353, 1], [356, 0], [356, 1], [358, 2], [358, 1], [359, 1], [359, 3], [359, 3], [359, 3], [352, 0], [352, 1], [354, 0], [354, 3], [355, 3], [355, 1], [355, 2], [363, 1], [363, 3], [364, 2], [364, 2], [364, 2], [364, 2], [364, 2], [365, 0], [365, 2], [370, 4], [366, 6], [367, 9], [381, 3], [380, 0], [380, 2], [382, 4], [383, 4], [368, 6], [369, 5], [369, 5], [376, 1], [376, 1], [376, 3], [376, 3], [362, 1], [362, 3], [388, 3], [388, 2], [388, 1], [391, 6], [391, 4], [391, 1], [391, 4], [276, 2], [276, 1], [392, 1], [392, 1], [389, 0], [389, 1], [395, 2], [395, 1], [397, 3], [396, 2], [396, 5], [396, 3], [396, 6], [396, 1], [396, 2], [396, 4], [396, 2], [396, 1], [396, 2], [396, 1], [396, 1], [396, 3], [396, 5], [33, 4], [403, 3], [403, 1], [402, 0], [402, 2], [18, 6], [18, 6], [18, 6], [18, 8], [18, 6], [39, 5], [19, 4], [19, 7], [19, 6], [19, 9], [30, 3], [21, 4], [21, 6], [21, 9], [21, 6], [411, 0], [411, 2], [54, 3], [54, 2], [31, 4], [31, 5], [31, 5], [22, 8], [22, 9], [32, 3], [43, 2], [43, 4], [43, 3], [43, 5], [45, 2], [45, 4], [45, 4], [45, 6], [42, 4], [42, 6], [44, 4], [44, 6], [41, 4], [41, 6], [25, 11], [25, 8], [417, 3], [417, 3], [417, 5], [34, 4], [66, 2], [57, 2], [58, 2], [58, 2], [58, 4], [144, 4], [144, 2], [144, 2], [144, 2], [144, 2], [144, 1], [144, 2], [144, 2], [426, 1], [426, 1], [427, 1], [427, 1], [427, 1], [427, 1], [427, 1], [427, 1], [427, 1], [427, 3], [423, 3], [423, 4], [423, 2], [425, 2], [425, 3], [425, 1], [429, 3], [429, 1], [432, 3], [432, 3], [432, 3], [431, 3], [431, 1], [65, 4], [65, 3], [65, 4], [65, 5], [65, 5], [65, 6], [435, 1], [435, 1], [434, 3], [434, 2], [436, 1], [436, 1], [436, 3], [433, 1], [433, 1], [51, 2], [52, 2], [50, 2], [35, 4], [35, 3], [442, 2], [59, 3], [60, 1], [61, 1], [62, 3], [63, 2], [63, 2], [64, 2], [64, 2], [450, 1], [450, 1], [69, 2], [448, 3], [448, 1], [449, 3], [449, 1], [28, 2], [453, 1], [453, 3], [454, 3], [454, 4], [454, 5], [454, 6], [46, 3], [37, 6], [457, 1], [457, 2], [458, 2], [459, 2], [460, 2], [460, 2], [460, 1], [460, 1], [462, 4], [462, 6], [465, 1], [465, 3], [463, 5], [463, 7], [463, 7], [463, 9], [463, 7], [463, 9], [466, 3], [466, 6], [466, 3], [466, 6], [461, 0], [461, 2], [461, 5], [461, 4], [461, 7], [27, 6], [473, 2], [472, 0], [472, 2], [472, 2], [472, 1], [26, 8], [23, 3], [23, 4], [477, 3], [477, 1], [478, 3], [478, 7], [478, 6], [478, 3], [478, 4], [482, 1], [482, 1], [486, 2], [487, 3], [488, 2], [489, 4], [479, 4], [479, 3], [479, 2], [479, 1], [501, 2], [497, 2], [497, 2], [502, 4], [504, 6], [67, 3], [67, 2], [510, 3], [510, 1], [508, 1], [508, 4], [68, 2], [20, 2], [48, 9], [48, 8], [48, 9], [514, 0], [514, 1], [514, 1], [514, 1], [514, 2], [515, 1], [515, 1], [515, 1], [49, 3], [38, 2], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [11, 1], [11, 1], [80, 0], [80, 1], [83, 0], [83, 1], [90, 0], [90, 2], [91, 0], [91, 1], [96, 0], [96, 1], [97, 0], [97, 1], [101, 0], [101, 1], [108, 0], [108, 1], [121, 0], [121, 1], [125, 1], [125, 2], [126, 1], [126, 2], [127, 0], [127, 1], [155, 0], [155, 2], [157, 0], [157, 2], [159, 0], [159, 2], [160, 1], [160, 1], [161, 0], [161, 2], [165, 0], [165, 2], [167, 0], [167, 2], [176, 0], [176, 2], [177, 0], [177, 2], [178, 0], [178, 2], [188, 0], [188, 1], [197, 0], [197, 1], [210, 0], [210, 1], [211, 0], [211, 1], [219, 0], [219, 1], [220, 0], [220, 1], [252, 0], [252, 1], [254, 0], [254, 1], [255, 0], [255, 1], [256, 0], [256, 1], [268, 1], [268, 1], [770, 1], [770, 1], [292, 0], [292, 1], [305, 1], [305, 1], [341, 1], [341, 1], [375, 0], [375, 1], [379, 0], [379, 1], [386, 0], [386, 1], [387, 0], [387, 1], [398, 0], [398, 1], [399, 0], [399, 1], [401, 1], [401, 1], [415, 0], [415, 1], [416, 0], [416, 1], [469, 0], [469, 1], [470, 0], [470, 1], [471, 0], [471, 1], [475, 0], [475, 1], [480, 0], [480, 1], [481, 0], [481, 1], [483, 0], [483, 1], [484, 0], [484, 1], [485, 0], [485, 1], [490, 0], [490, 1], [491, 0], [491, 1], [492, 0], [492, 1], [493, 0], [493, 1], [494, 0], [494, 1], [495, 0], [495, 1], [496, 0], [496, 1], [498, 0], [498, 1], [499, 0], [499, 1], [500, 0], [500, 1], [503, 0], [503, 2], [505, 0], [505, 2], [506, 0], [506, 2], [507, 0], [507, 2], [516, 0], [516, 1], [517, 0], [517, 1]], performAction: function(e5, t5, s5, n5, r5, a5, i5) {
          var o5 = a5.length - 1;
          switch (r5) {
            case 1:
              L.options.casesensitive ? this.$ = a5[o5] : this.$ = a5[o5].toLowerCase();
              break;
            case 2:
              this.$ = ys(a5[o5].substr(1, a5[o5].length - 2));
              break;
            case 3:
              this.$ = a5[o5].toLowerCase();
              break;
            case 4:
              this.$ = a5[o5];
              break;
            case 5:
              this.$ = a5[o5] ? a5[o5 - 1] + " " + a5[o5] : a5[o5 - 1];
              break;
            case 6:
              return new n5.Statements({ statements: a5[o5 - 1] });
            case 7:
              this.$ = a5[o5 - 2], a5[o5] && a5[o5 - 2].push(a5[o5]);
              break;
            case 8:
            case 9:
            case 70:
            case 80:
            case 85:
            case 143:
            case 177:
            case 205:
            case 206:
            case 242:
            case 261:
            case 276:
            case 359:
            case 377:
            case 456:
            case 479:
            case 480:
            case 484:
            case 492:
            case 533:
            case 534:
            case 571:
            case 654:
            case 664:
            case 688:
            case 690:
            case 692:
            case 706:
            case 707:
            case 737:
            case 761:
              this.$ = [a5[o5]];
              break;
            case 10:
            case 11:
              this.$ = a5[o5], a5[o5].explain = true;
              break;
            case 12:
              this.$ = a5[o5], n5.exists && (this.$.exists = n5.exists), delete n5.exists, n5.queries && (this.$.queries = n5.queries), delete n5.queries;
              break;
            case 13:
            case 162:
            case 172:
            case 237:
            case 238:
            case 240:
            case 248:
            case 250:
            case 259:
            case 270:
            case 273:
            case 380:
            case 496:
            case 506:
            case 508:
            case 520:
            case 526:
            case 527:
            case 572:
              this.$ = void 0;
              break;
            case 68:
              this.$ = new n5.WithSelect({ withs: a5[o5 - 1], select: a5[o5] });
              break;
            case 69:
            case 570:
              a5[o5 - 2].push(a5[o5]), this.$ = a5[o5 - 2];
              break;
            case 71:
              this.$ = { name: a5[o5 - 4], select: a5[o5 - 1] };
              break;
            case 72:
              n5.extend(this.$, a5[o5 - 9]), n5.extend(this.$, a5[o5 - 8]), n5.extend(this.$, a5[o5 - 7]), n5.extend(this.$, a5[o5 - 6]), n5.extend(this.$, a5[o5 - 5]), n5.extend(this.$, a5[o5 - 4]), n5.extend(this.$, a5[o5 - 3]), n5.extend(this.$, a5[o5 - 2]), n5.extend(this.$, a5[o5 - 1]), n5.extend(this.$, a5[o5]), this.$ = a5[o5 - 9];
              break;
            case 73:
              this.$ = new n5.Search({ selectors: a5[o5 - 2], from: a5[o5] }), n5.extend(this.$, a5[o5 - 1]);
              break;
            case 74:
              this.$ = { pivot: { expr: a5[o5 - 5], columnid: a5[o5 - 3], inlist: a5[o5 - 2], as: a5[o5] } };
              break;
            case 75:
              this.$ = { unpivot: { tocolumnid: a5[o5 - 8], forcolumnid: a5[o5 - 6], inlist: a5[o5 - 3], as: a5[o5] } };
              break;
            case 76:
            case 525:
            case 554:
            case 590:
            case 624:
            case 641:
            case 642:
            case 645:
            case 667:
              this.$ = a5[o5 - 1];
              break;
            case 77:
            case 78:
            case 86:
            case 147:
            case 185:
            case 247:
            case 283:
            case 291:
            case 292:
            case 293:
            case 294:
            case 295:
            case 296:
            case 297:
            case 298:
            case 299:
            case 300:
            case 301:
            case 302:
            case 303:
            case 304:
            case 307:
            case 308:
            case 323:
            case 324:
            case 325:
            case 326:
            case 327:
            case 328:
            case 379:
            case 445:
            case 446:
            case 447:
            case 448:
            case 449:
            case 450:
            case 521:
            case 547:
            case 551:
            case 553:
            case 628:
            case 629:
            case 630:
            case 631:
            case 632:
            case 633:
            case 637:
            case 639:
            case 640:
            case 649:
            case 665:
            case 666:
            case 728:
            case 743:
            case 744:
            case 746:
            case 747:
            case 753:
            case 754:
              this.$ = a5[o5];
              break;
            case 79:
            case 84:
            case 736:
            case 760:
              this.$ = a5[o5 - 2], this.$.push(a5[o5]);
              break;
            case 81:
              this.$ = { expr: a5[o5] };
              break;
            case 82:
              this.$ = { expr: a5[o5 - 2], as: a5[o5] };
              break;
            case 83:
              this.$ = { removecolumns: a5[o5] };
              break;
            case 87:
              this.$ = { like: a5[o5] };
              break;
            case 90:
            case 104:
              this.$ = { srchid: "PROP", args: [a5[o5]] };
              break;
            case 91:
              this.$ = { srchid: "ORDERBY", args: a5[o5 - 1] };
              break;
            case 92:
              var u5 = (u5 = a5[o5 - 1]) || "ASC";
              this.$ = { srchid: "ORDERBY", args: [{ expression: new n5.Column({ columnid: "_" }), direction: u5 }] };
              break;
            case 93:
              this.$ = { srchid: "PARENT" };
              break;
            case 94:
              this.$ = { srchid: "APROP", args: [a5[o5]] };
              break;
            case 95:
              this.$ = { selid: "ROOT" };
              break;
            case 96:
              this.$ = { srchid: "EQ", args: [a5[o5]] };
              break;
            case 97:
              this.$ = { srchid: "LIKE", args: [a5[o5]] };
              break;
            case 98:
            case 99:
              this.$ = { selid: "WITH", args: a5[o5 - 1] };
              break;
            case 100:
              this.$ = { srchid: a5[o5 - 3].toUpperCase(), args: a5[o5 - 1] };
              break;
            case 101:
              this.$ = { srchid: "WHERE", args: [a5[o5 - 1]] };
              break;
            case 102:
              this.$ = { selid: "OF", args: [a5[o5 - 1]] };
              break;
            case 103:
              this.$ = { srchid: "CLASS", args: [a5[o5 - 1]] };
              break;
            case 105:
              this.$ = { srchid: "NAME", args: [a5[o5].substr(1, a5[o5].length - 2)] };
              break;
            case 106:
              this.$ = { srchid: "CHILD" };
              break;
            case 107:
              this.$ = { srchid: "VERTEX" };
              break;
            case 108:
              this.$ = { srchid: "EDGE" };
              break;
            case 109:
              this.$ = { srchid: "REF" };
              break;
            case 110:
              this.$ = { srchid: "SHARP", args: [a5[o5]] };
              break;
            case 111:
              this.$ = { srchid: "ATTR", args: void 0 === a5[o5] ? void 0 : [a5[o5]] };
              break;
            case 112:
              this.$ = { srchid: "ATTR" };
              break;
            case 113:
              this.$ = { srchid: "OUT" };
              break;
            case 114:
              this.$ = { srchid: "IN" };
              break;
            case 115:
              this.$ = { srchid: "OUTOUT" };
              break;
            case 116:
              this.$ = { srchid: "ININ" };
              break;
            case 117:
              this.$ = { srchid: "CONTENT" };
              break;
            case 118:
              this.$ = { srchid: "EX", args: [new n5.Json({ value: a5[o5] })] };
              break;
            case 119:
              this.$ = { srchid: "AT", args: [a5[o5]] };
              break;
            case 120:
              this.$ = { srchid: "AS", args: [a5[o5]] };
              break;
            case 121:
              this.$ = { srchid: "SET", args: a5[o5 - 1] };
              break;
            case 122:
              this.$ = { selid: "TO", args: [a5[o5]] };
              break;
            case 123:
              this.$ = { srchid: "VALUE" };
              break;
            case 124:
              this.$ = { srchid: "ROW", args: a5[o5 - 1] };
              break;
            case 125:
              this.$ = { srchid: "CLASS", args: [a5[o5]] };
              break;
            case 126:
              this.$ = { selid: a5[o5], args: [a5[o5 - 1]] };
              break;
            case 127:
              this.$ = { selid: "NOT", args: a5[o5 - 1] };
              break;
            case 128:
              this.$ = { selid: "IF", args: a5[o5 - 1] };
              break;
            case 129:
              this.$ = { selid: a5[o5 - 3], args: a5[o5 - 1] };
              break;
            case 130:
              this.$ = { selid: "DISTINCT", args: a5[o5 - 1] };
              break;
            case 131:
              this.$ = { selid: "UNION", args: a5[o5 - 1] };
              break;
            case 132:
              this.$ = { selid: "UNIONALL", args: a5[o5 - 1] };
              break;
            case 133:
              this.$ = { selid: "ALL", args: [a5[o5 - 1]] };
              break;
            case 134:
              this.$ = { selid: "ANY", args: [a5[o5 - 1]] };
              break;
            case 135:
              this.$ = { selid: "INTERSECT", args: a5[o5 - 1] };
              break;
            case 136:
              this.$ = { selid: "EXCEPT", args: a5[o5 - 1] };
              break;
            case 137:
              this.$ = { selid: "AND", args: a5[o5 - 1] };
              break;
            case 138:
              this.$ = { selid: "OR", args: a5[o5 - 1] };
              break;
            case 139:
              this.$ = { selid: "PATH", args: [a5[o5 - 1]] };
              break;
            case 140:
              this.$ = { srchid: "RETURN", args: a5[o5 - 1] };
              break;
            case 141:
              this.$ = { selid: "REPEAT", sels: a5[o5 - 3], args: a5[o5 - 1] };
              break;
            case 142:
              this.$ = a5[o5 - 2], this.$.push(a5[o5]);
              break;
            case 144:
              this.$ = "PLUS";
              break;
            case 145:
              this.$ = "STAR";
              break;
            case 146:
              this.$ = "QUESTION";
              break;
            case 148:
            case 149:
              this.$ = new n5.Select({ columns: a5[o5], distinct: true }), n5.extend(this.$, a5[o5 - 3]), n5.extend(this.$, a5[o5 - 1]);
              break;
            case 150:
              this.$ = new n5.Select({ columns: a5[o5], all: true }), n5.extend(this.$, a5[o5 - 3]), n5.extend(this.$, a5[o5 - 1]);
              break;
            case 151:
              a5[o5] ? (this.$ = new n5.Select({ columns: a5[o5] }), n5.extend(this.$, a5[o5 - 2]), n5.extend(this.$, a5[o5 - 1])) : this.$ = new n5.Select({ columns: [new n5.Column({ columnid: "_" })], modifier: "COLUMN" });
              break;
            case 152:
              "SELECT" == a5[o5] ? this.$ = void 0 : this.$ = { modifier: a5[o5] };
              break;
            case 153:
              this.$ = { modifier: "VALUE" };
              break;
            case 154:
              this.$ = { modifier: "ROW" };
              break;
            case 155:
              this.$ = { modifier: "COLUMN" };
              break;
            case 156:
              this.$ = { modifier: "MATRIX" };
              break;
            case 157:
              this.$ = { modifier: "TEXTSTRING" };
              break;
            case 158:
              this.$ = { modifier: "INDEX" };
              break;
            case 159:
              this.$ = { modifier: "RECORDSET" };
              break;
            case 160:
              this.$ = { top: a5[o5 - 1], percent: void 0 !== a5[o5] || void 0 };
              break;
            case 161:
              this.$ = { top: a5[o5 - 1] };
              break;
            case 163:
            case 333:
            case 528:
            case 529:
            case 729:
              this.$ = void 0;
              break;
            case 164:
            case 165:
            case 166:
            case 167:
              this.$ = { into: a5[o5] };
              break;
            case 168:
              var l5 = (h5 = (h5 = a5[o5]).substr(1, h5.length - 2)).substr(-3).toUpperCase(), c5 = h5.substr(-4).toUpperCase();
              "#" == h5[0] ? this.$ = { into: new n5.FuncValue({ funcid: "HTML", args: [new n5.StringValue({ value: h5 }), new n5.Json({ value: { headers: true } })] }) } : "XLS" == l5 || "CSV" == l5 || "TAB" == l5 ? this.$ = { into: new n5.FuncValue({ funcid: l5, args: [new n5.StringValue({ value: h5 }), new n5.Json({ value: { headers: true } })] }) } : "XLSX" != c5 && "JSON" != c5 || (this.$ = { into: new n5.FuncValue({ funcid: c5, args: [new n5.StringValue({ value: h5 }), new n5.Json({ value: { headers: true } })] }) });
              break;
            case 169:
              this.$ = { from: a5[o5] };
              break;
            case 170:
              this.$ = { from: a5[o5 - 1], joins: a5[o5] };
              break;
            case 171:
              this.$ = { from: a5[o5 - 2], joins: a5[o5 - 1] };
              break;
            case 173:
              this.$ = new n5.Apply({ select: a5[o5 - 2], applymode: "CROSS", as: a5[o5] });
              break;
            case 174:
              this.$ = new n5.Apply({ select: a5[o5 - 3], applymode: "CROSS", as: a5[o5] });
              break;
            case 175:
              this.$ = new n5.Apply({ select: a5[o5 - 2], applymode: "OUTER", as: a5[o5] });
              break;
            case 176:
              this.$ = new n5.Apply({ select: a5[o5 - 3], applymode: "OUTER", as: a5[o5] });
              break;
            case 178:
            case 243:
            case 457:
            case 535:
            case 536:
              this.$ = a5[o5 - 2], a5[o5 - 2].push(a5[o5]);
              break;
            case 179:
              this.$ = a5[o5 - 2], this.$.as = a5[o5];
              break;
            case 180:
              this.$ = a5[o5 - 3], this.$.as = a5[o5];
              break;
            case 181:
              this.$ = a5[o5 - 1], this.$.as = "default";
              break;
            case 182:
              this.$ = new n5.Json({ value: a5[o5 - 2] }), a5[o5 - 2].as = a5[o5];
              break;
            case 183:
              this.$ = a5[o5 - 1], a5[o5 - 1].as = a5[o5];
              break;
            case 184:
              this.$ = a5[o5 - 2], a5[o5 - 2].as = a5[o5];
              break;
            case 186:
            case 643:
            case 646:
              this.$ = a5[o5 - 2];
              break;
            case 187:
            case 191:
            case 195:
            case 198:
              this.$ = a5[o5 - 1], a5[o5 - 1].as = a5[o5];
              break;
            case 188:
            case 192:
            case 196:
            case 199:
              this.$ = a5[o5 - 2], a5[o5 - 2].as = a5[o5];
              break;
            case 189:
            case 190:
            case 194:
            case 197:
              this.$ = a5[o5], a5[o5].as = "default";
              break;
            case 193:
              this.$ = { inserted: true };
              break;
            case 200:
              l5 = (h5 = (h5 = a5[o5]).substr(1, h5.length - 2)).substr(-3).toUpperCase(), c5 = h5.substr(-4).toUpperCase();
              if ("#" == h5[0])
                d5 = new n5.FuncValue({ funcid: "HTML", args: [new n5.StringValue({ value: h5 }), new n5.Json({ value: { headers: true } })] });
              else if ("XLS" == l5 || "CSV" == l5 || "TAB" == l5)
                d5 = new n5.FuncValue({ funcid: l5, args: [new n5.StringValue({ value: h5 }), new n5.Json({ value: { headers: true } })] });
              else {
                if ("XLSX" != c5 && "JSON" != c5)
                  throw new Error("Unknown string in FROM clause");
                d5 = new n5.FuncValue({ funcid: c5, args: [new n5.StringValue({ value: h5 }), new n5.Json({ value: { headers: true } })] });
              }
              this.$ = d5;
              break;
            case 201:
              "INFORMATION_SCHEMA" == a5[o5 - 2] ? this.$ = new n5.FuncValue({ funcid: a5[o5 - 2], args: [new n5.StringValue({ value: a5[o5] })] }) : this.$ = new n5.Table({ databaseid: a5[o5 - 2], tableid: a5[o5] });
              break;
            case 202:
              this.$ = new n5.Table({ tableid: a5[o5] });
              break;
            case 203:
            case 204:
              this.$ = a5[o5 - 1], a5[o5 - 1].push(a5[o5]);
              break;
            case 207:
              this.$ = new n5.Join(a5[o5 - 2]), n5.extend(this.$, a5[o5 - 1]), n5.extend(this.$, a5[o5]);
              break;
            case 208:
              this.$ = { table: a5[o5] };
              break;
            case 209:
              this.$ = { table: a5[o5 - 1], as: a5[o5] };
              break;
            case 210:
              this.$ = { table: a5[o5 - 2], as: a5[o5] };
              break;
            case 211:
              this.$ = { json: new n5.Json({ value: a5[o5 - 2], as: a5[o5] }) };
              break;
            case 212:
              this.$ = { param: a5[o5 - 1], as: a5[o5] };
              break;
            case 213:
              this.$ = { param: a5[o5 - 2], as: a5[o5] };
              break;
            case 214:
              this.$ = { select: a5[o5 - 2], as: a5[o5] };
              break;
            case 215:
              this.$ = { select: a5[o5 - 3], as: a5[o5] };
              break;
            case 216:
              this.$ = { func: a5[o5], as: "default" };
              break;
            case 217:
              this.$ = { func: a5[o5 - 1], as: a5[o5] };
              break;
            case 218:
              this.$ = { func: a5[o5 - 2], as: a5[o5] };
              break;
            case 219:
              this.$ = { variable: a5[o5], as: "default" };
              break;
            case 220:
              this.$ = { variable: a5[o5 - 1], as: a5[o5] };
              break;
            case 221:
              this.$ = { variable: a5[o5 - 2], as: a5[o5] };
              break;
            case 222:
              this.$ = { joinmode: a5[o5] };
              break;
            case 223:
              this.$ = { joinmode: a5[o5 - 1], natural: true };
              break;
            case 224:
            case 225:
              this.$ = "INNER";
              break;
            case 226:
            case 227:
              this.$ = "LEFT";
              break;
            case 228:
            case 229:
              this.$ = "RIGHT";
              break;
            case 230:
            case 231:
              this.$ = "OUTER";
              break;
            case 232:
              this.$ = "SEMI";
              break;
            case 233:
              this.$ = "ANTI";
              break;
            case 234:
              this.$ = "CROSS";
              break;
            case 235:
              this.$ = { on: a5[o5] };
              break;
            case 236:
            case 702:
              this.$ = { using: a5[o5] };
              break;
            case 239:
              this.$ = { where: new n5.Expression({ expression: a5[o5] }) };
              break;
            case 241:
              this.$ = { group: a5[o5 - 1] }, n5.extend(this.$, a5[o5]);
              break;
            case 244:
              this.$ = new n5.GroupExpression({ type: "GROUPING SETS", group: a5[o5 - 1] });
              break;
            case 245:
              this.$ = new n5.GroupExpression({ type: "ROLLUP", group: a5[o5 - 1] });
              break;
            case 246:
              this.$ = new n5.GroupExpression({ type: "CUBE", group: a5[o5 - 1] });
              break;
            case 249:
              this.$ = { having: a5[o5] };
              break;
            case 251:
              this.$ = { union: a5[o5] };
              break;
            case 252:
              this.$ = { unionall: a5[o5] };
              break;
            case 253:
              this.$ = { except: a5[o5] };
              break;
            case 254:
              this.$ = { intersect: a5[o5] };
              break;
            case 255:
              this.$ = { union: a5[o5], corresponding: true };
              break;
            case 256:
              this.$ = { unionall: a5[o5], corresponding: true };
              break;
            case 257:
              this.$ = { except: a5[o5], corresponding: true };
              break;
            case 258:
              this.$ = { intersect: a5[o5], corresponding: true };
              break;
            case 260:
              this.$ = { order: a5[o5] };
              break;
            case 262:
              this.$ = a5[o5 - 2], a5[o5 - 2].push(a5[o5]);
              break;
            case 263:
              this.$ = { nullsOrder: "FIRST" };
              break;
            case 264:
              this.$ = { nullsOrder: "LAST" };
              break;
            case 265:
              this.$ = new n5.Expression({ expression: a5[o5], direction: "ASC" });
              break;
            case 266:
              this.$ = new n5.Expression({ expression: a5[o5 - 1], direction: a5[o5].toUpperCase() });
              break;
            case 267:
              this.$ = new n5.Expression({ expression: a5[o5 - 2], direction: a5[o5 - 1].toUpperCase() }), n5.extend(this.$, a5[o5]);
              break;
            case 268:
              this.$ = new n5.Expression({ expression: a5[o5 - 2], direction: "ASC", nocase: true });
              break;
            case 269:
              this.$ = new n5.Expression({ expression: a5[o5 - 3], direction: a5[o5].toUpperCase(), nocase: true });
              break;
            case 271:
              this.$ = { limit: a5[o5 - 1] }, n5.extend(this.$, a5[o5]);
              break;
            case 272:
              this.$ = { limit: a5[o5 - 2], offset: a5[o5 - 6] };
              break;
            case 274:
              this.$ = { offset: a5[o5] };
              break;
            case 275:
            case 514:
            case 538:
            case 653:
            case 663:
            case 687:
            case 689:
            case 693:
              a5[o5 - 2].push(a5[o5]), this.$ = a5[o5 - 2];
              break;
            case 277:
            case 279:
            case 281:
              a5[o5 - 2].as = a5[o5], this.$ = a5[o5 - 2];
              break;
            case 278:
            case 280:
            case 282:
              a5[o5 - 1].as = a5[o5], this.$ = a5[o5 - 1];
              break;
            case 284:
              this.$ = new n5.Column({ columid: a5[o5], tableid: a5[o5 - 2], databaseid: a5[o5 - 4] });
              break;
            case 285:
              this.$ = new n5.Column({ columnid: a5[o5], tableid: a5[o5 - 2] });
              break;
            case 286:
              this.$ = new n5.Column({ columnid: a5[o5] });
              break;
            case 287:
              this.$ = new n5.Column({ columnid: a5[o5], tableid: a5[o5 - 2], databaseid: a5[o5 - 4] });
              break;
            case 288:
            case 289:
              this.$ = new n5.Column({ columnid: a5[o5], tableid: a5[o5 - 2] });
              break;
            case 290:
              this.$ = new n5.Column({ columnid: a5[o5] });
              break;
            case 305:
              this.$ = new n5.DomainValueValue();
              break;
            case 306:
              this.$ = new n5.Json({ value: a5[o5] });
              break;
            case 309:
            case 310:
            case 311:
              n5.queries || (n5.queries = []), n5.queries.push(a5[o5 - 1]), a5[o5 - 1].queriesidx = n5.queries.length, this.$ = a5[o5 - 1];
              break;
            case 312:
              this.$ = a5[o5];
              break;
            case 313:
              this.$ = new n5.FuncValue({ funcid: "CURRENT_TIMESTAMP" });
              break;
            case 314:
              this.$ = new n5.JavaScript({ value: a5[o5].substr(2, a5[o5].length - 4) });
              break;
            case 315:
              this.$ = new n5.JavaScript({ value: 'alasql.fn["' + a5[o5 - 2] + '"] = ' + a5[o5].substr(2, a5[o5].length - 4) });
              break;
            case 316:
              this.$ = new n5.JavaScript({ value: 'alasql.aggr["' + a5[o5 - 2] + '"] = ' + a5[o5].substr(2, a5[o5].length - 4) });
              break;
            case 317:
              this.$ = new n5.FuncValue({ funcid: a5[o5], newid: true });
              break;
            case 318:
              this.$ = a5[o5], n5.extend(this.$, { newid: true });
              break;
            case 319:
              this.$ = new n5.Convert({ expression: a5[o5 - 3] }), n5.extend(this.$, a5[o5 - 1]);
              break;
            case 320:
              this.$ = new n5.Convert({ expression: a5[o5 - 5], style: a5[o5 - 1] }), n5.extend(this.$, a5[o5 - 3]);
              break;
            case 321:
              this.$ = new n5.Convert({ expression: a5[o5 - 1] }), n5.extend(this.$, a5[o5 - 3]);
              break;
            case 322:
              this.$ = new n5.Convert({ expression: a5[o5 - 3], style: a5[o5 - 1] }), n5.extend(this.$, a5[o5 - 5]);
              break;
            case 329:
              this.$ = new n5.FuncValue({ funcid: "CURRENT_TIMESTAMP" });
              break;
            case 330:
              1 < a5[o5 - 2].length && ("MAX" == a5[o5 - 4].toUpperCase() || "MIN" == a5[o5 - 4].toUpperCase()) ? this.$ = new n5.FuncValue({ funcid: a5[o5 - 4], args: a5[o5 - 2] }) : this.$ = new n5.AggrValue({ aggregatorid: a5[o5 - 4].toUpperCase(), expression: a5[o5 - 2].pop(), over: a5[o5] });
              break;
            case 331:
              this.$ = new n5.AggrValue({ aggregatorid: a5[o5 - 5].toUpperCase(), expression: a5[o5 - 2], distinct: true, over: a5[o5] });
              break;
            case 332:
              this.$ = new n5.AggrValue({ aggregatorid: a5[o5 - 5].toUpperCase(), expression: a5[o5 - 2], over: a5[o5] });
              break;
            case 334:
            case 335:
              this.$ = new n5.Over(), n5.extend(this.$, a5[o5 - 1]);
              break;
            case 336:
              this.$ = new n5.Over(), n5.extend(this.$, a5[o5 - 2]), n5.extend(this.$, a5[o5 - 1]);
              break;
            case 337:
              this.$ = { partition: a5[o5] };
              break;
            case 338:
              this.$ = { order: a5[o5] };
              break;
            case 339:
              this.$ = "SUM";
              break;
            case 340:
              this.$ = "TOTAL";
              break;
            case 341:
              this.$ = "COUNT";
              break;
            case 342:
              this.$ = "MIN";
              break;
            case 343:
            case 549:
              this.$ = "MAX";
              break;
            case 344:
              this.$ = "AVG";
              break;
            case 345:
              this.$ = "FIRST";
              break;
            case 346:
              this.$ = "LAST";
              break;
            case 347:
              this.$ = "AGGR";
              break;
            case 348:
              this.$ = "ARRAY";
              break;
            case 349:
              u5 = a5[o5 - 4], l5 = a5[o5 - 1];
              (!(1 < l5.length) || "MIN" != u5.toUpperCase() && "MAX" != u5.toUpperCase()) && L.aggr[a5[o5 - 4]] ? this.$ = new n5.AggrValue({ aggregatorid: "REDUCE", funcid: u5, expression: l5.pop(), distinct: "DISTINCT" == a5[o5 - 2] }) : this.$ = new n5.FuncValue({ funcid: u5, args: l5 });
              break;
            case 350:
              this.$ = new n5.FuncValue({ funcid: a5[o5 - 2] });
              break;
            case 351:
              this.$ = new n5.FuncValue({ funcid: "IIF", args: a5[o5 - 1] });
              break;
            case 352:
              this.$ = new n5.FuncValue({ funcid: "REPLACE", args: a5[o5 - 1] });
              break;
            case 353:
              this.$ = new n5.FuncValue({ funcid: "DATEADD", args: [new n5.StringValue({ value: a5[o5 - 5] }), a5[o5 - 3], a5[o5 - 1]] });
              break;
            case 354:
              this.$ = new n5.FuncValue({ funcid: "DATEADD", args: [a5[o5 - 5], a5[o5 - 3], a5[o5 - 1]] });
              break;
            case 355:
              this.$ = new n5.FuncValue({ funcid: "DATEDIFF", args: [new n5.StringValue({ value: a5[o5 - 5] }), a5[o5 - 3], a5[o5 - 1]] });
              break;
            case 356:
              this.$ = new n5.FuncValue({ funcid: "DATEDIFF", args: [a5[o5 - 5], a5[o5 - 3], a5[o5 - 1]] });
              break;
            case 357:
              this.$ = new n5.FuncValue({ funcid: "TIMESTAMPDIFF", args: [new n5.StringValue({ value: a5[o5 - 5] }), a5[o5 - 3], a5[o5 - 1]] });
              break;
            case 358:
              this.$ = new n5.FuncValue({ funcid: "INTERVAL", args: [a5[o5 - 1], new n5.StringValue({ value: a5[o5].toLowerCase() })] });
              break;
            case 360:
              a5[o5 - 2].push(a5[o5]), this.$ = a5[o5 - 2];
              break;
            case 361:
              this.$ = new n5.NumValue({ value: +a5[o5] });
              break;
            case 362:
              this.$ = new n5.LogicValue({ value: true });
              break;
            case 363:
              this.$ = new n5.LogicValue({ value: false });
              break;
            case 364:
              this.$ = new n5.StringValue({ value: a5[o5].substr(1, a5[o5].length - 2).replace(/(\\\')/g, "'").replace(/(\'\')/g, "'") });
              break;
            case 365:
              this.$ = new n5.StringValue({ value: a5[o5].substr(2, a5[o5].length - 3).replace(/(\\\')/g, "'").replace(/(\'\')/g, "'") });
              break;
            case 366:
              this.$ = new n5.NullValue({ value: void 0 });
              break;
            case 367:
              this.$ = new n5.VarValue({ variable: a5[o5] });
              break;
            case 368:
              n5.exists || (n5.exists = []), this.$ = new n5.ExistsValue({ value: a5[o5 - 1], existsidx: n5.exists.length }), n5.exists.push(a5[o5 - 1]);
              break;
            case 369:
              this.$ = new n5.ArrayValue({ value: a5[o5 - 1] });
              break;
            case 370:
            case 371:
              this.$ = new n5.ParamValue({ param: a5[o5] });
              break;
            case 372:
              void 0 === n5.question && (n5.question = 0), this.$ = new n5.ParamValue({ param: n5.question++ });
              break;
            case 373:
              void 0 === n5.question && (n5.question = 0), this.$ = new n5.ParamValue({ param: n5.question++, array: true });
              break;
            case 374:
              this.$ = new n5.CaseValue({ expression: a5[o5 - 3], whens: a5[o5 - 2], elses: a5[o5 - 1] });
              break;
            case 375:
              this.$ = new n5.CaseValue({ whens: a5[o5 - 2], elses: a5[o5 - 1] });
              break;
            case 376:
            case 704:
            case 705:
              this.$ = a5[o5 - 1], this.$.push(a5[o5]);
              break;
            case 378:
              this.$ = { when: a5[o5 - 2], then: a5[o5] };
              break;
            case 381:
            case 382:
              this.$ = new n5.Op({ left: a5[o5 - 2], op: "REGEXP", right: a5[o5] });
              break;
            case 383:
              this.$ = new n5.Op({ left: a5[o5 - 2], op: "GLOB", right: a5[o5] });
              break;
            case 384:
              this.$ = new n5.Op({ left: a5[o5 - 2], op: "LIKE", right: a5[o5] });
              break;
            case 385:
              this.$ = new n5.Op({ left: a5[o5 - 4], op: "LIKE", right: a5[o5 - 2], escape: a5[o5] });
              break;
            case 386:
              this.$ = new n5.Op({ left: a5[o5 - 2], op: "NOT LIKE", right: a5[o5] });
              break;
            case 387:
              this.$ = new n5.Op({ left: a5[o5 - 4], op: "NOT LIKE", right: a5[o5 - 2], escape: a5[o5] });
              break;
            case 388:
              this.$ = new n5.Op({ left: a5[o5 - 2], op: "||", right: a5[o5] });
              break;
            case 389:
              this.$ = new n5.Op({ left: a5[o5 - 2], op: "+", right: a5[o5] });
              break;
            case 390:
              this.$ = new n5.Op({ left: a5[o5 - 2], op: "-", right: a5[o5] });
              break;
            case 391:
              this.$ = new n5.Op({ left: a5[o5 - 2], op: "*", right: a5[o5] });
              break;
            case 392:
              this.$ = new n5.Op({ left: a5[o5 - 2], op: "/", right: a5[o5] });
              break;
            case 393:
              this.$ = new n5.Op({ left: a5[o5 - 2], op: "%", right: a5[o5] });
              break;
            case 394:
              this.$ = new n5.Op({ left: a5[o5 - 2], op: "^", right: a5[o5] });
              break;
            case 395:
              this.$ = new n5.Op({ left: a5[o5 - 2], op: ">>", right: a5[o5] });
              break;
            case 396:
              this.$ = new n5.Op({ left: a5[o5 - 2], op: "<<", right: a5[o5] });
              break;
            case 397:
              this.$ = new n5.Op({ left: a5[o5 - 2], op: "&", right: a5[o5] });
              break;
            case 398:
              this.$ = new n5.Op({ left: a5[o5 - 2], op: "|", right: a5[o5] });
              break;
            case 399:
            case 400:
            case 402:
              this.$ = new n5.Op({ left: a5[o5 - 2], op: "->", right: a5[o5] });
              break;
            case 401:
              this.$ = new n5.Op({ left: a5[o5 - 4], op: "->", right: a5[o5 - 1] });
              break;
            case 403:
            case 404:
            case 406:
              this.$ = new n5.Op({ left: a5[o5 - 2], op: "!", right: a5[o5] });
              break;
            case 405:
              this.$ = new n5.Op({ left: a5[o5 - 4], op: "!", right: a5[o5 - 1] });
              break;
            case 407:
              this.$ = new n5.Op({ left: a5[o5 - 2], op: ">", right: a5[o5] });
              break;
            case 408:
              this.$ = new n5.Op({ left: a5[o5 - 2], op: ">=", right: a5[o5] });
              break;
            case 409:
              this.$ = new n5.Op({ left: a5[o5 - 2], op: "<", right: a5[o5] });
              break;
            case 410:
              this.$ = new n5.Op({ left: a5[o5 - 2], op: "<=", right: a5[o5] });
              break;
            case 411:
              this.$ = new n5.Op({ left: a5[o5 - 2], op: "=", right: a5[o5] });
              break;
            case 412:
              this.$ = new n5.Op({ left: a5[o5 - 2], op: "==", right: a5[o5] });
              break;
            case 413:
              this.$ = new n5.Op({ left: a5[o5 - 2], op: "===", right: a5[o5] });
              break;
            case 414:
              this.$ = new n5.Op({ left: a5[o5 - 2], op: "!=", right: a5[o5] });
              break;
            case 415:
              this.$ = new n5.Op({ left: a5[o5 - 2], op: "!==", right: a5[o5] });
              break;
            case 416:
              this.$ = new n5.Op({ left: a5[o5 - 2], op: "!===", right: a5[o5] });
              break;
            case 417:
              n5.queries || (n5.queries = []), this.$ = new n5.Op({ left: a5[o5 - 5], op: a5[o5 - 4], allsome: a5[o5 - 3], right: a5[o5 - 1], queriesidx: n5.queries.length }), n5.queries.push(a5[o5 - 1]);
              break;
            case 418:
              this.$ = new n5.Op({ left: a5[o5 - 5], op: a5[o5 - 4], allsome: a5[o5 - 3], right: a5[o5 - 1] });
              break;
            case 419:
              "BETWEEN1" == a5[o5 - 2].op ? "AND" == a5[o5 - 2].left.op ? this.$ = new n5.Op({ left: a5[o5 - 2].left.left, op: "AND", right: new n5.Op({ left: a5[o5 - 2].left.right, op: "BETWEEN", right1: a5[o5 - 2].right, right2: a5[o5] }) }) : this.$ = new n5.Op({ left: a5[o5 - 2].left, op: "BETWEEN", right1: a5[o5 - 2].right, right2: a5[o5] }) : "NOT BETWEEN1" == a5[o5 - 2].op ? "AND" == a5[o5 - 2].left.op ? this.$ = new n5.Op({ left: a5[o5 - 2].left.left, op: "AND", right: new n5.Op({ left: a5[o5 - 2].left.right, op: "NOT BETWEEN", right1: a5[o5 - 2].right, right2: a5[o5] }) }) : this.$ = new n5.Op({ left: a5[o5 - 2].left, op: "NOT BETWEEN", right1: a5[o5 - 2].right, right2: a5[o5] }) : this.$ = new n5.Op({ left: a5[o5 - 2], op: "AND", right: a5[o5] });
              break;
            case 420:
              this.$ = new n5.Op({ left: a5[o5 - 2], op: "OR", right: a5[o5] });
              break;
            case 421:
              this.$ = new n5.UniOp({ op: "NOT", right: a5[o5] });
              break;
            case 422:
              this.$ = new n5.UniOp({ op: "-", right: a5[o5] });
              break;
            case 423:
              this.$ = new n5.UniOp({ op: "+", right: a5[o5] });
              break;
            case 424:
              this.$ = new n5.UniOp({ op: "~", right: a5[o5] });
              break;
            case 425:
              this.$ = new n5.UniOp({ op: "#", right: a5[o5] });
              break;
            case 426:
              this.$ = new n5.UniOp({ right: a5[o5 - 1] });
              break;
            case 427:
              n5.queries || (n5.queries = []), this.$ = new n5.Op({ left: a5[o5 - 4], op: "IN", right: a5[o5 - 1], queriesidx: n5.queries.length }), n5.queries.push(a5[o5 - 1]);
              break;
            case 428:
              n5.queries || (n5.queries = []), this.$ = new n5.Op({ left: a5[o5 - 5], op: "NOT IN", right: a5[o5 - 1], queriesidx: n5.queries.length }), n5.queries.push(a5[o5 - 1]);
              break;
            case 429:
              this.$ = new n5.Op({ left: a5[o5 - 4], op: "IN", right: a5[o5 - 1] });
              break;
            case 430:
              this.$ = new n5.Op({ left: a5[o5 - 5], op: "NOT IN", right: a5[o5 - 1] });
              break;
            case 431:
              this.$ = new n5.Op({ left: a5[o5 - 3], op: "IN", right: [] });
              break;
            case 432:
              this.$ = new n5.Op({ left: a5[o5 - 4], op: "NOT IN", right: [] });
              break;
            case 433:
            case 435:
              this.$ = new n5.Op({ left: a5[o5 - 2], op: "IN", right: a5[o5] });
              break;
            case 434:
            case 436:
              this.$ = new n5.Op({ left: a5[o5 - 3], op: "NOT IN", right: a5[o5] });
              break;
            case 437:
              this.$ = new n5.Op({ left: a5[o5 - 2], op: "BETWEEN1", right: a5[o5] });
              break;
            case 438:
              this.$ = new n5.Op({ left: a5[o5 - 2], op: "NOT BETWEEN1", right: a5[o5] });
              break;
            case 439:
              this.$ = new n5.Op({ op: "IS", left: a5[o5 - 2], right: a5[o5] });
              break;
            case 440:
              this.$ = new n5.Op({ op: "IS", left: a5[o5 - 2], right: new n5.UniOp({ op: "NOT", right: new n5.NullValue({ value: void 0 }) }) });
              break;
            case 441:
              this.$ = new n5.Convert({ expression: a5[o5 - 2] }), n5.extend(this.$, a5[o5]);
              break;
            case 442:
            case 443:
              this.$ = a5[o5];
              break;
            case 444:
              this.$ = a5[o5 - 1];
              break;
            case 451:
              this.$ = "ALL";
              break;
            case 452:
              this.$ = "SOME";
              break;
            case 453:
              this.$ = "ANY";
              break;
            case 454:
              this.$ = new n5.Update({ table: a5[o5 - 4], columns: a5[o5 - 2], where: a5[o5] });
              break;
            case 455:
              this.$ = new n5.Update({ table: a5[o5 - 2], columns: a5[o5] });
              break;
            case 458:
              this.$ = new n5.SetColumn({ column: a5[o5 - 2], expression: a5[o5] });
              break;
            case 459:
              this.$ = new n5.SetColumn({ variable: a5[o5 - 2], expression: a5[o5], method: a5[o5 - 3] });
              break;
            case 460:
              this.$ = new n5.Delete({ table: a5[o5 - 2], where: a5[o5] });
              break;
            case 461:
              this.$ = new n5.Delete({ table: a5[o5] });
              break;
            case 462:
              this.$ = new n5.Insert({ into: a5[o5 - 2], values: a5[o5] });
              break;
            case 463:
              this.$ = new n5.Insert({ into: a5[o5 - 1], values: a5[o5] });
              break;
            case 464:
            case 466:
              this.$ = new n5.Insert({ into: a5[o5 - 2], values: a5[o5], orreplace: true });
              break;
            case 465:
            case 467:
              this.$ = new n5.Insert({ into: a5[o5 - 1], values: a5[o5], orreplace: true });
              break;
            case 468:
              this.$ = new n5.Insert({ into: a5[o5 - 2], default: true });
              break;
            case 469:
              this.$ = new n5.Insert({ into: a5[o5 - 5], columns: a5[o5 - 3], values: a5[o5] });
              break;
            case 470:
              this.$ = new n5.Insert({ into: a5[o5 - 4], columns: a5[o5 - 2], values: a5[o5] });
              break;
            case 471:
              this.$ = new n5.Insert({ into: a5[o5 - 1], select: a5[o5] });
              break;
            case 472:
              this.$ = new n5.Insert({ into: a5[o5 - 1], select: a5[o5], orreplace: true });
              break;
            case 473:
              this.$ = new n5.Insert({ into: a5[o5 - 4], columns: a5[o5 - 2], select: a5[o5] });
              break;
            case 478:
              this.$ = [a5[o5 - 1]];
              break;
            case 481:
              this.$ = a5[o5 - 4], a5[o5 - 4].push(a5[o5 - 1]);
              break;
            case 482:
            case 483:
            case 485:
            case 493:
              this.$ = a5[o5 - 2], a5[o5 - 2].push(a5[o5]);
              break;
            case 494:
              this.$ = new n5.CreateTable({ table: a5[o5 - 4] }), n5.extend(this.$, a5[o5 - 7]), n5.extend(this.$, a5[o5 - 6]), n5.extend(this.$, a5[o5 - 5]), n5.extend(this.$, a5[o5 - 2]), n5.extend(this.$, a5[o5]);
              break;
            case 495:
              this.$ = new n5.CreateTable({ table: a5[o5] }), n5.extend(this.$, a5[o5 - 3]), n5.extend(this.$, a5[o5 - 2]), n5.extend(this.$, a5[o5 - 1]);
              break;
            case 497:
              this.$ = { class: true };
              break;
            case 507:
              this.$ = { temporary: true };
              break;
            case 509:
              this.$ = { ifnotexists: true };
              break;
            case 510:
              this.$ = { columns: a5[o5 - 2], constraints: a5[o5] };
              break;
            case 511:
              this.$ = { columns: a5[o5] };
              break;
            case 512:
              this.$ = { as: a5[o5] };
              break;
            case 513:
            case 537:
              this.$ = [a5[o5]];
              break;
            case 515:
            case 516:
            case 517:
            case 518:
            case 519:
              a5[o5].constraintid = a5[o5 - 1], this.$ = a5[o5];
              break;
            case 522:
              this.$ = { type: "CHECK", expression: a5[o5 - 1] };
              break;
            case 523:
              this.$ = { type: "PRIMARY KEY", columns: a5[o5 - 1], clustered: (a5[o5 - 3] + "").toUpperCase() };
              break;
            case 524:
              this.$ = { type: "FOREIGN KEY", columns: a5[o5 - 5], fktable: a5[o5 - 2], fkcolumns: a5[o5 - 1] };
              break;
            case 530:
              this.$ = { type: "UNIQUE", columns: a5[o5 - 1], clustered: (a5[o5 - 3] + "").toUpperCase() };
              break;
            case 539:
              this.$ = new n5.ColumnDef({ columnid: a5[o5 - 2] }), n5.extend(this.$, a5[o5 - 1]), n5.extend(this.$, a5[o5]);
              break;
            case 540:
              this.$ = new n5.ColumnDef({ columnid: a5[o5 - 1] }), n5.extend(this.$, a5[o5]);
              break;
            case 541:
              this.$ = new n5.ColumnDef({ columnid: a5[o5], dbtypeid: "" });
              break;
            case 542:
              this.$ = { dbtypeid: a5[o5 - 5], dbsize: a5[o5 - 3], dbprecision: +a5[o5 - 1] };
              break;
            case 543:
              this.$ = { dbtypeid: a5[o5 - 3], dbsize: a5[o5 - 1] };
              break;
            case 544:
              this.$ = { dbtypeid: a5[o5] };
              break;
            case 545:
              this.$ = { dbtypeid: "ENUM", enumvalues: a5[o5 - 1] };
              break;
            case 546:
              this.$ = a5[o5 - 1], a5[o5 - 1].dbtypeid += "[" + a5[o5] + "]";
              break;
            case 548:
            case 755:
              this.$ = +a5[o5];
              break;
            case 550:
              this.$ = void 0;
              break;
            case 552:
              n5.extend(a5[o5 - 1], a5[o5]), this.$ = a5[o5 - 1];
              break;
            case 555:
              this.$ = { primarykey: true };
              break;
            case 556:
            case 557:
              this.$ = { foreignkey: { table: a5[o5 - 1], columnid: a5[o5] } };
              break;
            case 558:
              this.$ = { identity: { value: a5[o5 - 3], step: a5[o5 - 1] } };
              break;
            case 559:
              this.$ = { identity: { value: 1, step: 1 } };
              break;
            case 560:
            case 562:
              this.$ = { default: a5[o5] };
              break;
            case 561:
              this.$ = { default: a5[o5 - 1] };
              break;
            case 563:
              this.$ = { null: true };
              break;
            case 564:
              this.$ = { notnull: true };
              break;
            case 565:
              this.$ = { check: a5[o5] };
              break;
            case 566:
              this.$ = { unique: true };
              break;
            case 567:
              this.$ = { onupdate: a5[o5] };
              break;
            case 568:
              this.$ = { onupdate: a5[o5 - 1] };
              break;
            case 569:
              this.$ = new n5.DropTable({ tables: a5[o5], type: a5[o5 - 2] }), n5.extend(this.$, a5[o5 - 1]);
              break;
            case 573:
              this.$ = { ifexists: true };
              break;
            case 574:
              this.$ = new n5.AlterTable({ table: a5[o5 - 3], renameto: a5[o5] });
              break;
            case 575:
              this.$ = new n5.AlterTable({ table: a5[o5 - 3], addcolumn: a5[o5] });
              break;
            case 576:
              this.$ = new n5.AlterTable({ table: a5[o5 - 3], modifycolumn: a5[o5] });
              break;
            case 577:
              this.$ = new n5.AlterTable({ table: a5[o5 - 5], renamecolumn: a5[o5 - 2], to: a5[o5] });
              break;
            case 578:
              this.$ = new n5.AlterTable({ table: a5[o5 - 3], dropcolumn: a5[o5] });
              break;
            case 579:
              this.$ = new n5.AlterTable({ table: a5[o5 - 2], renameto: a5[o5] });
              break;
            case 580:
              this.$ = new n5.AttachDatabase({ databaseid: a5[o5], engineid: a5[o5 - 2].toUpperCase() });
              break;
            case 581:
              this.$ = new n5.AttachDatabase({ databaseid: a5[o5 - 3], engineid: a5[o5 - 5].toUpperCase(), args: a5[o5 - 1] });
              break;
            case 582:
              this.$ = new n5.AttachDatabase({ databaseid: a5[o5 - 2], engineid: a5[o5 - 4].toUpperCase(), as: a5[o5] });
              break;
            case 583:
              this.$ = new n5.AttachDatabase({ databaseid: a5[o5 - 5], engineid: a5[o5 - 7].toUpperCase(), as: a5[o5], args: a5[o5 - 3] });
              break;
            case 584:
              this.$ = new n5.DetachDatabase({ databaseid: a5[o5] });
              break;
            case 585:
              this.$ = new n5.CreateDatabase({ databaseid: a5[o5] }), n5.extend(this.$, a5[o5]);
              break;
            case 586:
              this.$ = new n5.CreateDatabase({ engineid: a5[o5 - 4].toUpperCase(), databaseid: a5[o5 - 1], as: a5[o5] }), n5.extend(this.$, a5[o5 - 2]);
              break;
            case 587:
              this.$ = new n5.CreateDatabase({ engineid: a5[o5 - 7].toUpperCase(), databaseid: a5[o5 - 4], args: a5[o5 - 2], as: a5[o5] }), n5.extend(this.$, a5[o5 - 5]);
              break;
            case 588:
              this.$ = new n5.CreateDatabase({ engineid: a5[o5 - 4].toUpperCase(), as: a5[o5], args: [a5[o5 - 1]] }), n5.extend(this.$, a5[o5 - 2]);
              break;
            case 589:
              this.$ = void 0;
              break;
            case 591:
            case 592:
              this.$ = new n5.UseDatabase({ databaseid: a5[o5] });
              break;
            case 593:
              this.$ = new n5.DropDatabase({ databaseid: a5[o5] }), n5.extend(this.$, a5[o5 - 1]);
              break;
            case 594:
            case 595:
              this.$ = new n5.DropDatabase({ databaseid: a5[o5], engineid: a5[o5 - 3].toUpperCase() }), n5.extend(this.$, a5[o5 - 1]);
              break;
            case 596:
              this.$ = new n5.CreateIndex({ indexid: a5[o5 - 5], table: a5[o5 - 3], columns: a5[o5 - 1] });
              break;
            case 597:
              this.$ = new n5.CreateIndex({ indexid: a5[o5 - 5], table: a5[o5 - 3], columns: a5[o5 - 1], unique: true });
              break;
            case 598:
              this.$ = new n5.DropIndex({ indexid: a5[o5] });
              break;
            case 599:
              this.$ = new n5.ShowDatabases();
              break;
            case 600:
              this.$ = new n5.ShowDatabases({ like: a5[o5] });
              break;
            case 601:
              this.$ = new n5.ShowDatabases({ engineid: a5[o5 - 1].toUpperCase() });
              break;
            case 602:
              this.$ = new n5.ShowDatabases({ engineid: a5[o5 - 3].toUpperCase(), like: a5[o5] });
              break;
            case 603:
              this.$ = new n5.ShowTables();
              break;
            case 604:
              this.$ = new n5.ShowTables({ like: a5[o5] });
              break;
            case 605:
              this.$ = new n5.ShowTables({ databaseid: a5[o5] });
              break;
            case 606:
              this.$ = new n5.ShowTables({ like: a5[o5], databaseid: a5[o5 - 2] });
              break;
            case 607:
              this.$ = new n5.ShowColumns({ table: a5[o5] });
              break;
            case 608:
              this.$ = new n5.ShowColumns({ table: a5[o5 - 2], databaseid: a5[o5] });
              break;
            case 609:
              this.$ = new n5.ShowIndex({ table: a5[o5] });
              break;
            case 610:
              this.$ = new n5.ShowIndex({ table: a5[o5 - 2], databaseid: a5[o5] });
              break;
            case 611:
              this.$ = new n5.ShowCreateTable({ table: a5[o5] });
              break;
            case 612:
              this.$ = new n5.ShowCreateTable({ table: a5[o5 - 2], databaseid: a5[o5] });
              break;
            case 613:
              this.$ = new n5.CreateTable({ table: a5[o5 - 6], view: true, select: a5[o5 - 1], viewcolumns: a5[o5 - 4] }), n5.extend(this.$, a5[o5 - 9]), n5.extend(this.$, a5[o5 - 7]);
              break;
            case 614:
              this.$ = new n5.CreateTable({ table: a5[o5 - 3], view: true, select: a5[o5 - 1] }), n5.extend(this.$, a5[o5 - 6]), n5.extend(this.$, a5[o5 - 4]);
              break;
            case 618:
              this.$ = new n5.DropTable({ tables: a5[o5], view: true }), n5.extend(this.$, a5[o5 - 1]);
              break;
            case 619:
            case 765:
              this.$ = new n5.ExpressionStatement({ expression: a5[o5] });
              break;
            case 620:
              this.$ = new n5.Source({ url: a5[o5].value });
              break;
            case 621:
              this.$ = new n5.Assert({ value: a5[o5] });
              break;
            case 622:
              this.$ = new n5.Assert({ value: a5[o5].value });
              break;
            case 623:
              this.$ = new n5.Assert({ value: a5[o5], message: a5[o5 - 2] });
              break;
            case 625:
            case 636:
            case 638:
              this.$ = a5[o5].value;
              break;
            case 626:
            case 634:
              this.$ = +a5[o5].value;
              break;
            case 627:
              this.$ = !!a5[o5].value;
              break;
            case 635:
              this.$ = "" + a5[o5].value;
              break;
            case 644:
              this.$ = {};
              break;
            case 647:
              this.$ = [];
              break;
            case 648:
              n5.extend(a5[o5 - 2], a5[o5]), this.$ = a5[o5 - 2];
              break;
            case 650:
              this.$ = {}, this.$[a5[o5 - 2].substr(1, a5[o5 - 2].length - 2)] = a5[o5];
              break;
            case 651:
            case 652:
              this.$ = {}, this.$[a5[o5 - 2]] = a5[o5];
              break;
            case 655:
              this.$ = new n5.SetVariable({ variable: a5[o5 - 2].toLowerCase(), value: a5[o5] });
              break;
            case 656:
              this.$ = new n5.SetVariable({ variable: a5[o5 - 1].toLowerCase(), value: a5[o5] });
              break;
            case 657:
              this.$ = new n5.SetVariable({ variable: a5[o5 - 2], expression: a5[o5] });
              break;
            case 658:
              this.$ = new n5.SetVariable({ variable: a5[o5 - 3], props: a5[o5 - 2], expression: a5[o5] });
              break;
            case 659:
              this.$ = new n5.SetVariable({ variable: a5[o5 - 2], expression: a5[o5], method: a5[o5 - 3] });
              break;
            case 660:
              this.$ = new n5.SetVariable({ variable: a5[o5 - 3], props: a5[o5 - 2], expression: a5[o5], method: a5[o5 - 4] });
              break;
            case 661:
              this.$ = "@";
              break;
            case 662:
              this.$ = "$";
              break;
            case 668:
              this.$ = true;
              break;
            case 669:
              this.$ = false;
              break;
            case 670:
              this.$ = new n5.CommitTransaction();
              break;
            case 671:
              this.$ = new n5.RollbackTransaction();
              break;
            case 672:
              this.$ = new n5.BeginTransaction();
              break;
            case 673:
              this.$ = new n5.If({ expression: a5[o5 - 2], thenstat: a5[o5 - 1], elsestat: a5[o5] }), a5[o5 - 1].exists && (this.$.exists = a5[o5 - 1].exists), a5[o5 - 1].queries && (this.$.queries = a5[o5 - 1].queries);
              break;
            case 674:
              this.$ = new n5.If({ expression: a5[o5 - 1], thenstat: a5[o5] }), a5[o5].exists && (this.$.exists = a5[o5].exists), a5[o5].queries && (this.$.queries = a5[o5].queries);
              break;
            case 675:
              this.$ = a5[o5];
              break;
            case 676:
              this.$ = new n5.While({ expression: a5[o5 - 1], loopstat: a5[o5] }), a5[o5].exists && (this.$.exists = a5[o5].exists), a5[o5].queries && (this.$.queries = a5[o5].queries);
              break;
            case 677:
              this.$ = new n5.Continue();
              break;
            case 678:
              this.$ = new n5.Break();
              break;
            case 679:
              this.$ = new n5.BeginEnd({ statements: a5[o5 - 1] });
              break;
            case 680:
              this.$ = new n5.Print({ exprs: a5[o5] });
              break;
            case 681:
              this.$ = new n5.Print({ select: a5[o5] });
              break;
            case 682:
              this.$ = new n5.Require({ paths: a5[o5] });
              break;
            case 683:
              this.$ = new n5.Require({ plugins: a5[o5] });
              break;
            case 684:
            case 685:
              this.$ = a5[o5].toUpperCase();
              break;
            case 686:
              this.$ = new n5.Echo({ expr: a5[o5] });
              break;
            case 691:
              this.$ = new n5.Declare({ declares: a5[o5] });
              break;
            case 694:
              this.$ = { variable: a5[o5 - 1] }, n5.extend(this.$, a5[o5]);
              break;
            case 695:
              this.$ = { variable: a5[o5 - 2] }, n5.extend(this.$, a5[o5]);
              break;
            case 696:
              this.$ = { variable: a5[o5 - 3], expression: a5[o5] }, n5.extend(this.$, a5[o5 - 2]);
              break;
            case 697:
              this.$ = { variable: a5[o5 - 4], expression: a5[o5] }, n5.extend(this.$, a5[o5 - 2]);
              break;
            case 698:
              this.$ = new n5.TruncateTable({ table: a5[o5] });
              break;
            case 699:
              this.$ = new n5.Merge(), n5.extend(this.$, a5[o5 - 4]), n5.extend(this.$, a5[o5 - 3]), n5.extend(this.$, a5[o5 - 2]), n5.extend(this.$, { matches: a5[o5 - 1] }), n5.extend(this.$, a5[o5]);
              break;
            case 700:
            case 701:
              this.$ = { into: a5[o5] };
              break;
            case 703:
              this.$ = { on: a5[o5] };
              break;
            case 708:
              this.$ = { matched: true, action: a5[o5] };
              break;
            case 709:
              this.$ = { matched: true, expr: a5[o5 - 2], action: a5[o5] };
              break;
            case 710:
              this.$ = { delete: true };
              break;
            case 711:
              this.$ = { update: a5[o5] };
              break;
            case 712:
            case 713:
              this.$ = { matched: false, bytarget: true, action: a5[o5] };
              break;
            case 714:
            case 715:
              this.$ = { matched: false, bytarget: true, expr: a5[o5 - 2], action: a5[o5] };
              break;
            case 716:
              this.$ = { matched: false, bysource: true, action: a5[o5] };
              break;
            case 717:
              this.$ = { matched: false, bysource: true, expr: a5[o5 - 2], action: a5[o5] };
              break;
            case 718:
              this.$ = { insert: true, values: a5[o5] };
              break;
            case 719:
              this.$ = { insert: true, values: a5[o5], columns: a5[o5 - 3] };
              break;
            case 720:
              this.$ = { insert: true, defaultvalues: true };
              break;
            case 721:
              this.$ = { insert: true, defaultvalues: true, columns: a5[o5 - 3] };
              break;
            case 723:
              this.$ = { output: { columns: a5[o5] } };
              break;
            case 724:
              this.$ = { output: { columns: a5[o5 - 3], intovar: a5[o5], method: a5[o5 - 1] } };
              break;
            case 725:
              this.$ = { output: { columns: a5[o5 - 2], intotable: a5[o5] } };
              break;
            case 726:
              this.$ = { output: { columns: a5[o5 - 5], intotable: a5[o5 - 3], intocolumns: a5[o5 - 1] } };
              break;
            case 727:
              this.$ = new n5.CreateVertex({ class: a5[o5 - 3], sharp: a5[o5 - 2], name: a5[o5 - 1] }), n5.extend(this.$, a5[o5]);
              break;
            case 730:
              this.$ = { sets: a5[o5] };
              break;
            case 731:
              this.$ = { content: a5[o5] };
              break;
            case 732:
              this.$ = { select: a5[o5] };
              break;
            case 733:
              this.$ = new n5.CreateEdge({ from: a5[o5 - 3], to: a5[o5 - 1], name: a5[o5 - 5] }), n5.extend(this.$, a5[o5]);
              break;
            case 734:
              this.$ = new n5.CreateGraph({ graph: a5[o5] });
              break;
            case 735:
              this.$ = new n5.CreateGraph({ from: a5[o5] });
              break;
            case 738:
              this.$ = a5[o5 - 2], a5[o5 - 1] && (this.$.json = new n5.Json({ value: a5[o5 - 1] })), a5[o5] && (this.$.as = a5[o5]);
              break;
            case 739:
              this.$ = { source: a5[o5 - 6], target: a5[o5] }, a5[o5 - 3] && (this.$.json = new n5.Json({ value: a5[o5 - 3] })), a5[o5 - 2] && (this.$.as = a5[o5 - 2]), n5.extend(this.$, a5[o5 - 4]);
              break;
            case 740:
              this.$ = { source: a5[o5 - 5], target: a5[o5] }, a5[o5 - 2] && (this.$.json = new n5.Json({ value: a5[o5 - 3] })), a5[o5 - 1] && (this.$.as = a5[o5 - 2]);
              break;
            case 741:
              this.$ = { source: a5[o5 - 2], target: a5[o5] };
              break;
            case 745:
              this.$ = { vars: a5[o5], method: a5[o5 - 1] };
              break;
            case 748:
            case 749:
              c5 = a5[o5 - 1];
              this.$ = { prop: a5[o5 - 3], sharp: a5[o5 - 2], name: void 0 === c5 ? void 0 : c5.substr(1, c5.length - 2), class: a5[o5] };
              break;
            case 750:
              var h5 = a5[o5 - 1];
              this.$ = { sharp: a5[o5 - 2], name: void 0 === h5 ? void 0 : h5.substr(1, h5.length - 2), class: a5[o5] };
              break;
            case 751:
              var d5 = a5[o5 - 1];
              this.$ = { name: void 0 === d5 ? void 0 : d5.substr(1, d5.length - 2), class: a5[o5] };
              break;
            case 752:
              this.$ = { class: a5[o5] };
              break;
            case 758:
              this.$ = new n5.AddRule({ left: a5[o5 - 2], right: a5[o5] });
              break;
            case 759:
              this.$ = new n5.AddRule({ right: a5[o5] });
              break;
            case 762:
              this.$ = new n5.Term({ termid: a5[o5] });
              break;
            case 763:
              this.$ = new n5.Term({ termid: a5[o5 - 3], args: a5[o5 - 1] });
              break;
            case 766:
              this.$ = new n5.CreateTrigger({ trigger: a5[o5 - 6], when: a5[o5 - 5], action: a5[o5 - 4], table: a5[o5 - 2], statement: a5[o5] }), a5[o5].exists && (this.$.exists = a5[o5].exists), a5[o5].queries && (this.$.queries = a5[o5].queries);
              break;
            case 767:
              this.$ = new n5.CreateTrigger({ trigger: a5[o5 - 5], when: a5[o5 - 4], action: a5[o5 - 3], table: a5[o5 - 1], funcid: a5[o5] });
              break;
            case 768:
              this.$ = new n5.CreateTrigger({ trigger: a5[o5 - 6], when: a5[o5 - 4], action: a5[o5 - 3], table: a5[o5 - 5], statement: a5[o5] }), a5[o5].exists && (this.$.exists = a5[o5].exists), a5[o5].queries && (this.$.queries = a5[o5].queries);
              break;
            case 769:
            case 770:
            case 772:
              this.$ = "AFTER";
              break;
            case 771:
              this.$ = "BEFORE";
              break;
            case 773:
              this.$ = "INSTEADOF";
              break;
            case 774:
              this.$ = "INSERT";
              break;
            case 775:
              this.$ = "DELETE";
              break;
            case 776:
              this.$ = "UPDATE";
              break;
            case 777:
              this.$ = new n5.DropTrigger({ trigger: a5[o5] });
              break;
            case 778:
              this.$ = new n5.Reindex({ indexid: a5[o5] });
              break;
            case 1052:
            case 1072:
            case 1074:
            case 1076:
            case 1080:
            case 1082:
            case 1084:
            case 1086:
            case 1088:
            case 1090:
              this.$ = [];
              break;
            case 1053:
            case 1067:
            case 1069:
            case 1073:
            case 1075:
            case 1077:
            case 1081:
            case 1083:
            case 1085:
            case 1087:
            case 1089:
            case 1091:
              a5[o5 - 1].push(a5[o5]);
              break;
            case 1066:
            case 1068:
              this.$ = [a5[o5]];
          }
        }, table: [D([10, 606, 767], F = [2, 13], { 8: 1, 9: 2, 12: 3, 13: 4, 17: 5, 18: 7, 19: 8, 20: 9, 21: 10, 22: 11, 23: 12, 24: 13, 25: 14, 26: 15, 27: 16, 28: 17, 29: 18, 30: 19, 31: 20, 32: 21, 33: 22, 34: 23, 35: 24, 36: 25, 37: 26, 38: 27, 39: 28, 40: 29, 41: 30, 42: 31, 43: 32, 44: 33, 45: 34, 46: 35, 47: 36, 48: 37, 49: 38, 50: 39, 51: 40, 52: 41, 54: 43, 55: 44, 56: 45, 57: 46, 58: 47, 59: 48, 60: 49, 61: 50, 62: 51, 63: 52, 64: 53, 65: 54, 66: 55, 67: 56, 68: 57, 69: 58, 70: 59, 71: 60, 79: 75, 508: 95, 184: 99, 3: 100, 2: e = [1, 104], 4: t = [1, 102], 5: s = [1, 103], 14: _ = [1, 6], 53: P = [1, 42], 72: q = [1, 79], 89: G = [1, 76], 124: j = [1, 94], 146: V = [1, 93], 156: B = [1, 69], 189: H = [1, 101], 270: n = [1, 85], 271: J = [1, 64], 293: Y = [1, 71], 339: W = [1, 84], 342: X = [1, 66], 343: K = [1, 70], 400: Q = [1, 68], 404: z = [1, 61], 405: Z = [1, 74], 408: e1 = [1, 62], 410: t1 = [1, 67], 412: s1 = [1, 83], 413: n1 = [1, 77], 421: r1 = [1, 86], 422: a1 = [1, 87], 438: i1 = [1, 81], 440: o1 = [1, 82], 441: u1 = [1, 80], 443: l1 = [1, 88], 444: c1 = [1, 89], 445: h1 = [1, 90], 446: d1 = [1, 91], 447: f1 = [1, 92], 451: p1 = [1, 98], 452: b1 = [1, 65], 455: E1 = [1, 78], 456: g1 = [1, 72], 509: m1 = [1, 96], 511: T1 = [1, 97], 512: S1 = [1, 63], 521: A1 = [1, 73] }), { 1: [3] }, { 10: [1, 105], 11: 106, 606: gn, 767: Sn }, D(y1, [2, 8]), D(y1, [2, 9]), D(r, [2, 12]), D(y1, F, { 17: 5, 18: 7, 19: 8, 20: 9, 21: 10, 22: 11, 23: 12, 24: 13, 25: 14, 26: 15, 27: 16, 28: 17, 29: 18, 30: 19, 31: 20, 32: 21, 33: 22, 34: 23, 35: 24, 36: 25, 37: 26, 38: 27, 39: 28, 40: 29, 41: 30, 42: 31, 43: 32, 44: 33, 45: 34, 46: 35, 47: 36, 48: 37, 49: 38, 50: 39, 51: 40, 52: 41, 54: 43, 55: 44, 56: 45, 57: 46, 58: 47, 59: 48, 60: 49, 61: 50, 62: 51, 63: 52, 64: 53, 65: 54, 66: 55, 67: 56, 68: 57, 69: 58, 70: 59, 71: 60, 79: 75, 508: 95, 184: 99, 3: 100, 12: 109, 2: e, 4: t, 5: s, 15: [1, 110], 53: P, 72: q, 89: G, 124: j, 146: V, 156: B, 189: H, 270: n, 271: J, 293: Y, 339: W, 342: X, 343: K, 400: Q, 404: z, 405: Z, 408: e1, 410: t1, 412: s1, 413: n1, 421: r1, 422: a1, 438: i1, 440: o1, 441: u1, 443: l1, 444: c1, 445: h1, 446: d1, 447: f1, 451: p1, 452: b1, 455: E1, 456: g1, 509: m1, 511: T1, 512: S1, 521: A1 }), D(r, [2, 14]), D(r, [2, 15]), D(r, [2, 16]), D(r, [2, 17]), D(r, [2, 18]), D(r, [2, 19]), D(r, [2, 20]), D(r, [2, 21]), D(r, [2, 22]), D(r, [2, 23]), D(r, [2, 24]), D(r, [2, 25]), D(r, [2, 26]), D(r, [2, 27]), D(r, [2, 28]), D(r, [2, 29]), D(r, [2, 30]), D(r, [2, 31]), D(r, [2, 32]), D(r, [2, 33]), D(r, [2, 34]), D(r, [2, 35]), D(r, [2, 36]), D(r, [2, 37]), D(r, [2, 38]), D(r, [2, 39]), D(r, [2, 40]), D(r, [2, 41]), D(r, [2, 42]), D(r, [2, 43]), D(r, [2, 44]), D(r, [2, 45]), D(r, [2, 46]), D(r, [2, 47]), D(r, [2, 48]), D(r, [2, 49]), D(r, [2, 50]), D(r, [2, 51]), D(r, [2, 52]), D(r, [2, 53]), D(r, [2, 54]), D(r, [2, 55]), D(r, [2, 56]), D(r, [2, 57]), D(r, [2, 58]), D(r, [2, 59]), D(r, [2, 60]), D(r, [2, 61]), D(r, [2, 62]), D(r, [2, 63]), D(r, [2, 64]), D(r, [2, 65]), D(r, [2, 66]), D(r, [2, 67]), { 357: [1, 111] }, { 2: e, 3: 112, 4: t, 5: s }, { 2: e, 3: 114, 4: t, 5: s, 156: a, 200: 113, 293: i, 294: o, 295: u, 296: l, 297: c }, D(Gs, [2, 506], { 3: 122, 352: 126, 2: e, 4: t, 5: s, 134: v1, 135: N1, 187: [1, 124], 193: [1, 123], 272: [1, 130], 273: [1, 131], 361: [1, 132], 409: [1, 121], 476: [1, 125], 513: [1, 129] }), { 145: O1, 453: 133, 454: 134 }, { 183: [1, 136] }, { 409: [1, 137] }, { 2: e, 3: 139, 4: t, 5: s, 130: [1, 145], 193: [1, 140], 357: [1, 144], 401: 141, 409: [1, 138], 414: [1, 142], 513: [1, 143] }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 146, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, D(V1, B1, { 344: 206, 171: [1, 207], 198: H1 }), D(V1, B1, { 344: 209, 198: H1 }), { 2: e, 3: 221, 4: t, 5: s, 77: J1, 132: Y1, 143: f, 144: 214, 145: I1, 152: p, 156: a, 181: b, 198: [1, 212], 199: 215, 200: 217, 201: 216, 202: 219, 209: 211, 213: W1, 214: 220, 293: i, 294: o, 295: u, 296: l, 297: c, 306: w, 423: 191, 424: $, 428: x, 457: 210 }, { 2: e, 3: 223, 4: t, 5: s }, { 357: [1, 224] }, D(X1, [2, 1048], { 80: 225, 106: 226, 107: [1, 227] }), D(K1, [2, 1052], { 90: 228 }), { 2: e, 3: 232, 4: t, 5: s, 190: [1, 230], 193: [1, 233], 271: [1, 229], 357: [1, 234], 409: [1, 231] }, { 357: [1, 235] }, { 2: e, 3: 238, 4: t, 5: s, 73: 236, 75: 237 }, D([310, 606, 767], F, { 12: 3, 13: 4, 17: 5, 18: 7, 19: 8, 20: 9, 21: 10, 22: 11, 23: 12, 24: 13, 25: 14, 26: 15, 27: 16, 28: 17, 29: 18, 30: 19, 31: 20, 32: 21, 33: 22, 34: 23, 35: 24, 36: 25, 37: 26, 38: 27, 39: 28, 40: 29, 41: 30, 42: 31, 43: 32, 44: 33, 45: 34, 46: 35, 47: 36, 48: 37, 49: 38, 50: 39, 51: 40, 52: 41, 54: 43, 55: 44, 56: 45, 57: 46, 58: 47, 59: 48, 60: 49, 61: 50, 62: 51, 63: 52, 64: 53, 65: 54, 66: 55, 67: 56, 68: 57, 69: 58, 70: 59, 71: 60, 79: 75, 508: 95, 184: 99, 3: 100, 9: 240, 2: e, 4: t, 5: s, 14: _, 53: P, 72: q, 89: G, 124: j, 146: V, 156: B, 189: H, 270: n, 271: J, 293: Y, 339: W, 342: X, 343: K, 400: Q, 404: z, 405: Z, 408: e1, 410: t1, 412: s1, 413: n1, 421: r1, 422: a1, 438: i1, 439: [1, 239], 440: o1, 441: u1, 443: l1, 444: c1, 445: h1, 446: d1, 447: f1, 451: p1, 452: b1, 455: E1, 456: g1, 509: m1, 511: T1, 512: S1, 521: A1 }), { 439: [1, 241] }, { 439: [1, 242] }, { 2: e, 3: 244, 4: t, 5: s, 409: [1, 243] }, { 2: e, 3: 246, 4: t, 5: s, 199: 245 }, D(Q1, [2, 314]), { 113: 247, 132: d, 300: I }, { 2: e, 3: 114, 4: t, 5: s, 113: 253, 131: h, 132: [1, 250], 143: f, 144: 248, 145: z1, 152: p, 156: a, 181: b, 196: 252, 200: 257, 201: 256, 261: 254, 262: 255, 269: Z1, 278: 249, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 306: w, 423: 191, 424: $, 428: x }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 259, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, D(r, [2, 677]), D(r, [2, 678]), { 2: e, 3: 169, 4: t, 5: s, 40: 261, 56: 166, 77: C1, 79: 75, 89: G, 94: 262, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 151: 260, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 184: 99, 189: H, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 268, 4: t, 5: s, 113: 265, 132: d, 300: I, 448: 263, 449: 264, 450: 266, 451: e2 }, { 2: e, 3: 269, 4: t, 5: s, 143: t2, 145: s2, 435: 270 }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 273, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 509: [1, 274] }, { 2: e, 3: 100, 4: t, 5: s, 508: 276, 510: 275 }, { 2: e, 3: 114, 4: t, 5: s, 156: a, 200: 277, 293: i, 294: o, 295: u, 296: l, 297: c }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 278, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, D(n2, r2, { 186: 282, 164: [1, 281], 185: [1, 279], 187: [1, 280], 195: a2 }), D(i2, [2, 762], { 77: [1, 284] }), D([2, 4, 5, 10, 72, 77, 78, 93, 98, 107, 118, 128, 131, 132, 137, 143, 145, 152, 154, 156, 162, 164, 168, 169, 179, 180, 181, 183, 185, 187, 195, 198, 232, 244, 245, 249, 251, 269, 270, 274, 275, 277, 284, 285, 286, 287, 288, 289, 290, 291, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 306, 307, 310, 314, 316, 321, 424, 428, 606, 767], [2, 152], { 149: [1, 285], 150: [1, 286], 190: [1, 287], 191: [1, 288], 192: [1, 289], 193: [1, 290], 194: [1, 291] }), D(k, [2, 1]), D(k, [2, 2]), { 6: 292, 131: [1, 441], 172: [1, 464], 243: [1, 440], 244: [1, 375], 245: [1, 409], 249: [1, 413], 374: [1, 406], 385: [1, 297], 406: [1, 299], 414: [1, 551], 418: [1, 473], 420: [1, 445], 421: [1, 511], 437: [1, 444], 439: [1, 527], 444: [1, 344], 464: [1, 420], 468: [1, 450], 474: [1, 343], 518: [1, 309], 519: [1, 301], 520: [1, 401], 522: [1, 293], 523: [1, 294], 524: [1, 295], 525: [1, 296], 526: [1, 298], 527: [1, 300], 528: [1, 302], 529: [1, 303], 530: [1, 304], 531: [1, 305], 532: [1, 306], 533: [1, 307], 534: [1, 308], 535: [1, 310], 536: [1, 311], 537: [1, 312], 538: [1, 313], 539: [1, 314], 540: [1, 315], 541: [1, 316], 542: [1, 317], 543: [1, 318], 544: [1, 319], 545: [1, 320], 546: [1, 321], 547: [1, 322], 548: [1, 323], 549: [1, 324], 550: [1, 325], 551: [1, 326], 552: [1, 327], 553: [1, 328], 554: [1, 329], 555: [1, 330], 556: [1, 331], 557: [1, 332], 558: [1, 333], 559: [1, 334], 560: [1, 335], 561: [1, 336], 562: [1, 337], 563: [1, 338], 564: [1, 339], 565: [1, 340], 566: [1, 341], 567: [1, 342], 568: [1, 345], 569: [1, 346], 570: [1, 347], 571: [1, 348], 572: [1, 349], 573: [1, 350], 574: [1, 351], 575: [1, 352], 576: [1, 353], 577: [1, 354], 578: [1, 355], 579: [1, 356], 580: [1, 357], 581: [1, 358], 582: [1, 359], 583: [1, 360], 584: [1, 361], 585: [1, 362], 586: [1, 363], 587: [1, 364], 588: [1, 365], 589: [1, 366], 590: [1, 367], 591: [1, 368], 592: [1, 369], 593: [1, 370], 594: [1, 371], 595: [1, 372], 596: [1, 373], 597: [1, 374], 598: [1, 376], 599: [1, 377], 600: [1, 378], 601: [1, 379], 602: [1, 380], 603: [1, 381], 604: [1, 382], 605: [1, 383], 606: [1, 384], 607: [1, 385], 608: [1, 386], 609: [1, 387], 610: [1, 388], 611: [1, 389], 612: [1, 390], 613: [1, 391], 614: [1, 392], 615: [1, 393], 616: [1, 394], 617: [1, 395], 618: [1, 396], 619: [1, 397], 620: [1, 398], 621: [1, 399], 622: [1, 400], 623: [1, 402], 624: [1, 403], 625: [1, 404], 626: [1, 405], 627: [1, 407], 628: [1, 408], 629: [1, 410], 630: [1, 411], 631: [1, 412], 632: [1, 414], 633: [1, 415], 634: [1, 416], 635: [1, 417], 636: [1, 418], 637: [1, 419], 638: [1, 421], 639: [1, 422], 640: [1, 423], 641: [1, 424], 642: [1, 425], 643: [1, 426], 644: [1, 427], 645: [1, 428], 646: [1, 429], 647: [1, 430], 648: [1, 431], 649: [1, 432], 650: [1, 433], 651: [1, 434], 652: [1, 435], 653: [1, 436], 654: [1, 437], 655: [1, 438], 656: [1, 439], 657: [1, 442], 658: [1, 443], 659: [1, 446], 660: [1, 447], 661: [1, 448], 662: [1, 449], 663: [1, 451], 664: [1, 452], 665: [1, 453], 666: [1, 454], 667: [1, 455], 668: [1, 456], 669: [1, 457], 670: [1, 458], 671: [1, 459], 672: [1, 460], 673: [1, 461], 674: [1, 462], 675: [1, 463], 676: [1, 465], 677: [1, 466], 678: [1, 467], 679: [1, 468], 680: [1, 469], 681: [1, 470], 682: [1, 471], 683: [1, 472], 684: [1, 474], 685: [1, 475], 686: [1, 476], 687: [1, 477], 688: [1, 478], 689: [1, 479], 690: [1, 480], 691: [1, 481], 692: [1, 482], 693: [1, 483], 694: [1, 484], 695: [1, 485], 696: [1, 486], 697: [1, 487], 698: [1, 488], 699: [1, 489], 700: [1, 490], 701: [1, 491], 702: [1, 492], 703: [1, 493], 704: [1, 494], 705: [1, 495], 706: [1, 496], 707: [1, 497], 708: [1, 498], 709: [1, 499], 710: [1, 500], 711: [1, 501], 712: [1, 502], 713: [1, 503], 714: [1, 504], 715: [1, 505], 716: [1, 506], 717: [1, 507], 718: [1, 508], 719: [1, 509], 720: [1, 510], 721: [1, 512], 722: [1, 513], 723: [1, 514], 724: [1, 515], 725: [1, 516], 726: [1, 517], 727: [1, 518], 728: [1, 519], 729: [1, 520], 730: [1, 521], 731: [1, 522], 732: [1, 523], 733: [1, 524], 734: [1, 525], 735: [1, 526], 736: [1, 528], 737: [1, 529], 738: [1, 530], 739: [1, 531], 740: [1, 532], 741: [1, 533], 742: [1, 534], 743: [1, 535], 744: [1, 536], 745: [1, 537], 746: [1, 538], 747: [1, 539], 748: [1, 540], 749: [1, 541], 750: [1, 542], 751: [1, 543], 752: [1, 544], 753: [1, 545], 754: [1, 546], 755: [1, 547], 756: [1, 548], 757: [1, 549], 758: [1, 550], 759: [1, 552], 760: [1, 553], 761: [1, 554], 762: [1, 555], 763: [1, 556], 764: [1, 557], 765: [1, 558], 766: [1, 559] }, { 1: [2, 6] }, D(y1, F, { 17: 5, 18: 7, 19: 8, 20: 9, 21: 10, 22: 11, 23: 12, 24: 13, 25: 14, 26: 15, 27: 16, 28: 17, 29: 18, 30: 19, 31: 20, 32: 21, 33: 22, 34: 23, 35: 24, 36: 25, 37: 26, 38: 27, 39: 28, 40: 29, 41: 30, 42: 31, 43: 32, 44: 33, 45: 34, 46: 35, 47: 36, 48: 37, 49: 38, 50: 39, 51: 40, 52: 41, 54: 43, 55: 44, 56: 45, 57: 46, 58: 47, 59: 48, 60: 49, 61: 50, 62: 51, 63: 52, 64: 53, 65: 54, 66: 55, 67: 56, 68: 57, 69: 58, 70: 59, 71: 60, 79: 75, 508: 95, 184: 99, 3: 100, 12: 560, 2: e, 4: t, 5: s, 53: P, 72: q, 89: G, 124: j, 146: V, 156: B, 189: H, 270: n, 271: J, 293: Y, 339: W, 342: X, 343: K, 400: Q, 404: z, 405: Z, 408: e1, 410: t1, 412: s1, 413: n1, 421: r1, 422: a1, 438: i1, 440: o1, 441: u1, 443: l1, 444: c1, 445: h1, 446: d1, 447: f1, 451: p1, 452: b1, 455: E1, 456: g1, 509: m1, 511: T1, 512: S1, 521: A1 }), D(o2, [2, 1046]), D(o2, [2, 1047]), D(y1, [2, 10]), { 16: [1, 561] }, { 2: e, 3: 246, 4: t, 5: s, 199: 562 }, { 409: [1, 563] }, D(r, [2, 765]), { 77: u2 }, { 77: [1, 565] }, { 77: l2 }, { 77: [1, 567] }, { 77: [1, 568] }, { 77: [1, 569] }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 570, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, D(V1, c2, { 354: 571, 156: h2 }), { 409: [1, 573] }, { 2: e, 3: 574, 4: t, 5: s }, { 193: [1, 575] }, { 2: e, 3: 581, 4: t, 5: s, 132: d2, 137: f2, 143: t2, 145: s2, 152: p2, 183: [1, 577], 435: 588, 477: 576, 478: 578, 479: 579, 482: 580, 486: 585, 497: 582, 501: 584 }, { 130: [1, 592], 353: 589, 357: [1, 591], 414: [1, 590] }, { 113: 594, 132: d, 183: [2, 1146], 300: I, 475: 593 }, D(b2, [2, 1140], { 469: 595, 3: 596, 2: e, 4: t, 5: s }), { 2: e, 3: 597, 4: t, 5: s }, { 4: [1, 598] }, { 4: [1, 599] }, D(Gs, [2, 507]), D(r, [2, 691], { 74: [1, 600] }), D(E2, [2, 692]), { 2: e, 3: 601, 4: t, 5: s }, { 2: e, 3: 246, 4: t, 5: s, 199: 602 }, { 2: e, 3: 603, 4: t, 5: s }, D(V1, g2, { 402: 604, 156: m2 }), { 409: [1, 606] }, { 2: e, 3: 607, 4: t, 5: s }, D(V1, g2, { 402: 608, 156: m2 }), D(V1, g2, { 402: 609, 156: m2 }), { 2: e, 3: 610, 4: t, 5: s }, D(T2, [2, 1134]), D(T2, [2, 1135]), D(r, F, { 17: 5, 18: 7, 19: 8, 20: 9, 21: 10, 22: 11, 23: 12, 24: 13, 25: 14, 26: 15, 27: 16, 28: 17, 29: 18, 30: 19, 31: 20, 32: 21, 33: 22, 34: 23, 35: 24, 36: 25, 37: 26, 38: 27, 39: 28, 40: 29, 41: 30, 42: 31, 43: 32, 44: 33, 45: 34, 46: 35, 47: 36, 48: 37, 49: 38, 50: 39, 51: 40, 52: 41, 54: 43, 55: 44, 56: 45, 57: 46, 58: 47, 59: 48, 60: 49, 61: 50, 62: 51, 63: 52, 64: 53, 65: 54, 66: 55, 67: 56, 68: 57, 69: 58, 70: 59, 71: 60, 79: 75, 508: 95, 184: 99, 3: 100, 12: 611, 114: 628, 331: 640, 2: e, 4: t, 5: s, 53: P, 72: q, 89: G, 99: S2, 112: A2, 115: y2, 116: v2, 123: N2, 124: O2, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 146: V, 154: L2, 156: B, 170: D2, 171: M2, 179: U2, 180: F2, 189: H, 270: n, 271: J, 293: Y, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 334: Z2, 335: ee, 336: te, 337: se, 339: W, 342: X, 343: K, 400: Q, 404: z, 405: Z, 408: e1, 410: t1, 412: s1, 413: n1, 421: r1, 422: a1, 438: i1, 440: o1, 441: u1, 443: l1, 444: c1, 445: h1, 446: d1, 447: f1, 451: p1, 452: b1, 455: E1, 456: g1, 509: m1, 511: T1, 512: S1, 521: A1 }), D(Q1, [2, 291]), D(Q1, [2, 292]), D(Q1, [2, 293]), D(Q1, [2, 294]), D(Q1, [2, 295]), D(Q1, [2, 296]), D(Q1, [2, 297]), D(Q1, [2, 298]), D(Q1, [2, 299]), D(Q1, [2, 300]), D(Q1, [2, 301]), D(Q1, [2, 302]), D(Q1, [2, 303]), D(Q1, [2, 304]), D(Q1, [2, 305]), D(Q1, [2, 306]), D(Q1, [2, 307]), D(Q1, [2, 308]), { 2: e, 3: 169, 4: t, 5: s, 26: 657, 27: 656, 36: 652, 40: 651, 56: 166, 77: C1, 79: 75, 89: G, 94: 654, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 184: 99, 189: H, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 268: 653, 269: L1, 270: n, 271: [1, 658], 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: [1, 655], 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 343: K, 423: 191, 424: $, 428: x }, D(Q1, [2, 312]), D(Q1, [2, 313]), { 77: [1, 659] }, D([2, 4, 5, 10, 53, 72, 74, 76, 78, 89, 93, 95, 98, 99, 107, 112, 115, 118, 122, 123, 124, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 145, 146, 148, 149, 150, 152, 154, 156, 162, 164, 166, 168, 169, 170, 171, 172, 173, 175, 179, 180, 181, 183, 185, 187, 189, 198, 206, 208, 222, 223, 224, 225, 226, 227, 228, 229, 232, 239, 244, 245, 246, 247, 249, 251, 270, 271, 284, 285, 286, 287, 288, 289, 290, 291, 293, 300, 304, 310, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 334, 335, 336, 337, 339, 342, 343, 400, 404, 405, 408, 410, 412, 413, 421, 422, 424, 428, 438, 440, 441, 443, 444, 445, 446, 447, 451, 452, 455, 456, 468, 474, 509, 511, 512, 521, 606, 767], ne, { 77: u2, 116: [1, 660] }), { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 661, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 662, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 663, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 664, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 665, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, D(Q1, [2, 286]), D([2, 4, 5, 10, 53, 72, 74, 76, 77, 78, 89, 93, 95, 98, 99, 107, 112, 115, 116, 118, 122, 123, 124, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 145, 146, 148, 149, 150, 152, 154, 156, 162, 164, 166, 168, 169, 170, 171, 172, 173, 175, 179, 180, 181, 183, 185, 187, 189, 198, 206, 208, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 239, 244, 245, 246, 247, 249, 251, 253, 269, 270, 271, 274, 275, 277, 284, 285, 286, 287, 288, 289, 290, 291, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 306, 307, 310, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 334, 335, 336, 337, 339, 342, 343, 347, 360, 372, 373, 377, 378, 400, 404, 405, 408, 410, 412, 413, 419, 421, 422, 424, 428, 430, 438, 440, 441, 443, 444, 445, 446, 447, 451, 452, 455, 456, 468, 474, 509, 511, 512, 521, 606, 767, 768, 769], [2, 361]), D(re, [2, 362]), D(re, [2, 363]), D(re, ae), D(re, [2, 365]), D([2, 4, 5, 10, 53, 72, 74, 76, 77, 78, 89, 93, 95, 98, 99, 107, 112, 115, 116, 118, 122, 123, 124, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 145, 146, 148, 149, 150, 152, 154, 156, 162, 164, 166, 168, 169, 170, 171, 172, 173, 175, 179, 180, 181, 183, 185, 187, 189, 198, 206, 208, 222, 223, 224, 225, 226, 227, 228, 229, 230, 232, 239, 244, 245, 246, 247, 249, 251, 270, 271, 284, 285, 286, 287, 288, 289, 290, 291, 293, 300, 301, 304, 310, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 334, 335, 336, 337, 339, 342, 343, 347, 360, 372, 373, 377, 378, 400, 404, 405, 408, 410, 412, 413, 421, 422, 424, 428, 430, 438, 440, 441, 443, 444, 445, 446, 447, 451, 452, 455, 456, 468, 474, 509, 511, 512, 521, 606, 767], [2, 366]), { 2: e, 3: 667, 4: t, 5: s, 131: [1, 668], 305: 666 }, { 2: e, 3: 669, 4: t, 5: s }, D(re, [2, 372]), D(re, [2, 373]), { 2: e, 3: 670, 4: t, 5: s, 77: ie, 113: 672, 131: h, 132: d, 143: f, 152: p, 181: b, 196: 673, 201: 675, 261: 674, 298: C, 299: R, 300: I, 306: w, 423: 676, 428: x }, { 77: [1, 677] }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 678, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 308: 679, 311: 680, 312: oe, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 77: [1, 682] }, { 77: [1, 683] }, D(ue, [2, 629]), { 2: e, 3: 698, 4: t, 5: s, 77: le, 111: 693, 113: 691, 131: h, 132: d, 143: f, 144: 688, 145: z1, 152: p, 156: a, 181: b, 196: 690, 200: 696, 201: 695, 261: 692, 262: 694, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 304: [1, 686], 306: w, 423: 191, 424: $, 425: 684, 426: 687, 427: 689, 428: x, 431: 685 }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 262, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 151: 699, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 700, 4: t, 5: s, 156: a, 200: 701, 293: i, 294: o, 295: u, 296: l, 297: c }, { 77: [2, 339] }, { 77: [2, 340] }, { 77: [2, 341] }, { 77: [2, 342] }, { 77: [2, 343] }, { 77: [2, 344] }, { 77: [2, 345] }, { 77: [2, 346] }, { 77: [2, 347] }, { 77: [2, 348] }, { 2: e, 3: 707, 4: t, 5: s, 131: ce, 132: he, 429: 702, 430: [1, 703], 432: 704 }, { 2: e, 3: 246, 4: t, 5: s, 199: 708 }, { 293: [1, 709] }, D(V1, [2, 477]), { 2: e, 3: 246, 4: t, 5: s, 199: 710 }, { 231: [1, 712], 458: 711 }, { 231: [2, 700] }, { 2: e, 3: 221, 4: t, 5: s, 77: J1, 132: Y1, 143: f, 144: 214, 145: I1, 152: p, 156: a, 181: b, 199: 215, 200: 217, 201: 216, 202: 219, 209: 713, 213: W1, 214: 220, 293: i, 294: o, 295: u, 296: l, 297: c, 306: w, 423: 191, 424: $, 428: x }, { 40: 714, 79: 75, 89: G, 184: 99, 189: H }, D(de, [2, 1096], { 210: 715, 76: [1, 716] }), D(fe, [2, 185], { 3: 717, 2: e, 4: t, 5: s, 76: [1, 718], 154: [1, 719] }), D(fe, [2, 189], { 3: 720, 2: e, 4: t, 5: s, 76: [1, 721] }), D(fe, [2, 190], { 3: 722, 2: e, 4: t, 5: s, 76: [1, 723] }), D(fe, [2, 193]), D(fe, [2, 194], { 3: 724, 2: e, 4: t, 5: s, 76: [1, 725] }), D(fe, [2, 197], { 3: 726, 2: e, 4: t, 5: s, 76: [1, 727] }), D([2, 4, 5, 10, 72, 74, 76, 78, 93, 98, 118, 128, 154, 162, 168, 169, 183, 206, 208, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 249, 251, 310, 314, 606, 767], pe, { 77: u2, 116: be }), D([2, 4, 5, 10, 72, 74, 76, 78, 93, 98, 118, 128, 162, 168, 169, 206, 208, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 249, 251, 310, 314, 606, 767], [2, 200]), D(r, [2, 778]), { 2: e, 3: 246, 4: t, 5: s, 199: 729 }, D(Ee, rn, { 81: 730, 198: an }), D(X1, [2, 1049]), D(ge, [2, 1062], { 108: 732, 190: [1, 733] }), D([10, 78, 183, 310, 314, 606, 767], rn, { 423: 191, 81: 734, 117: 735, 3: 736, 114: 739, 144: 761, 158: 771, 160: 772, 2: e, 4: t, 5: s, 72: me, 76: Te, 77: Se, 112: Ae, 115: y2, 116: v2, 118: ye, 122: ve, 123: Ne, 124: Oe, 128: Ce, 129: Re, 130: Ie, 131: we, 132: $e, 133: xe, 134: ke, 135: Le, 136: De, 137: Me, 138: Ue, 139: Fe, 140: _e, 141: Pe, 142: qe, 143: Ge, 145: je, 146: Ve, 148: Be, 149: He, 150: Je, 152: Ye, 154: We, 156: Xe, 162: Ke, 164: Qe, 166: ze, 168: Ze, 169: et, 170: tt, 171: st, 172: nt, 173: rt, 175: at, 185: it, 187: ot, 198: an, 244: E, 245: g, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 424: $, 428: x }), { 357: [1, 785] }, { 183: [1, 786] }, D(r, [2, 599], { 112: [1, 787] }), { 409: [1, 788] }, { 183: [1, 789] }, D(r, [2, 603], { 112: [1, 790], 183: [1, 791] }), { 2: e, 3: 246, 4: t, 5: s, 199: 792 }, { 40: 793, 74: [1, 794], 79: 75, 89: G, 184: 99, 189: H }, D(ut, [2, 70]), { 76: [1, 795] }, D(r, [2, 672]), { 11: 106, 310: [1, 796], 606: gn, 767: Sn }, D(r, [2, 670]), D(r, [2, 671]), { 2: e, 3: 797, 4: t, 5: s }, D(r, [2, 592]), { 146: [1, 798] }, D([2, 4, 5, 10, 53, 72, 74, 76, 77, 78, 89, 95, 124, 128, 143, 145, 146, 148, 149, 152, 154, 156, 181, 183, 187, 189, 230, 270, 271, 293, 301, 306, 310, 314, 339, 342, 343, 347, 348, 360, 372, 373, 377, 378, 400, 404, 405, 406, 407, 408, 410, 412, 413, 421, 422, 424, 428, 438, 440, 441, 443, 444, 445, 446, 447, 451, 452, 455, 456, 509, 511, 512, 518, 519, 520, 521, 606, 767], pe, { 116: be }), D(r, [2, 620]), D(r, [2, 621]), D(r, [2, 622]), D(r, ae, { 74: [1, 799] }), { 77: ie, 113: 672, 131: h, 132: d, 143: f, 152: p, 181: b, 196: 673, 201: 675, 261: 674, 298: C, 299: R, 300: I, 306: w, 423: 676, 428: x }, D(lt, [2, 323]), D(lt, [2, 324]), D(lt, [2, 325]), D(lt, [2, 326]), D(lt, [2, 327]), D(lt, [2, 328]), D(lt, [2, 329]), D(r, F, { 17: 5, 18: 7, 19: 8, 20: 9, 21: 10, 22: 11, 23: 12, 24: 13, 25: 14, 26: 15, 27: 16, 28: 17, 29: 18, 30: 19, 31: 20, 32: 21, 33: 22, 34: 23, 35: 24, 36: 25, 37: 26, 38: 27, 39: 28, 40: 29, 41: 30, 42: 31, 43: 32, 44: 33, 45: 34, 46: 35, 47: 36, 48: 37, 49: 38, 50: 39, 51: 40, 52: 41, 54: 43, 55: 44, 56: 45, 57: 46, 58: 47, 59: 48, 60: 49, 61: 50, 62: 51, 63: 52, 64: 53, 65: 54, 66: 55, 67: 56, 68: 57, 69: 58, 70: 59, 71: 60, 79: 75, 508: 95, 184: 99, 3: 100, 114: 628, 331: 640, 12: 800, 2: e, 4: t, 5: s, 53: P, 72: q, 89: G, 99: S2, 112: A2, 115: y2, 116: v2, 123: N2, 124: O2, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 146: V, 154: L2, 156: B, 170: D2, 171: M2, 179: U2, 180: F2, 189: H, 270: n, 271: J, 293: Y, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 334: Z2, 335: ee, 336: te, 337: se, 339: W, 342: X, 343: K, 400: Q, 404: z, 405: Z, 408: e1, 410: t1, 412: s1, 413: n1, 421: r1, 422: a1, 438: i1, 440: o1, 441: u1, 443: l1, 444: c1, 445: h1, 446: d1, 447: f1, 451: p1, 452: b1, 455: E1, 456: g1, 509: m1, 511: T1, 512: S1, 521: A1 }), D(r, [2, 680], { 74: ct }), D(r, [2, 681]), D(ht, [2, 359], { 114: 628, 331: 640, 99: S2, 112: A2, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 334: Z2, 335: ee, 336: te, 337: se }), D(r, [2, 682], { 74: [1, 803] }), D(r, [2, 683], { 74: [1, 804] }), D(E2, [2, 688]), D(E2, [2, 690]), D(E2, [2, 684]), D(E2, [2, 685]), { 114: 810, 115: y2, 116: v2, 124: [1, 805], 230: ft, 433: 806, 434: 807, 437: pt }, { 2: e, 3: 811, 4: t, 5: s }, D(V1, [2, 661]), D(V1, [2, 662]), D(r, [2, 619], { 114: 628, 331: 640, 99: S2, 112: A2, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 334: Z2, 335: ee, 336: te, 337: se }), { 2: e, 3: 100, 4: t, 5: s, 508: 276, 510: 812 }, D(r, [2, 759], { 74: bt }), D(Et, [2, 761]), D(r, [2, 764]), D(r, [2, 686], { 114: 628, 331: 640, 99: S2, 112: A2, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 334: Z2, 335: ee, 336: te, 337: se }), D(gt, r2, { 186: 814, 195: a2 }), D(gt, r2, { 186: 815, 195: a2 }), D(gt, r2, { 186: 816, 195: a2 }), D(mt, [2, 1092], { 259: 147, 200: 148, 260: 149, 111: 150, 258: 151, 196: 152, 261: 153, 113: 154, 262: 155, 201: 156, 202: 157, 263: 158, 264: 159, 265: 160, 144: 162, 266: 163, 267: 164, 56: 166, 158: 168, 3: 169, 423: 191, 188: 817, 174: 818, 257: 819, 94: 820, 2: e, 4: t, 5: s, 77: C1, 131: h, 132: d, 137: R1, 143: f, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 179: x1, 180: k1, 181: b, 244: E, 245: g, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 424: $, 428: x }), { 77: [1, 822], 131: h, 196: 821 }, { 2: e, 3: 100, 4: t, 5: s, 508: 276, 510: 823 }, D(Tt, [2, 153]), D(Tt, [2, 154]), D(Tt, [2, 155]), D(Tt, [2, 156]), D(Tt, [2, 157]), D(Tt, [2, 158]), D(Tt, [2, 159]), D(k, [2, 3]), D(k, [2, 779]), D(k, [2, 780]), D(k, [2, 781]), D(k, [2, 782]), D(k, [2, 783]), D(k, [2, 784]), D(k, [2, 785]), D(k, [2, 786]), D(k, [2, 787]), D(k, [2, 788]), D(k, [2, 789]), D(k, [2, 790]), D(k, [2, 791]), D(k, [2, 792]), D(k, [2, 793]), D(k, [2, 794]), D(k, [2, 795]), D(k, [2, 796]), D(k, [2, 797]), D(k, [2, 798]), D(k, [2, 799]), D(k, [2, 800]), D(k, [2, 801]), D(k, [2, 802]), D(k, [2, 803]), D(k, [2, 804]), D(k, [2, 805]), D(k, [2, 806]), D(k, [2, 807]), D(k, [2, 808]), D(k, [2, 809]), D(k, [2, 810]), D(k, [2, 811]), D(k, [2, 812]), D(k, [2, 813]), D(k, [2, 814]), D(k, [2, 815]), D(k, [2, 816]), D(k, [2, 817]), D(k, [2, 818]), D(k, [2, 819]), D(k, [2, 820]), D(k, [2, 821]), D(k, [2, 822]), D(k, [2, 823]), D(k, [2, 824]), D(k, [2, 825]), D(k, [2, 826]), D(k, [2, 827]), D(k, [2, 828]), D(k, [2, 829]), D(k, [2, 830]), D(k, [2, 831]), D(k, [2, 832]), D(k, [2, 833]), D(k, [2, 834]), D(k, [2, 835]), D(k, [2, 836]), D(k, [2, 837]), D(k, [2, 838]), D(k, [2, 839]), D(k, [2, 840]), D(k, [2, 841]), D(k, [2, 842]), D(k, [2, 843]), D(k, [2, 844]), D(k, [2, 845]), D(k, [2, 846]), D(k, [2, 847]), D(k, [2, 848]), D(k, [2, 849]), D(k, [2, 850]), D(k, [2, 851]), D(k, [2, 852]), D(k, [2, 853]), D(k, [2, 854]), D(k, [2, 855]), D(k, [2, 856]), D(k, [2, 857]), D(k, [2, 858]), D(k, [2, 859]), D(k, [2, 860]), D(k, [2, 861]), D(k, [2, 862]), D(k, [2, 863]), D(k, [2, 864]), D(k, [2, 865]), D(k, [2, 866]), D(k, [2, 867]), D(k, [2, 868]), D(k, [2, 869]), D(k, [2, 870]), D(k, [2, 871]), D(k, [2, 872]), D(k, [2, 873]), D(k, [2, 874]), D(k, [2, 875]), D(k, [2, 876]), D(k, [2, 877]), D(k, [2, 878]), D(k, [2, 879]), D(k, [2, 880]), D(k, [2, 881]), D(k, [2, 882]), D(k, [2, 883]), D(k, [2, 884]), D(k, [2, 885]), D(k, [2, 886]), D(k, [2, 887]), D(k, [2, 888]), D(k, [2, 889]), D(k, [2, 890]), D(k, [2, 891]), D(k, [2, 892]), D(k, [2, 893]), D(k, [2, 894]), D(k, [2, 895]), D(k, [2, 896]), D(k, [2, 897]), D(k, [2, 898]), D(k, [2, 899]), D(k, [2, 900]), D(k, [2, 901]), D(k, [2, 902]), D(k, [2, 903]), D(k, [2, 904]), D(k, [2, 905]), D(k, [2, 906]), D(k, [2, 907]), D(k, [2, 908]), D(k, [2, 909]), D(k, [2, 910]), D(k, [2, 911]), D(k, [2, 912]), D(k, [2, 913]), D(k, [2, 914]), D(k, [2, 915]), D(k, [2, 916]), D(k, [2, 917]), D(k, [2, 918]), D(k, [2, 919]), D(k, [2, 920]), D(k, [2, 921]), D(k, [2, 922]), D(k, [2, 923]), D(k, [2, 924]), D(k, [2, 925]), D(k, [2, 926]), D(k, [2, 927]), D(k, [2, 928]), D(k, [2, 929]), D(k, [2, 930]), D(k, [2, 931]), D(k, [2, 932]), D(k, [2, 933]), D(k, [2, 934]), D(k, [2, 935]), D(k, [2, 936]), D(k, [2, 937]), D(k, [2, 938]), D(k, [2, 939]), D(k, [2, 940]), D(k, [2, 941]), D(k, [2, 942]), D(k, [2, 943]), D(k, [2, 944]), D(k, [2, 945]), D(k, [2, 946]), D(k, [2, 947]), D(k, [2, 948]), D(k, [2, 949]), D(k, [2, 950]), D(k, [2, 951]), D(k, [2, 952]), D(k, [2, 953]), D(k, [2, 954]), D(k, [2, 955]), D(k, [2, 956]), D(k, [2, 957]), D(k, [2, 958]), D(k, [2, 959]), D(k, [2, 960]), D(k, [2, 961]), D(k, [2, 962]), D(k, [2, 963]), D(k, [2, 964]), D(k, [2, 965]), D(k, [2, 966]), D(k, [2, 967]), D(k, [2, 968]), D(k, [2, 969]), D(k, [2, 970]), D(k, [2, 971]), D(k, [2, 972]), D(k, [2, 973]), D(k, [2, 974]), D(k, [2, 975]), D(k, [2, 976]), D(k, [2, 977]), D(k, [2, 978]), D(k, [2, 979]), D(k, [2, 980]), D(k, [2, 981]), D(k, [2, 982]), D(k, [2, 983]), D(k, [2, 984]), D(k, [2, 985]), D(k, [2, 986]), D(k, [2, 987]), D(k, [2, 988]), D(k, [2, 989]), D(k, [2, 990]), D(k, [2, 991]), D(k, [2, 992]), D(k, [2, 993]), D(k, [2, 994]), D(k, [2, 995]), D(k, [2, 996]), D(k, [2, 997]), D(k, [2, 998]), D(k, [2, 999]), D(k, [2, 1e3]), D(k, [2, 1001]), D(k, [2, 1002]), D(k, [2, 1003]), D(k, [2, 1004]), D(k, [2, 1005]), D(k, [2, 1006]), D(k, [2, 1007]), D(k, [2, 1008]), D(k, [2, 1009]), D(k, [2, 1010]), D(k, [2, 1011]), D(k, [2, 1012]), D(k, [2, 1013]), D(k, [2, 1014]), D(k, [2, 1015]), D(k, [2, 1016]), D(k, [2, 1017]), D(k, [2, 1018]), D(k, [2, 1019]), D(k, [2, 1020]), D(k, [2, 1021]), D(k, [2, 1022]), D(k, [2, 1023]), D(k, [2, 1024]), D(k, [2, 1025]), D(k, [2, 1026]), D(k, [2, 1027]), D(k, [2, 1028]), D(k, [2, 1029]), D(k, [2, 1030]), D(k, [2, 1031]), D(k, [2, 1032]), D(k, [2, 1033]), D(k, [2, 1034]), D(k, [2, 1035]), D(k, [2, 1036]), D(k, [2, 1037]), D(k, [2, 1038]), D(k, [2, 1039]), D(k, [2, 1040]), D(k, [2, 1041]), D(k, [2, 1042]), D(k, [2, 1043]), D(k, [2, 1044]), D(k, [2, 1045]), D(y1, [2, 7]), D(y1, F, { 17: 5, 18: 7, 19: 8, 20: 9, 21: 10, 22: 11, 23: 12, 24: 13, 25: 14, 26: 15, 27: 16, 28: 17, 29: 18, 30: 19, 31: 20, 32: 21, 33: 22, 34: 23, 35: 24, 36: 25, 37: 26, 38: 27, 39: 28, 40: 29, 41: 30, 42: 31, 43: 32, 44: 33, 45: 34, 46: 35, 47: 36, 48: 37, 49: 38, 50: 39, 51: 40, 52: 41, 54: 43, 55: 44, 56: 45, 57: 46, 58: 47, 59: 48, 60: 49, 61: 50, 62: 51, 63: 52, 64: 53, 65: 54, 66: 55, 67: 56, 68: 57, 69: 58, 70: 59, 71: 60, 79: 75, 508: 95, 184: 99, 3: 100, 12: 824, 2: e, 4: t, 5: s, 53: P, 72: q, 89: G, 124: j, 146: V, 156: B, 189: H, 270: n, 271: J, 293: Y, 339: W, 342: X, 343: K, 400: Q, 404: z, 405: Z, 408: e1, 410: t1, 412: s1, 413: n1, 421: r1, 422: a1, 438: i1, 440: o1, 441: u1, 443: l1, 444: c1, 445: h1, 446: d1, 447: f1, 451: p1, 452: b1, 455: E1, 456: g1, 509: m1, 511: T1, 512: S1, 521: A1 }), { 400: [1, 828], 405: [1, 825], 406: [1, 826], 407: [1, 827] }, { 2: e, 3: 829, 4: t, 5: s }, D(gt, [2, 1116], { 292: 830, 770: 832, 78: [1, 831], 164: [1, 834], 185: [1, 833] }), { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 262, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 151: 835, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 262, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 151: 836, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 837, 4: t, 5: s, 132: [1, 838] }, { 2: e, 3: 839, 4: t, 5: s, 132: [1, 840] }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 841, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 842, 4: t, 5: s, 99: S2, 112: A2, 114: 628, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 331: 640, 334: Z2, 335: ee, 336: te, 337: se }, { 2: e, 3: 843, 4: t, 5: s }, { 154: [1, 844] }, D(St, c2, { 354: 845, 156: h2 }), { 230: [1, 846] }, { 2: e, 3: 847, 4: t, 5: s }, D(r, [2, 734], { 74: At }), { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 849, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, D(Et, [2, 737]), D(yt, [2, 1148], { 423: 191, 480: 850, 144: 851, 139: vt, 141: vt, 145: z1, 424: $, 428: x }), { 139: [1, 852], 141: [1, 853] }, D(Nt, Ot, { 494: 855, 497: 856, 77: [1, 854], 137: f2 }), D(Ct, [2, 1172], { 498: 857, 132: [1, 858] }), D(Rt, [2, 1176], { 500: 859, 501: 860, 152: p2 }), D(Rt, [2, 752]), D(It, [2, 744]), { 2: e, 3: 861, 4: t, 5: s, 131: [1, 862] }, { 2: e, 3: 863, 4: t, 5: s }, { 2: e, 3: 864, 4: t, 5: s }, D(V1, c2, { 354: 865, 156: h2 }), D(V1, c2, { 354: 866, 156: h2 }), D(T2, [2, 496]), D(T2, [2, 497]), { 183: [1, 867] }, { 183: [2, 1147] }, D(wt, [2, 1142], { 470: 868, 473: 869, 137: [1, 870] }), D(b2, [2, 1141]), D($t, xt, { 514: 871, 95: kt, 230: [1, 872], 518: Lt, 519: Dt, 520: Mt }), { 76: [1, 877] }, { 76: [1, 878] }, { 145: O1, 454: 879 }, { 4: Ut, 7: 883, 76: [1, 881], 276: 880, 391: 882, 393: Ft }, D(r, [2, 461], { 128: [1, 886] }), D(r, [2, 584]), { 2: e, 3: 887, 4: t, 5: s }, { 302: [1, 888] }, D(St, g2, { 402: 889, 156: m2 }), D(r, [2, 598]), { 2: e, 3: 246, 4: t, 5: s, 199: 891, 403: 890 }, { 2: e, 3: 246, 4: t, 5: s, 199: 891, 403: 892 }, D(r, [2, 777]), D(y1, [2, 674], { 442: 893, 314: [1, 894] }), { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 895, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 896, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 897, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 898, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 899, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 900, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 901, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 902, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 903, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 904, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 905, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 906, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 907, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 908, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 909, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 910, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 911, 4: t, 5: s, 77: [1, 913], 131: h, 156: a, 196: 912, 200: 914, 293: i, 294: o, 295: u, 296: l, 297: c }, { 2: e, 3: 915, 4: t, 5: s, 77: [1, 917], 131: h, 156: a, 196: 916, 200: 918, 293: i, 294: o, 295: u, 296: l, 297: c }, D(_t, [2, 445], { 259: 147, 200: 148, 260: 149, 111: 150, 258: 151, 196: 152, 261: 153, 113: 154, 262: 155, 201: 156, 202: 157, 263: 158, 264: 159, 265: 160, 144: 162, 266: 163, 267: 164, 56: 166, 158: 168, 3: 169, 423: 191, 94: 919, 2: e, 4: t, 5: s, 77: C1, 131: h, 132: d, 137: R1, 143: f, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 179: x1, 180: k1, 181: b, 244: E, 245: g, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 424: $, 428: x }), D(_t, [2, 446], { 259: 147, 200: 148, 260: 149, 111: 150, 258: 151, 196: 152, 261: 153, 113: 154, 262: 155, 201: 156, 202: 157, 263: 158, 264: 159, 265: 160, 144: 162, 266: 163, 267: 164, 56: 166, 158: 168, 3: 169, 423: 191, 94: 920, 2: e, 4: t, 5: s, 77: C1, 131: h, 132: d, 137: R1, 143: f, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 179: x1, 180: k1, 181: b, 244: E, 245: g, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 424: $, 428: x }), D(_t, [2, 447], { 259: 147, 200: 148, 260: 149, 111: 150, 258: 151, 196: 152, 261: 153, 113: 154, 262: 155, 201: 156, 202: 157, 263: 158, 264: 159, 265: 160, 144: 162, 266: 163, 267: 164, 56: 166, 158: 168, 3: 169, 423: 191, 94: 921, 2: e, 4: t, 5: s, 77: C1, 131: h, 132: d, 137: R1, 143: f, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 179: x1, 180: k1, 181: b, 244: E, 245: g, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 424: $, 428: x }), D(_t, [2, 448], { 259: 147, 200: 148, 260: 149, 111: 150, 258: 151, 196: 152, 261: 153, 113: 154, 262: 155, 201: 156, 202: 157, 263: 158, 264: 159, 265: 160, 144: 162, 266: 163, 267: 164, 56: 166, 158: 168, 3: 169, 423: 191, 94: 922, 2: e, 4: t, 5: s, 77: C1, 131: h, 132: d, 137: R1, 143: f, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 179: x1, 180: k1, 181: b, 244: E, 245: g, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 424: $, 428: x }), D(_t, Pt, { 259: 147, 200: 148, 260: 149, 111: 150, 258: 151, 196: 152, 261: 153, 113: 154, 262: 155, 201: 156, 202: 157, 263: 158, 264: 159, 265: 160, 144: 162, 266: 163, 267: 164, 56: 166, 158: 168, 3: 169, 423: 191, 94: 923, 2: e, 4: t, 5: s, 77: C1, 131: h, 132: d, 137: R1, 143: f, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 179: x1, 180: k1, 181: b, 244: E, 245: g, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 424: $, 428: x }), { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 924, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 925, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, D(_t, [2, 450], { 259: 147, 200: 148, 260: 149, 111: 150, 258: 151, 196: 152, 261: 153, 113: 154, 262: 155, 201: 156, 202: 157, 263: 158, 264: 159, 265: 160, 144: 162, 266: 163, 267: 164, 56: 166, 158: 168, 3: 169, 423: 191, 94: 926, 2: e, 4: t, 5: s, 77: C1, 131: h, 132: d, 137: R1, 143: f, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 179: x1, 180: k1, 181: b, 244: E, 245: g, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 424: $, 428: x }), { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 927, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 928, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 164: [1, 930], 166: [1, 932], 332: 929, 338: [1, 931] }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 933, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 934, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 698, 4: t, 5: s, 77: [1, 935], 111: 938, 145: qt, 156: a, 200: 939, 202: 937, 293: i, 294: o, 295: u, 296: l, 297: c, 333: 936 }, { 99: [1, 941], 301: [1, 942] }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 943, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 944, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 945, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 4: Ut, 7: 883, 276: 946, 391: 882, 393: Ft }, D(Gt, [2, 88]), D(Gt, [2, 89]), { 78: [1, 947] }, { 78: [1, 948] }, { 78: [1, 949] }, { 78: [1, 950], 99: S2, 112: A2, 114: 628, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 331: 640, 334: Z2, 335: ee, 336: te, 337: se }, D(V1, B1, { 344: 209, 77: l2, 198: H1 }), { 78: [2, 1112] }, { 78: [2, 1113] }, { 134: v1, 135: N1 }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 262, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 151: 951, 152: p, 154: $1, 156: a, 158: 168, 164: [1, 953], 179: x1, 180: k1, 181: b, 185: [1, 952], 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 954, 4: t, 5: s, 149: jt, 180: [1, 956] }, D([2, 4, 5, 10, 53, 72, 74, 76, 77, 78, 89, 93, 95, 98, 99, 107, 118, 122, 128, 129, 130, 131, 132, 134, 135, 137, 143, 145, 146, 148, 149, 150, 152, 154, 156, 162, 164, 166, 168, 169, 170, 171, 172, 173, 175, 181, 183, 185, 187, 189, 198, 206, 208, 222, 223, 224, 225, 226, 227, 228, 229, 232, 239, 244, 245, 246, 247, 249, 251, 270, 271, 284, 285, 286, 287, 288, 289, 290, 291, 293, 300, 304, 310, 312, 313, 314, 318, 334, 335, 337, 339, 342, 343, 400, 404, 405, 408, 410, 412, 413, 421, 422, 424, 428, 438, 440, 441, 443, 444, 445, 446, 447, 451, 452, 455, 456, 468, 474, 509, 511, 512, 521, 606, 767], [2, 421], { 114: 628, 331: 640, 112: A2, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 336: te }), D(Vt, [2, 422], { 114: 628, 331: 640, 115: y2, 116: v2, 123: N2, 133: C2, 136: R2, 138: I2, 180: F2, 316: P2, 320: j2 }), D(Vt, [2, 423], { 114: 628, 331: 640, 115: y2, 116: v2, 123: N2, 133: C2, 136: R2, 138: I2, 180: F2, 316: P2, 320: j2 }), D(Bt, [2, 424], { 114: 628, 331: 640, 320: j2 }), D(Bt, [2, 425], { 114: 628, 331: 640, 320: j2 }), D(re, [2, 370]), D(re, [2, 1118]), D(re, [2, 1119]), D(re, [2, 371]), D([2, 4, 5, 10, 53, 72, 74, 76, 77, 78, 89, 93, 95, 98, 99, 107, 112, 115, 116, 118, 122, 123, 124, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 145, 146, 148, 149, 150, 152, 154, 156, 162, 164, 166, 168, 169, 170, 171, 172, 173, 175, 179, 180, 181, 183, 185, 187, 189, 198, 206, 208, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 239, 244, 245, 246, 247, 249, 251, 270, 271, 284, 285, 286, 287, 288, 289, 290, 291, 293, 300, 304, 310, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 334, 335, 336, 337, 339, 342, 343, 400, 404, 405, 408, 410, 412, 413, 421, 422, 424, 428, 438, 440, 441, 443, 444, 445, 446, 447, 451, 452, 455, 456, 468, 474, 509, 511, 512, 521, 606, 767], [2, 367]), { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 957, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, D(ue, [2, 625]), D(ue, [2, 626]), D(ue, [2, 627]), D(ue, [2, 628]), D(ue, [2, 630]), { 40: 958, 79: 75, 89: G, 184: 99, 189: H }, { 99: S2, 112: A2, 114: 628, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 308: 959, 311: 680, 312: oe, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 331: 640, 334: Z2, 335: ee, 336: te, 337: se }, { 309: 960, 310: Ht, 311: 961, 312: oe, 314: Jt }, D(Yt, [2, 377]), { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 963, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 964, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 4: Ut, 7: 883, 276: 965, 391: 882, 393: Ft }, D(ue, [2, 631]), { 74: [1, 967], 304: [1, 966] }, D(ue, [2, 647]), D(Wt, [2, 654]), D(Xt, [2, 632]), D(Xt, [2, 633]), D(Xt, [2, 634]), D(Xt, [2, 635]), D(Xt, [2, 636]), D(Xt, [2, 637]), D(Xt, [2, 638]), D(Xt, [2, 639]), D(Xt, [2, 640]), { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 968, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, D([2, 4, 5, 10, 53, 72, 74, 76, 78, 89, 93, 95, 98, 99, 107, 112, 115, 118, 122, 123, 124, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 145, 146, 148, 149, 150, 152, 154, 156, 162, 164, 166, 168, 169, 170, 171, 172, 173, 175, 179, 180, 181, 183, 185, 187, 189, 198, 206, 208, 222, 223, 224, 225, 226, 227, 228, 229, 232, 239, 244, 245, 246, 247, 249, 251, 270, 271, 284, 285, 286, 287, 288, 289, 290, 291, 293, 300, 304, 310, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 334, 335, 336, 337, 339, 342, 343, 400, 404, 405, 408, 410, 412, 413, 421, 422, 424, 428, 430, 438, 440, 441, 443, 444, 445, 446, 447, 451, 452, 455, 456, 468, 474, 509, 511, 512, 521, 606, 767], ne, { 77: u2, 116: Kt }), { 74: ct, 304: [1, 970] }, D(Qt, [2, 317], { 77: u2 }), D(Q1, [2, 318]), { 74: [1, 972], 430: [1, 971] }, D(ue, [2, 644]), D(zt, [2, 649]), { 152: [1, 973] }, { 152: [1, 974] }, { 152: [1, 975] }, { 40: 980, 77: [1, 979], 79: 75, 89: G, 143: f, 144: 983, 145: z1, 149: Zt, 152: p, 181: b, 184: 99, 189: H, 201: 984, 306: w, 345: 976, 346: 977, 347: [1, 978], 348: e3, 423: 191, 424: $, 428: x }, D(V1, B1, { 344: 985, 198: H1 }), { 77: t3, 143: f, 144: 983, 145: z1, 149: Zt, 152: p, 181: b, 201: 984, 306: w, 345: 986, 346: 987, 348: e3, 423: 191, 424: $, 428: x }, { 230: [1, 990], 459: 989 }, { 2: e, 3: 221, 4: t, 5: s, 77: J1, 132: Y1, 143: f, 144: 214, 145: I1, 152: p, 156: a, 181: b, 199: 215, 200: 217, 201: 216, 202: 219, 209: 991, 213: W1, 214: 220, 293: i, 294: o, 295: u, 296: l, 297: c, 306: w, 423: 191, 424: $, 428: x }, { 231: [2, 701] }, { 78: [1, 992] }, D(fe, [2, 1098], { 211: 993, 3: 994, 2: e, 4: t, 5: s }), D(de, [2, 1097]), D(fe, [2, 183]), { 2: e, 3: 995, 4: t, 5: s }, { 212: [1, 996] }, D(fe, [2, 187]), { 2: e, 3: 997, 4: t, 5: s }, D(fe, [2, 191]), { 2: e, 3: 998, 4: t, 5: s }, D(fe, [2, 195]), { 2: e, 3: 999, 4: t, 5: s }, D(fe, [2, 198]), { 2: e, 3: 1e3, 4: t, 5: s }, { 2: e, 3: 1001, 4: t, 5: s }, { 148: [1, 1002] }, D(s3, [2, 172], { 82: 1003, 183: [1, 1004] }), { 2: e, 3: 221, 4: t, 5: s, 132: [1, 1009], 143: f, 145: [1, 1010], 152: p, 156: a, 181: b, 199: 1005, 200: 1006, 201: 1007, 202: 1008, 293: i, 294: o, 295: u, 296: l, 297: c, 306: w }, { 2: e, 3: 1015, 4: t, 5: s, 109: 1011, 110: 1012, 111: 1013, 112: n3 }, D(ge, [2, 1063]), D(r3, [2, 1054], { 91: 1016, 182: 1017, 183: [1, 1018] }), D(K1, [2, 1053], { 153: 1019, 179: a3, 180: i3, 181: o3 }), D([2, 4, 5, 10, 72, 74, 76, 78, 112, 115, 116, 118, 122, 123, 124, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 145, 146, 148, 149, 150, 152, 154, 156, 162, 164, 166, 168, 169, 170, 171, 172, 173, 175, 179, 180, 181, 183, 185, 187, 198, 244, 245, 284, 285, 286, 287, 288, 289, 290, 291, 310, 314, 424, 428, 606, 767], [2, 90], { 77: [1, 1023] }), { 119: [1, 1024] }, D(u3, [2, 93]), { 2: e, 3: 1025, 4: t, 5: s }, D(u3, [2, 95]), { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1026, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1027, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 736, 4: t, 5: s, 72: me, 76: Te, 77: Se, 112: Ae, 114: 739, 115: y2, 116: v2, 117: 1029, 118: ye, 122: ve, 123: Ne, 124: Oe, 125: 1028, 128: Ce, 129: Re, 130: Ie, 131: we, 132: $e, 133: xe, 134: ke, 135: Le, 136: De, 137: Me, 138: Ue, 139: Fe, 140: _e, 141: Pe, 142: qe, 143: Ge, 144: 761, 145: je, 146: Ve, 148: Be, 149: He, 150: Je, 152: Ye, 154: We, 156: Xe, 158: 771, 160: 772, 162: Ke, 164: Qe, 166: ze, 168: Ze, 169: et, 170: tt, 171: st, 172: nt, 173: rt, 175: at, 185: it, 187: ot, 244: E, 245: g, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 423: 191, 424: $, 428: x }, { 77: [1, 1030] }, { 77: [1, 1031] }, { 77: [1, 1032] }, { 77: [1, 1033] }, D(u3, [2, 104]), D(u3, [2, 105]), D(u3, [2, 106]), D(u3, [2, 107]), D(u3, [2, 108]), D(u3, [2, 109]), { 2: e, 3: 1034, 4: t, 5: s }, { 2: e, 3: 1035, 4: t, 5: s, 133: [1, 1036] }, D(u3, [2, 113]), D(u3, [2, 114]), D(u3, [2, 115]), D(u3, [2, 116]), D(u3, [2, 117]), D(u3, [2, 118]), { 2: e, 3: 1037, 4: t, 5: s, 77: ie, 113: 672, 131: h, 132: d, 143: f, 152: p, 181: b, 196: 673, 201: 675, 261: 674, 298: C, 299: R, 300: I, 306: w, 423: 676, 428: x }, { 145: [1, 1038] }, { 77: [1, 1039] }, { 145: [1, 1040] }, D(u3, [2, 123]), { 77: [1, 1041] }, { 2: e, 3: 1042, 4: t, 5: s }, { 77: [1, 1043] }, { 77: [1, 1044] }, { 77: [1, 1045] }, { 77: [1, 1046] }, { 77: [1, 1047], 164: [1, 1048] }, { 77: [1, 1049] }, { 77: [1, 1050] }, { 77: [1, 1051] }, { 77: [1, 1052] }, { 77: [1, 1053] }, { 77: [1, 1054] }, { 77: [1, 1055] }, { 77: [1, 1056] }, { 77: [1, 1057] }, { 77: [2, 1078] }, { 77: [2, 1079] }, { 2: e, 3: 246, 4: t, 5: s, 199: 1058 }, { 2: e, 3: 246, 4: t, 5: s, 199: 1059 }, { 113: 1060, 132: d, 300: I }, D(r, [2, 601], { 112: [1, 1061] }), { 2: e, 3: 246, 4: t, 5: s, 199: 1062 }, { 113: 1063, 132: d, 300: I }, { 2: e, 3: 1064, 4: t, 5: s }, D(r, [2, 698]), D(r, [2, 68]), { 2: e, 3: 238, 4: t, 5: s, 75: 1065 }, { 77: [1, 1066] }, D(r, [2, 679]), D(r, [2, 591]), { 2: e, 3: 1015, 4: t, 5: s, 111: 1069, 143: l3, 145: c3, 147: 1067, 340: 1068, 341: 1070 }, { 144: 1073, 145: z1, 423: 191, 424: $, 428: x }, D(r, [2, 676]), { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1074, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, D(_t, Pt, { 259: 147, 200: 148, 260: 149, 111: 150, 258: 151, 196: 152, 261: 153, 113: 154, 262: 155, 201: 156, 202: 157, 263: 158, 264: 159, 265: 160, 144: 162, 266: 163, 267: 164, 56: 166, 158: 168, 3: 169, 423: 191, 94: 1075, 2: e, 4: t, 5: s, 77: C1, 131: h, 132: d, 137: R1, 143: f, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 179: x1, 180: k1, 181: b, 244: E, 245: g, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 424: $, 428: x }), { 113: 1076, 132: d, 300: I }, { 2: e, 3: 268, 4: t, 5: s, 450: 1077, 451: e2 }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1079, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 230: ft, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x, 433: 1078, 437: pt }, D(r, [2, 656]), { 114: 1081, 115: y2, 116: v2, 124: [1, 1080] }, D(r, [2, 668]), D(r, [2, 669]), { 2: e, 3: 1083, 4: t, 5: s, 77: h3, 131: d3, 436: 1082 }, { 114: 810, 115: y2, 116: v2, 124: [1, 1086], 434: 1087 }, D(r, [2, 758], { 74: bt }), { 2: e, 3: 100, 4: t, 5: s, 508: 1088 }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 820, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 174: 1089, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 257: 819, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 820, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 174: 1090, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 257: 819, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 820, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 174: 1091, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 257: 819, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, D(mt, [2, 151]), D(mt, [2, 1093], { 74: f3 }), D(p3, [2, 276]), D(p3, [2, 283], { 114: 628, 331: 640, 3: 1094, 113: 1096, 2: e, 4: t, 5: s, 76: [1, 1093], 99: S2, 112: A2, 115: y2, 116: v2, 123: N2, 124: dt, 131: [1, 1095], 132: d, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 300: I, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 334: Z2, 335: ee, 336: te, 337: se }), D(n2, [2, 1094], { 197: 1097, 768: [1, 1098] }), { 131: h, 196: 1099 }, { 74: bt, 78: [1, 1100] }, D(y1, [2, 11]), { 148: [1, 1101], 190: [1, 1102] }, { 190: [1, 1103] }, { 190: [1, 1104] }, { 190: [1, 1105] }, D(r, [2, 580], { 76: [1, 1107], 77: [1, 1106] }), { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 262, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 151: 1108, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, D(re, [2, 350]), D(gt, [2, 1117]), D(gt, [2, 1114]), D(gt, [2, 1115]), { 74: ct, 78: [1, 1109] }, { 74: ct, 78: [1, 1110] }, { 74: [1, 1111] }, { 74: [1, 1112] }, { 74: [1, 1113] }, { 74: [1, 1114] }, { 74: [1, 1115], 99: S2, 112: A2, 114: 628, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 331: 640, 334: Z2, 335: ee, 336: te, 337: se }, D(re, [2, 358]), D(r, [2, 585]), { 302: [1, 1116] }, { 2: e, 3: 1117, 4: t, 5: s, 113: 1118, 132: d, 300: I }, { 2: e, 3: 246, 4: t, 5: s, 199: 1119 }, { 230: [1, 1120] }, { 2: e, 3: 581, 4: t, 5: s, 132: d2, 137: f2, 143: t2, 145: s2, 152: p2, 435: 588, 478: 1121, 479: 579, 482: 580, 486: 585, 497: 582, 501: 584 }, D(r, [2, 735], { 114: 628, 331: 640, 99: S2, 112: A2, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 334: Z2, 335: ee, 336: te, 337: se }), D(Et, [2, 1150], { 481: 1122, 487: 1123, 76: b3 }), D(yt, [2, 1149]), { 2: e, 3: 1127, 4: t, 5: s, 132: d2, 137: f2, 144: 1126, 145: z1, 152: p2, 423: 191, 424: $, 428: x, 479: 1125, 497: 582, 501: 584 }, { 2: e, 3: 1127, 4: t, 5: s, 132: d2, 137: f2, 143: t2, 145: s2, 152: p2, 435: 588, 479: 1129, 482: 1128, 486: 585, 497: 582, 501: 584 }, { 2: e, 3: 581, 4: t, 5: s, 132: d2, 137: f2, 143: t2, 145: s2, 152: p2, 435: 588, 477: 1130, 478: 578, 479: 579, 482: 580, 486: 585, 497: 582, 501: 584 }, D(Ct, [2, 1168], { 495: 1131, 132: [1, 1132] }), D(Nt, [2, 1167]), D(Rt, [2, 1174], { 499: 1133, 501: 1134, 152: p2 }), D(Ct, [2, 1173]), D(Rt, [2, 751]), D(Rt, [2, 1177]), D(Nt, [2, 754]), D(Nt, [2, 755]), D(Rt, [2, 753]), D(It, [2, 745]), { 2: e, 3: 246, 4: t, 5: s, 199: 1135 }, { 2: e, 3: 246, 4: t, 5: s, 199: 1136 }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1137, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, D(E3, [2, 1144], { 471: 1138, 113: 1139, 132: d, 300: I }), D(wt, [2, 1143]), { 2: e, 3: 1140, 4: t, 5: s }, { 339: g3, 342: m3, 343: T3, 515: 1141 }, { 2: e, 3: 246, 4: t, 5: s, 199: 1145 }, D($t, [2, 770]), D($t, [2, 771]), D($t, [2, 772]), { 129: [1, 1146] }, { 270: [1, 1147] }, { 270: [1, 1148] }, D(E2, [2, 693]), D(E2, [2, 694], { 124: [1, 1149] }), { 4: Ut, 7: 883, 276: 1150, 391: 882, 393: Ft }, D([2, 4, 10, 53, 72, 74, 76, 77, 78, 89, 93, 95, 98, 99, 107, 112, 115, 116, 118, 122, 123, 124, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 145, 146, 148, 149, 150, 152, 154, 156, 162, 164, 166, 168, 169, 170, 171, 172, 173, 175, 179, 180, 181, 183, 185, 187, 189, 198, 206, 208, 222, 223, 224, 225, 226, 227, 228, 229, 230, 232, 239, 244, 245, 246, 247, 249, 251, 270, 271, 284, 285, 286, 287, 288, 289, 290, 291, 293, 300, 301, 304, 310, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 334, 335, 336, 337, 339, 342, 343, 347, 360, 372, 373, 377, 378, 400, 404, 405, 408, 410, 412, 413, 421, 422, 424, 428, 438, 440, 441, 443, 444, 445, 446, 447, 451, 452, 455, 456, 468, 474, 509, 511, 512, 521, 606, 767], [2, 547], { 5: [1, 1151] }), D([2, 5, 10, 53, 72, 74, 76, 78, 89, 93, 95, 98, 99, 107, 112, 115, 116, 118, 122, 123, 124, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 145, 146, 148, 149, 150, 152, 154, 156, 162, 164, 166, 168, 169, 170, 171, 172, 173, 175, 179, 180, 181, 183, 185, 187, 189, 198, 206, 208, 222, 223, 224, 225, 226, 227, 228, 229, 230, 232, 239, 244, 245, 246, 247, 249, 251, 270, 271, 284, 285, 286, 287, 288, 289, 290, 291, 293, 300, 301, 304, 310, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 334, 335, 336, 337, 339, 342, 343, 347, 360, 372, 373, 377, 378, 400, 404, 405, 408, 410, 412, 413, 421, 422, 424, 428, 438, 440, 441, 443, 444, 445, 446, 447, 451, 452, 455, 456, 468, 474, 509, 511, 512, 521, 606, 767], [2, 544], { 4: [1, 1153], 77: [1, 1152] }), { 77: [1, 1154] }, D(S3, [2, 4]), { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1155, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, D(r, [2, 593]), D(St, [2, 573]), { 2: e, 3: 1156, 4: t, 5: s, 113: 1157, 132: d, 300: I }, D(r, [2, 569], { 74: A3 }), D(E2, [2, 571]), D(r, [2, 618], { 74: A3 }), D(r, [2, 673]), D(r, F, { 17: 5, 18: 7, 19: 8, 20: 9, 21: 10, 22: 11, 23: 12, 24: 13, 25: 14, 26: 15, 27: 16, 28: 17, 29: 18, 30: 19, 31: 20, 32: 21, 33: 22, 34: 23, 35: 24, 36: 25, 37: 26, 38: 27, 39: 28, 40: 29, 41: 30, 42: 31, 43: 32, 44: 33, 45: 34, 46: 35, 47: 36, 48: 37, 49: 38, 50: 39, 51: 40, 52: 41, 54: 43, 55: 44, 56: 45, 57: 46, 58: 47, 59: 48, 60: 49, 61: 50, 62: 51, 63: 52, 64: 53, 65: 54, 66: 55, 67: 56, 68: 57, 69: 58, 70: 59, 71: 60, 79: 75, 508: 95, 184: 99, 3: 100, 12: 1159, 2: e, 4: t, 5: s, 53: P, 72: q, 89: G, 124: j, 146: V, 156: B, 189: H, 270: n, 271: J, 293: Y, 339: W, 342: X, 343: K, 400: Q, 404: z, 405: Z, 408: e1, 410: t1, 412: s1, 413: n1, 421: r1, 422: a1, 438: i1, 440: o1, 441: u1, 443: l1, 444: c1, 445: h1, 446: d1, 447: f1, 451: p1, 452: b1, 455: E1, 456: g1, 509: m1, 511: T1, 512: S1, 521: A1 }), D(y3, [2, 381], { 114: 628, 331: 640, 115: y2, 116: v2, 123: N2, 133: C2, 136: R2, 138: I2, 141: x2, 142: k2, 179: U2, 180: F2, 316: P2, 320: j2, 321: V2, 322: B2, 323: H2 }), D(Bt, [2, 382], { 114: 628, 331: 640, 320: j2 }), D(y3, [2, 383], { 114: 628, 331: 640, 115: y2, 116: v2, 123: N2, 133: C2, 136: R2, 138: I2, 141: x2, 142: k2, 179: U2, 180: F2, 316: P2, 320: j2, 321: V2, 322: B2, 323: H2 }), D(v3, [2, 384], { 114: 628, 331: 640, 115: y2, 116: v2, 123: N2, 133: C2, 136: R2, 138: I2, 141: x2, 142: k2, 179: U2, 180: F2, 316: P2, 318: [1, 1160], 320: j2, 321: V2, 322: B2, 323: H2 }), D(v3, [2, 386], { 114: 628, 331: 640, 115: y2, 116: v2, 123: N2, 133: C2, 136: R2, 138: I2, 141: x2, 142: k2, 179: U2, 180: F2, 316: P2, 318: [1, 1161], 320: j2, 321: V2, 322: B2, 323: H2 }), D(Q1, [2, 388], { 114: 628, 331: 640 }), D(Vt, [2, 389], { 114: 628, 331: 640, 115: y2, 116: v2, 123: N2, 133: C2, 136: R2, 138: I2, 180: F2, 316: P2, 320: j2 }), D(Vt, [2, 390], { 114: 628, 331: 640, 115: y2, 116: v2, 123: N2, 133: C2, 136: R2, 138: I2, 180: F2, 316: P2, 320: j2 }), D(N3, [2, 391], { 114: 628, 331: 640, 115: y2, 116: v2, 123: N2, 136: R2, 316: P2, 320: j2 }), D(N3, [2, 392], { 114: 628, 331: 640, 115: y2, 116: v2, 123: N2, 136: R2, 316: P2, 320: j2 }), D(N3, [2, 393], { 114: 628, 331: 640, 115: y2, 116: v2, 123: N2, 136: R2, 316: P2, 320: j2 }), D([2, 4, 5, 10, 53, 72, 74, 76, 77, 78, 89, 93, 95, 98, 99, 107, 112, 118, 122, 123, 124, 128, 129, 130, 131, 132, 133, 134, 135, 137, 138, 139, 140, 141, 142, 143, 145, 146, 148, 149, 150, 152, 154, 156, 162, 164, 166, 168, 169, 170, 171, 172, 173, 175, 179, 180, 181, 183, 185, 187, 189, 198, 206, 208, 222, 223, 224, 225, 226, 227, 228, 229, 232, 239, 244, 245, 246, 247, 249, 251, 270, 271, 284, 285, 286, 287, 288, 289, 290, 291, 293, 300, 304, 310, 312, 313, 314, 315, 317, 318, 319, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 334, 335, 336, 337, 339, 342, 343, 400, 404, 405, 408, 410, 412, 413, 421, 422, 424, 428, 438, 440, 441, 443, 444, 445, 446, 447, 451, 452, 455, 456, 468, 474, 509, 511, 512, 521, 606, 767], [2, 394], { 114: 628, 331: 640, 115: y2, 116: v2, 136: R2, 316: P2, 320: j2 }), D(O3, [2, 395], { 114: 628, 331: 640, 115: y2, 116: v2, 123: N2, 133: C2, 136: R2, 138: I2, 179: U2, 180: F2, 316: P2, 320: j2, 321: V2 }), D(O3, [2, 396], { 114: 628, 331: 640, 115: y2, 116: v2, 123: N2, 133: C2, 136: R2, 138: I2, 179: U2, 180: F2, 316: P2, 320: j2, 321: V2 }), D(O3, [2, 397], { 114: 628, 331: 640, 115: y2, 116: v2, 123: N2, 133: C2, 136: R2, 138: I2, 179: U2, 180: F2, 316: P2, 320: j2, 321: V2 }), D(O3, [2, 398], { 114: 628, 331: 640, 115: y2, 116: v2, 123: N2, 133: C2, 136: R2, 138: I2, 179: U2, 180: F2, 316: P2, 320: j2, 321: V2 }), D(Qt, [2, 399], { 77: u2 }), D(Q1, [2, 400]), { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1162, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, D(Q1, [2, 402]), D(Qt, [2, 403], { 77: u2 }), D(Q1, [2, 404]), { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1163, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, D(Q1, [2, 406]), D(C3, [2, 407], { 114: 628, 331: 640, 112: A2, 115: y2, 116: v2, 123: N2, 133: C2, 136: R2, 138: I2, 141: x2, 142: k2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 336: te }), D(C3, [2, 408], { 114: 628, 331: 640, 112: A2, 115: y2, 116: v2, 123: N2, 133: C2, 136: R2, 138: I2, 141: x2, 142: k2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 336: te }), D(C3, [2, 409], { 114: 628, 331: 640, 112: A2, 115: y2, 116: v2, 123: N2, 133: C2, 136: R2, 138: I2, 141: x2, 142: k2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 336: te }), D(C3, [2, 410], { 114: 628, 331: 640, 112: A2, 115: y2, 116: v2, 123: N2, 133: C2, 136: R2, 138: I2, 141: x2, 142: k2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 336: te }), D([2, 4, 5, 10, 53, 72, 89, 99, 124, 139, 140, 146, 154, 156, 170, 171, 189, 270, 271, 293, 310, 314, 324, 325, 326, 327, 328, 329, 330, 334, 335, 337, 339, 342, 343, 400, 404, 405, 408, 410, 412, 413, 421, 422, 438, 440, 441, 443, 444, 445, 446, 447, 451, 452, 455, 456, 509, 511, 512, 521, 606, 767], R3, { 114: 628, 331: 640, 112: A2, 115: y2, 116: v2, 123: N2, 133: C2, 136: R2, 138: I2, 141: x2, 142: k2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 336: te }), D(C3, [2, 412], { 114: 628, 331: 640, 112: A2, 115: y2, 116: v2, 123: N2, 133: C2, 136: R2, 138: I2, 141: x2, 142: k2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 336: te }), D(C3, [2, 413], { 114: 628, 331: 640, 112: A2, 115: y2, 116: v2, 123: N2, 133: C2, 136: R2, 138: I2, 141: x2, 142: k2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 336: te }), D(C3, [2, 414], { 114: 628, 331: 640, 112: A2, 115: y2, 116: v2, 123: N2, 133: C2, 136: R2, 138: I2, 141: x2, 142: k2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 336: te }), D(C3, [2, 415], { 114: 628, 331: 640, 112: A2, 115: y2, 116: v2, 123: N2, 133: C2, 136: R2, 138: I2, 141: x2, 142: k2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 336: te }), D(C3, [2, 416], { 114: 628, 331: 640, 112: A2, 115: y2, 116: v2, 123: N2, 133: C2, 136: R2, 138: I2, 141: x2, 142: k2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 336: te }), { 77: [1, 1164] }, { 77: [2, 451] }, { 77: [2, 452] }, { 77: [2, 453] }, D(I3, [2, 419], { 114: 628, 331: 640, 99: S2, 112: A2, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 336: te }), D([2, 4, 5, 10, 53, 72, 74, 76, 77, 78, 89, 93, 95, 98, 107, 118, 122, 128, 129, 130, 131, 132, 134, 135, 137, 143, 145, 146, 148, 149, 150, 152, 156, 162, 164, 166, 168, 169, 171, 172, 173, 175, 181, 183, 185, 187, 189, 198, 206, 208, 222, 223, 224, 225, 226, 227, 228, 229, 232, 239, 244, 245, 246, 247, 249, 251, 270, 271, 284, 285, 286, 287, 288, 289, 290, 291, 293, 300, 304, 310, 312, 313, 314, 318, 337, 339, 342, 343, 400, 404, 405, 408, 410, 412, 413, 421, 422, 424, 428, 438, 440, 441, 443, 444, 445, 446, 447, 451, 452, 455, 456, 468, 474, 509, 511, 512, 521, 606, 767], [2, 420], { 114: 628, 331: 640, 99: S2, 112: A2, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 334: Z2, 335: ee, 336: te }), { 2: e, 3: 169, 4: t, 5: s, 40: 1165, 56: 166, 77: C1, 78: [1, 1167], 79: 75, 89: G, 94: 262, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 151: 1166, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 184: 99, 189: H, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, D(Q1, [2, 433]), D(Q1, [2, 435]), D(Q1, [2, 442]), D(Q1, [2, 443]), { 2: e, 3: 670, 4: t, 5: s, 77: [1, 1168] }, { 2: e, 3: 698, 4: t, 5: s, 77: [1, 1169], 111: 938, 145: qt, 156: a, 200: 939, 202: 1171, 293: i, 294: o, 295: u, 296: l, 297: c, 333: 1170 }, D(Q1, [2, 440]), D(I3, [2, 437], { 114: 628, 331: 640, 99: S2, 112: A2, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 336: te }), D(I3, [2, 438], { 114: 628, 331: 640, 99: S2, 112: A2, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 336: te }), D([2, 4, 5, 10, 53, 72, 74, 76, 77, 78, 89, 93, 95, 98, 99, 107, 118, 122, 124, 128, 129, 130, 131, 132, 134, 135, 137, 139, 140, 143, 145, 146, 148, 149, 150, 152, 154, 156, 162, 164, 166, 168, 169, 170, 171, 172, 173, 175, 181, 183, 185, 187, 189, 198, 206, 208, 222, 223, 224, 225, 226, 227, 228, 229, 232, 239, 244, 245, 246, 247, 249, 251, 270, 271, 284, 285, 286, 287, 288, 289, 290, 291, 293, 300, 304, 310, 312, 313, 314, 318, 324, 325, 326, 327, 328, 329, 330, 334, 335, 336, 337, 339, 342, 343, 400, 404, 405, 408, 410, 412, 413, 421, 422, 424, 428, 438, 440, 441, 443, 444, 445, 446, 447, 451, 452, 455, 456, 468, 474, 509, 511, 512, 521, 606, 767], [2, 439], { 114: 628, 331: 640, 112: A2, 115: y2, 116: v2, 123: N2, 133: C2, 136: R2, 138: I2, 141: x2, 142: k2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2 }), D(Q1, [2, 441]), D(Q1, [2, 309]), D(Q1, [2, 310]), D(Q1, [2, 311]), D(Q1, [2, 426]), { 74: ct, 78: [1, 1172] }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1173, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1174, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, D(Q1, w3), D($3, [2, 289]), D(Q1, [2, 285]), { 78: [1, 1176], 99: S2, 112: A2, 114: 628, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 331: 640, 334: Z2, 335: ee, 336: te, 337: se }, { 78: [1, 1177] }, { 309: 1178, 310: Ht, 311: 961, 312: oe, 314: Jt }, { 310: [1, 1179] }, D(Yt, [2, 376]), { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1180, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 99: S2, 112: A2, 114: 628, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 313: [1, 1181], 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 331: 640, 334: Z2, 335: ee, 336: te, 337: se }, { 76: [1, 1182], 99: S2, 112: A2, 114: 628, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 331: 640, 334: Z2, 335: ee, 336: te, 337: se }, { 74: [1, 1183] }, D(ue, [2, 645]), { 2: e, 3: 698, 4: t, 5: s, 77: le, 111: 693, 113: 691, 131: h, 132: d, 143: f, 144: 688, 145: z1, 152: p, 156: a, 181: b, 196: 690, 200: 696, 201: 695, 261: 692, 262: 694, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 304: [1, 1184], 306: w, 423: 191, 424: $, 426: 1185, 427: 689, 428: x }, { 78: [1, 1186], 99: S2, 112: A2, 114: 628, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 331: 640, 334: Z2, 335: ee, 336: te, 337: se }, { 2: e, 3: 1187, 4: t, 5: s, 149: jt }, D(Q1, [2, 369]), D(ue, [2, 642]), { 2: e, 3: 707, 4: t, 5: s, 131: ce, 132: he, 430: [1, 1188], 432: 1189 }, { 2: e, 3: 698, 4: t, 5: s, 77: le, 111: 693, 113: 691, 131: h, 132: d, 143: f, 144: 688, 145: z1, 152: p, 156: a, 181: b, 196: 690, 200: 696, 201: 695, 261: 692, 262: 694, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 306: w, 423: 191, 424: $, 426: 1190, 427: 689, 428: x }, { 2: e, 3: 698, 4: t, 5: s, 77: le, 111: 693, 113: 691, 131: h, 132: d, 143: f, 144: 688, 145: z1, 152: p, 156: a, 181: b, 196: 690, 200: 696, 201: 695, 261: 692, 262: 694, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 306: w, 423: 191, 424: $, 426: 1191, 427: 689, 428: x }, { 2: e, 3: 698, 4: t, 5: s, 77: le, 111: 693, 113: 691, 131: h, 132: d, 143: f, 144: 688, 145: z1, 152: p, 156: a, 181: b, 196: 690, 200: 696, 201: 695, 261: 692, 262: 694, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 306: w, 423: 191, 424: $, 426: 1192, 427: 689, 428: x }, { 77: t3, 143: f, 144: 983, 145: z1, 152: p, 181: b, 201: 984, 306: w, 346: 1193, 423: 191, 424: $, 428: x }, D(x3, [2, 463], { 74: k3 }), { 149: Zt, 345: 1195, 348: e3 }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1199, 100: 1196, 111: 1198, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 349: 1197, 423: 191, 424: $, 428: x }, D(x3, [2, 471]), D(L3, [2, 474]), D(L3, [2, 475]), D(D3, [2, 479]), D(D3, [2, 480]), { 2: e, 3: 246, 4: t, 5: s, 199: 1200 }, { 77: t3, 143: f, 144: 983, 145: z1, 152: p, 181: b, 201: 984, 306: w, 346: 1201, 423: 191, 424: $, 428: x }, D(x3, [2, 467], { 74: k3 }), { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1199, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 349: 1197, 423: 191, 424: $, 428: x }, { 312: M3, 460: 1202, 462: 1203, 463: 1204 }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1206, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 230: [2, 702] }, D(fe, [2, 181], { 3: 1207, 2: e, 4: t, 5: s, 76: [1, 1208] }), D(fe, [2, 182]), D(fe, [2, 1099]), D(fe, [2, 184]), D(fe, [2, 186]), D(fe, [2, 188]), D(fe, [2, 192]), D(fe, [2, 196]), D(fe, [2, 199]), D([2, 4, 5, 10, 53, 72, 74, 76, 77, 78, 89, 93, 95, 98, 118, 124, 128, 143, 145, 146, 148, 149, 152, 154, 156, 162, 168, 169, 181, 183, 187, 189, 206, 208, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 249, 251, 270, 271, 293, 301, 306, 310, 314, 339, 342, 343, 347, 348, 360, 372, 373, 377, 378, 400, 404, 405, 406, 407, 408, 410, 412, 413, 421, 422, 424, 428, 438, 440, 441, 443, 444, 445, 446, 447, 451, 452, 455, 456, 509, 511, 512, 518, 519, 520, 521, 606, 767], [2, 201]), { 2: e, 3: 1209, 4: t, 5: s }, D(U3, [2, 1050], { 83: 1210, 92: 1211, 93: [1, 1212], 98: [1, 1213] }), { 2: e, 3: 221, 4: t, 5: s, 77: [1, 1215], 132: Y1, 143: f, 144: 214, 145: I1, 152: p, 156: a, 181: b, 199: 215, 200: 217, 201: 216, 202: 219, 203: 1214, 209: 1216, 213: W1, 214: 220, 293: i, 294: o, 295: u, 296: l, 297: c, 306: w, 423: 191, 424: $, 428: x }, D(Ee, [2, 164]), D(Ee, [2, 165]), D(Ee, [2, 166]), D(Ee, [2, 167]), D(Ee, [2, 168]), { 2: e, 3: 670, 4: t, 5: s }, D(X1, [2, 83], { 74: [1, 1217] }), D(F3, [2, 85]), D(F3, [2, 86]), { 113: 1218, 132: d, 300: I }, D([10, 72, 74, 78, 93, 98, 118, 124, 128, 162, 168, 169, 183, 198, 206, 208, 222, 223, 224, 225, 226, 227, 228, 229, 232, 249, 251, 310, 314, 606, 767], ne, { 116: Kt }), D(r3, [2, 73]), D(r3, [2, 1055]), { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1219, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, D(u3, [2, 126]), D(u3, [2, 144]), D(u3, [2, 145]), D(u3, [2, 146]), { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 78: [2, 1070], 94: 262, 111: 150, 113: 154, 127: 1220, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 151: 1221, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 77: [1, 1222] }, D(u3, [2, 94]), D([2, 4, 5, 10, 72, 74, 76, 77, 78, 118, 122, 124, 128, 129, 130, 131, 132, 134, 135, 137, 139, 140, 143, 145, 146, 148, 149, 150, 152, 154, 156, 162, 164, 166, 168, 169, 170, 171, 172, 173, 175, 181, 183, 185, 187, 198, 244, 245, 284, 285, 286, 287, 288, 289, 290, 291, 310, 314, 424, 428, 606, 767], [2, 96], { 114: 628, 331: 640, 99: S2, 112: A2, 115: y2, 116: v2, 123: N2, 133: C2, 136: R2, 138: I2, 141: x2, 142: k2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 334: Z2, 335: ee, 336: te, 337: se }), D([2, 4, 5, 10, 72, 74, 76, 77, 78, 112, 118, 122, 124, 128, 129, 130, 131, 132, 134, 135, 137, 139, 140, 143, 145, 146, 148, 149, 150, 152, 154, 156, 162, 164, 166, 168, 169, 170, 171, 172, 173, 175, 181, 183, 185, 187, 198, 244, 245, 284, 285, 286, 287, 288, 289, 290, 291, 310, 314, 424, 428, 606, 767], [2, 97], { 114: 628, 331: 640, 99: S2, 115: y2, 116: v2, 123: N2, 133: C2, 136: R2, 138: I2, 141: x2, 142: k2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 334: Z2, 335: ee, 336: te, 337: se }), { 2: e, 3: 736, 4: t, 5: s, 72: me, 76: Te, 77: Se, 78: [1, 1223], 112: Ae, 114: 739, 115: y2, 116: v2, 117: 1224, 118: ye, 122: ve, 123: Ne, 124: Oe, 128: Ce, 129: Re, 130: Ie, 131: we, 132: $e, 133: xe, 134: ke, 135: Le, 136: De, 137: Me, 138: Ue, 139: Fe, 140: _e, 141: Pe, 142: qe, 143: Ge, 144: 761, 145: je, 146: Ve, 148: Be, 149: He, 150: Je, 152: Ye, 154: We, 156: Xe, 158: 771, 160: 772, 162: Ke, 164: Qe, 166: ze, 168: Ze, 169: et, 170: tt, 171: st, 172: nt, 173: rt, 175: at, 185: it, 187: ot, 244: E, 245: g, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 423: 191, 424: $, 428: x }, D(_3, [2, 1066], { 153: 1019, 179: a3, 180: i3, 181: o3 }), { 2: e, 3: 736, 4: t, 5: s, 72: me, 76: Te, 77: Se, 112: Ae, 114: 739, 115: y2, 116: v2, 117: 1226, 118: ye, 122: ve, 123: Ne, 124: Oe, 126: 1225, 128: Ce, 129: Re, 130: Ie, 131: we, 132: $e, 133: xe, 134: ke, 135: Le, 136: De, 137: Me, 138: Ue, 139: Fe, 140: _e, 141: Pe, 142: qe, 143: Ge, 144: 761, 145: je, 146: Ve, 148: Be, 149: He, 150: Je, 152: Ye, 154: We, 156: Xe, 158: 771, 160: 772, 162: Ke, 164: Qe, 166: ze, 168: Ze, 169: et, 170: tt, 171: st, 172: nt, 173: rt, 175: at, 185: it, 187: ot, 244: E, 245: g, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 423: 191, 424: $, 428: x }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1227, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1228, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 1229, 4: t, 5: s }, D(u3, [2, 110]), D(u3, [2, 111]), D(u3, [2, 112]), D(u3, [2, 119]), { 2: e, 3: 1230, 4: t, 5: s }, { 2: e, 3: 1015, 4: t, 5: s, 111: 1069, 143: l3, 145: c3, 147: 1231, 340: 1068, 341: 1070 }, { 2: e, 3: 1232, 4: t, 5: s }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 262, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 151: 1233, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, D(u3, [2, 125]), D(_3, [2, 1072], { 155: 1234 }), D(_3, [2, 1074], { 157: 1235 }), D(_3, [2, 1076], { 159: 1236 }), D(_3, [2, 1080], { 161: 1237 }), D(P3, q3, { 163: 1238, 178: 1239 }), { 77: [1, 1240] }, D(_3, [2, 1082], { 165: 1241 }), D(_3, [2, 1084], { 167: 1242 }), D(P3, q3, { 178: 1239, 163: 1243 }), D(P3, q3, { 178: 1239, 163: 1244 }), D(P3, q3, { 178: 1239, 163: 1245 }), D(P3, q3, { 178: 1239, 163: 1246 }), { 2: e, 3: 736, 4: t, 5: s, 72: me, 76: Te, 77: Se, 112: Ae, 114: 739, 115: y2, 116: v2, 117: 1247, 118: ye, 122: ve, 123: Ne, 124: Oe, 128: Ce, 129: Re, 130: Ie, 131: we, 132: $e, 133: xe, 134: ke, 135: Le, 136: De, 137: Me, 138: Ue, 139: Fe, 140: _e, 141: Pe, 142: qe, 143: Ge, 144: 761, 145: je, 146: Ve, 148: Be, 149: He, 150: Je, 152: Ye, 154: We, 156: Xe, 158: 771, 160: 772, 162: Ke, 164: Qe, 166: ze, 168: Ze, 169: et, 170: tt, 171: st, 172: nt, 173: rt, 175: at, 185: it, 187: ot, 244: E, 245: g, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 423: 191, 424: $, 428: x }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 820, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 174: 1248, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 257: 819, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, D(G3, [2, 1086], { 176: 1249 }), D(r, [2, 611], { 183: [1, 1250] }), D(r, [2, 607], { 183: [1, 1251] }), D(r, [2, 600]), { 113: 1252, 132: d, 300: I }, D(r, [2, 609], { 183: [1, 1253] }), D(r, [2, 604]), D(r, [2, 605], { 112: [1, 1254] }), D(ut, [2, 69]), { 40: 1255, 79: 75, 89: G, 184: 99, 189: H }, D(r, [2, 455], { 74: j3, 128: [1, 1256] }), D(V3, [2, 456]), { 124: [1, 1258] }, { 2: e, 3: 1259, 4: t, 5: s }, D(V1, [2, 1120]), D(V1, [2, 1121]), D(r, [2, 623]), D(ht, [2, 360], { 114: 628, 331: 640, 99: S2, 112: A2, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 334: Z2, 335: ee, 336: te, 337: se }), D(C3, R3, { 114: 628, 331: 640, 112: A2, 115: y2, 116: v2, 123: N2, 133: C2, 136: R2, 138: I2, 141: x2, 142: k2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 336: te }), D(E2, [2, 687]), D(E2, [2, 689]), D(r, [2, 655]), D(r, [2, 657], { 114: 628, 331: 640, 99: S2, 112: A2, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 334: Z2, 335: ee, 336: te, 337: se }), { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1260, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 1083, 4: t, 5: s, 77: h3, 131: d3, 436: 1261 }, D(B3, [2, 664]), D(B3, [2, 665]), D(B3, [2, 666]), { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1262, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1263, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 114: 1081, 115: y2, 116: v2, 124: [1, 1264] }, D(Et, [2, 760]), D(mt, [2, 148], { 74: f3 }), D(mt, [2, 149], { 74: f3 }), D(mt, [2, 150], { 74: f3 }), { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 820, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 257: 1265, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 1266, 4: t, 5: s, 113: 1268, 131: [1, 1267], 132: d, 300: I }, D(p3, [2, 278]), D(p3, [2, 280]), D(p3, [2, 282]), D(n2, [2, 160]), D(n2, [2, 1095]), { 78: [1, 1269] }, D(i2, [2, 763]), { 2: e, 3: 1270, 4: t, 5: s }, { 2: e, 3: 1271, 4: t, 5: s }, { 2: e, 3: 1273, 4: t, 5: s, 388: 1272 }, { 2: e, 3: 1273, 4: t, 5: s, 388: 1274 }, { 2: e, 3: 1275, 4: t, 5: s }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 262, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 151: 1276, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 1277, 4: t, 5: s }, { 74: ct, 78: [1, 1278] }, D(re, [2, 351]), D(re, [2, 352]), { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1279, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1280, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1281, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1282, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1283, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, D(St, [2, 509]), D(r, H3, { 411: 1284, 76: J3, 77: [1, 1285] }), D(r, H3, { 411: 1287, 76: J3 }), { 77: [1, 1288] }, { 2: e, 3: 246, 4: t, 5: s, 199: 1289 }, D(Et, [2, 736]), D(Et, [2, 738]), D(Et, [2, 1151]), { 143: t2, 145: s2, 435: 1290 }, D(Y3, [2, 1152], { 423: 191, 483: 1291, 144: 1292, 145: z1, 424: $, 428: x }), { 76: b3, 139: [2, 1156], 485: 1293, 487: 1294 }, D([10, 74, 76, 78, 132, 139, 145, 152, 310, 314, 424, 428, 606, 767], Ot, { 494: 855, 497: 856, 137: f2 }), D(Et, [2, 741]), D(Et, vt), { 74: At, 78: [1, 1295] }, D(Rt, [2, 1170], { 496: 1296, 501: 1297, 152: p2 }), D(Ct, [2, 1169]), D(Rt, [2, 750]), D(Rt, [2, 1175]), D(r, [2, 495], { 77: [1, 1298] }), { 76: [1, 1300], 77: [1, 1299] }, { 99: S2, 112: A2, 114: 628, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 148: [1, 1301], 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 331: 640, 334: Z2, 335: ee, 336: te, 337: se }, D(x3, W3, { 79: 75, 184: 99, 472: 1302, 40: 1305, 89: G, 146: X3, 189: H, 474: K3 }), D(E3, [2, 1145]), D(wt, [2, 728]), { 230: [1, 1306] }, D(Q3, [2, 774]), D(Q3, [2, 775]), D(Q3, [2, 776]), D($t, xt, { 514: 1307, 95: kt, 518: Lt, 519: Dt, 520: Mt }), D($t, [2, 773]), D(r, [2, 315]), D(r, [2, 316]), { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1308, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, D(E2, [2, 695], { 124: [1, 1309] }), D(S3, [2, 546]), { 131: [1, 1311], 392: 1310, 394: [1, 1312] }, D(S3, [2, 5]), { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1199, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 349: 1313, 423: 191, 424: $, 428: x }, D(r, [2, 460], { 114: 628, 331: 640, 99: S2, 112: A2, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 334: Z2, 335: ee, 336: te, 337: se }), D(r, [2, 594]), D(r, [2, 595]), { 2: e, 3: 246, 4: t, 5: s, 199: 1314 }, D(r, [2, 675]), { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1315, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1316, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 78: [1, 1317], 99: S2, 112: A2, 114: 628, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 331: 640, 334: Z2, 335: ee, 336: te, 337: se }, { 78: [1, 1318], 99: S2, 112: A2, 114: 628, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 331: 640, 334: Z2, 335: ee, 336: te, 337: se }, { 2: e, 3: 169, 4: t, 5: s, 40: 1319, 56: 166, 77: C1, 79: 75, 89: G, 94: 262, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 151: 1320, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 184: 99, 189: H, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 78: [1, 1321] }, { 74: ct, 78: [1, 1322] }, D(Q1, [2, 431]), { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1323, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 169, 4: t, 5: s, 40: 1324, 56: 166, 77: C1, 78: [1, 1326], 79: 75, 89: G, 94: 262, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 151: 1325, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 184: 99, 189: H, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, D(Q1, [2, 434]), D(Q1, [2, 436]), D(Q1, z3, { 279: 1327, 280: Z3 }), { 78: [1, 1329], 99: S2, 112: A2, 114: 628, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 331: 640, 334: Z2, 335: ee, 336: te, 337: se }, { 78: [1, 1330], 99: S2, 112: A2, 114: 628, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 331: 640, 334: Z2, 335: ee, 336: te, 337: se }, { 2: e, 3: 1331, 4: t, 5: s, 180: [1, 1332] }, D(ue, [2, 624]), D(Q1, [2, 368]), { 310: [1, 1333] }, D(Q1, [2, 375]), { 99: S2, 112: A2, 114: 628, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 310: [2, 379], 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 331: 640, 334: Z2, 335: ee, 336: te, 337: se }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1334, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 4: Ut, 7: 883, 276: 1335, 391: 882, 393: Ft }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1336, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, D(ue, [2, 646]), D(Wt, [2, 653]), D(Xt, [2, 641]), D($3, w3), D(ue, [2, 643]), D(zt, [2, 648]), D(zt, [2, 650]), D(zt, [2, 651]), D(zt, [2, 652]), D(x3, [2, 462], { 74: k3 }), { 77: [1, 1338], 143: f, 144: 1339, 145: z1, 152: p, 181: b, 201: 1340, 306: w, 423: 191, 424: $, 428: x }, D(x3, [2, 468]), { 74: e4, 78: [1, 1341] }, { 74: t4, 78: [1, 1343] }, D([74, 78, 99, 112, 115, 116, 123, 124, 133, 136, 138, 139, 140, 141, 142, 154, 170, 171, 179, 180, 315, 316, 317, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 334, 335, 336, 337], s4), D(n4, [2, 484], { 114: 628, 331: 640, 99: S2, 112: A2, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 334: Z2, 335: ee, 336: te, 337: se }), { 40: 1347, 77: t3, 79: 75, 89: G, 143: f, 144: 983, 145: z1, 149: Zt, 152: p, 181: b, 184: 99, 189: H, 201: 984, 306: w, 345: 1345, 346: 1346, 348: e3, 423: 191, 424: $, 428: x }, D(x3, [2, 466], { 74: k3 }), D(r, [2, 722], { 461: 1348, 462: 1349, 463: 1350, 312: M3, 468: [1, 1351] }), D(r4, [2, 706]), D(r4, [2, 707]), { 154: [1, 1353], 464: [1, 1352] }, { 99: S2, 112: A2, 114: 628, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 312: [2, 703], 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 331: 640, 334: Z2, 335: ee, 336: te, 337: se }, D(fe, [2, 179]), { 2: e, 3: 1354, 4: t, 5: s }, D(r, [2, 579]), D(a4, [2, 238], { 84: 1355, 128: [1, 1356] }), D(U3, [2, 1051]), { 77: [1, 1357] }, { 77: [1, 1358] }, D(s3, [2, 169], { 204: 1359, 215: 1361, 205: 1362, 216: 1363, 221: 1366, 74: i4, 206: o4, 208: u4, 222: l4, 223: c4, 224: h4, 225: d4, 226: f4, 227: p4, 228: b4, 229: E4 }), { 2: e, 3: 221, 4: t, 5: s, 40: 714, 77: J1, 79: 75, 89: G, 132: Y1, 143: f, 144: 214, 145: I1, 152: p, 156: a, 181: b, 184: 99, 189: H, 199: 215, 200: 217, 201: 216, 202: 219, 203: 1375, 209: 1216, 213: W1, 214: 220, 293: i, 294: o, 295: u, 296: l, 297: c, 306: w, 423: 191, 424: $, 428: x }, D(g4, [2, 177]), { 2: e, 3: 1015, 4: t, 5: s, 110: 1376, 111: 1013, 112: n3 }, D(F3, [2, 87]), D(r3, [2, 147], { 114: 628, 331: 640, 99: S2, 112: A2, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 334: Z2, 335: ee, 336: te, 337: se }), { 78: [1, 1377] }, { 74: ct, 78: [2, 1071] }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 78: [2, 1064], 94: 1382, 111: 150, 113: 154, 120: 1378, 121: 1379, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 241: 1380, 244: E, 245: g, 246: [1, 1381], 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, D(u3, [2, 98]), D(_3, [2, 1067], { 153: 1019, 179: a3, 180: i3, 181: o3 }), { 2: e, 3: 736, 4: t, 5: s, 72: me, 76: Te, 77: Se, 78: [1, 1383], 112: Ae, 114: 739, 115: y2, 116: v2, 117: 1384, 118: ye, 122: ve, 123: Ne, 124: Oe, 128: Ce, 129: Re, 130: Ie, 131: we, 132: $e, 133: xe, 134: ke, 135: Le, 136: De, 137: Me, 138: Ue, 139: Fe, 140: _e, 141: Pe, 142: qe, 143: Ge, 144: 761, 145: je, 146: Ve, 148: Be, 149: He, 150: Je, 152: Ye, 154: We, 156: Xe, 158: 771, 160: 772, 162: Ke, 164: Qe, 166: ze, 168: Ze, 169: et, 170: tt, 171: st, 172: nt, 173: rt, 175: at, 185: it, 187: ot, 244: E, 245: g, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 423: 191, 424: $, 428: x }, D(_3, [2, 1068], { 153: 1019, 179: a3, 180: i3, 181: o3 }), { 78: [1, 1385], 99: S2, 112: A2, 114: 628, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 331: 640, 334: Z2, 335: ee, 336: te, 337: se }, { 78: [1, 1386], 99: S2, 112: A2, 114: 628, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 331: 640, 334: Z2, 335: ee, 336: te, 337: se }, { 78: [1, 1387] }, D(u3, [2, 120]), { 74: j3, 78: [1, 1388] }, D(u3, [2, 122]), { 74: ct, 78: [1, 1389] }, { 2: e, 3: 736, 4: t, 5: s, 72: me, 76: Te, 77: Se, 78: [1, 1390], 112: Ae, 114: 739, 115: y2, 116: v2, 117: 1391, 118: ye, 122: ve, 123: Ne, 124: Oe, 128: Ce, 129: Re, 130: Ie, 131: we, 132: $e, 133: xe, 134: ke, 135: Le, 136: De, 137: Me, 138: Ue, 139: Fe, 140: _e, 141: Pe, 142: qe, 143: Ge, 144: 761, 145: je, 146: Ve, 148: Be, 149: He, 150: Je, 152: Ye, 154: We, 156: Xe, 158: 771, 160: 772, 162: Ke, 164: Qe, 166: ze, 168: Ze, 169: et, 170: tt, 171: st, 172: nt, 173: rt, 175: at, 185: it, 187: ot, 244: E, 245: g, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 423: 191, 424: $, 428: x }, { 2: e, 3: 736, 4: t, 5: s, 72: me, 76: Te, 77: Se, 78: [1, 1392], 112: Ae, 114: 739, 115: y2, 116: v2, 117: 1393, 118: ye, 122: ve, 123: Ne, 124: Oe, 128: Ce, 129: Re, 130: Ie, 131: we, 132: $e, 133: xe, 134: ke, 135: Le, 136: De, 137: Me, 138: Ue, 139: Fe, 140: _e, 141: Pe, 142: qe, 143: Ge, 144: 761, 145: je, 146: Ve, 148: Be, 149: He, 150: Je, 152: Ye, 154: We, 156: Xe, 158: 771, 160: 772, 162: Ke, 164: Qe, 166: ze, 168: Ze, 169: et, 170: tt, 171: st, 172: nt, 173: rt, 175: at, 185: it, 187: ot, 244: E, 245: g, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 423: 191, 424: $, 428: x }, { 2: e, 3: 736, 4: t, 5: s, 72: me, 76: Te, 77: Se, 78: [1, 1394], 112: Ae, 114: 739, 115: y2, 116: v2, 117: 1395, 118: ye, 122: ve, 123: Ne, 124: Oe, 128: Ce, 129: Re, 130: Ie, 131: we, 132: $e, 133: xe, 134: ke, 135: Le, 136: De, 137: Me, 138: Ue, 139: Fe, 140: _e, 141: Pe, 142: qe, 143: Ge, 144: 761, 145: je, 146: Ve, 148: Be, 149: He, 150: Je, 152: Ye, 154: We, 156: Xe, 158: 771, 160: 772, 162: Ke, 164: Qe, 166: ze, 168: Ze, 169: et, 170: tt, 171: st, 172: nt, 173: rt, 175: at, 185: it, 187: ot, 244: E, 245: g, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 423: 191, 424: $, 428: x }, { 2: e, 3: 736, 4: t, 5: s, 72: me, 76: Te, 77: Se, 78: [1, 1396], 112: Ae, 114: 739, 115: y2, 116: v2, 117: 1397, 118: ye, 122: ve, 123: Ne, 124: Oe, 128: Ce, 129: Re, 130: Ie, 131: we, 132: $e, 133: xe, 134: ke, 135: Le, 136: De, 137: Me, 138: Ue, 139: Fe, 140: _e, 141: Pe, 142: qe, 143: Ge, 144: 761, 145: je, 146: Ve, 148: Be, 149: He, 150: Je, 152: Ye, 154: We, 156: Xe, 158: 771, 160: 772, 162: Ke, 164: Qe, 166: ze, 168: Ze, 169: et, 170: tt, 171: st, 172: nt, 173: rt, 175: at, 185: it, 187: ot, 244: E, 245: g, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 423: 191, 424: $, 428: x }, { 74: m4, 78: [1, 1398] }, D(n4, [2, 143], { 423: 191, 3: 736, 114: 739, 144: 761, 158: 771, 160: 772, 117: 1400, 2: e, 4: t, 5: s, 72: me, 76: Te, 77: Se, 112: Ae, 115: y2, 116: v2, 118: ye, 122: ve, 123: Ne, 124: Oe, 128: Ce, 129: Re, 130: Ie, 131: we, 132: $e, 133: xe, 134: ke, 135: Le, 136: De, 137: Me, 138: Ue, 139: Fe, 140: _e, 141: Pe, 142: qe, 143: Ge, 145: je, 146: Ve, 148: Be, 149: He, 150: Je, 152: Ye, 154: We, 156: Xe, 162: Ke, 164: Qe, 166: ze, 168: Ze, 169: et, 170: tt, 171: st, 172: nt, 173: rt, 175: at, 185: it, 187: ot, 244: E, 245: g, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 424: $, 428: x }), D(P3, q3, { 178: 1239, 163: 1401 }), { 2: e, 3: 736, 4: t, 5: s, 72: me, 76: Te, 77: Se, 78: [1, 1402], 112: Ae, 114: 739, 115: y2, 116: v2, 117: 1403, 118: ye, 122: ve, 123: Ne, 124: Oe, 128: Ce, 129: Re, 130: Ie, 131: we, 132: $e, 133: xe, 134: ke, 135: Le, 136: De, 137: Me, 138: Ue, 139: Fe, 140: _e, 141: Pe, 142: qe, 143: Ge, 144: 761, 145: je, 146: Ve, 148: Be, 149: He, 150: Je, 152: Ye, 154: We, 156: Xe, 158: 771, 160: 772, 162: Ke, 164: Qe, 166: ze, 168: Ze, 169: et, 170: tt, 171: st, 172: nt, 173: rt, 175: at, 185: it, 187: ot, 244: E, 245: g, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 423: 191, 424: $, 428: x }, { 2: e, 3: 736, 4: t, 5: s, 72: me, 76: Te, 77: Se, 78: [1, 1404], 112: Ae, 114: 739, 115: y2, 116: v2, 117: 1405, 118: ye, 122: ve, 123: Ne, 124: Oe, 128: Ce, 129: Re, 130: Ie, 131: we, 132: $e, 133: xe, 134: ke, 135: Le, 136: De, 137: Me, 138: Ue, 139: Fe, 140: _e, 141: Pe, 142: qe, 143: Ge, 144: 761, 145: je, 146: Ve, 148: Be, 149: He, 150: Je, 152: Ye, 154: We, 156: Xe, 158: 771, 160: 772, 162: Ke, 164: Qe, 166: ze, 168: Ze, 169: et, 170: tt, 171: st, 172: nt, 173: rt, 175: at, 185: it, 187: ot, 244: E, 245: g, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 423: 191, 424: $, 428: x }, { 74: m4, 78: [1, 1406] }, { 74: m4, 78: [1, 1407] }, { 74: m4, 78: [1, 1408] }, { 74: m4, 78: [1, 1409] }, { 78: [1, 1410], 153: 1019, 179: a3, 180: i3, 181: o3 }, { 74: f3, 78: [1, 1411] }, { 2: e, 3: 736, 4: t, 5: s, 72: me, 74: [1, 1412], 76: Te, 77: Se, 112: Ae, 114: 739, 115: y2, 116: v2, 117: 1413, 118: ye, 122: ve, 123: Ne, 124: Oe, 128: Ce, 129: Re, 130: Ie, 131: we, 132: $e, 133: xe, 134: ke, 135: Le, 136: De, 137: Me, 138: Ue, 139: Fe, 140: _e, 141: Pe, 142: qe, 143: Ge, 144: 761, 145: je, 146: Ve, 148: Be, 149: He, 150: Je, 152: Ye, 154: We, 156: Xe, 158: 771, 160: 772, 162: Ke, 164: Qe, 166: ze, 168: Ze, 169: et, 170: tt, 171: st, 172: nt, 173: rt, 175: at, 185: it, 187: ot, 244: E, 245: g, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 423: 191, 424: $, 428: x }, { 2: e, 3: 1414, 4: t, 5: s }, { 2: e, 3: 1415, 4: t, 5: s }, D(r, [2, 602]), { 2: e, 3: 1416, 4: t, 5: s }, { 113: 1417, 132: d, 300: I }, { 78: [1, 1418] }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1419, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 1015, 4: t, 5: s, 111: 1069, 143: l3, 145: c3, 340: 1420, 341: 1070 }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1421, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 124: [1, 1422] }, D(r, [2, 658], { 114: 628, 331: 640, 99: S2, 112: A2, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 334: Z2, 335: ee, 336: te, 337: se }), D(B3, [2, 663]), { 78: [1, 1423], 99: S2, 112: A2, 114: 628, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 331: 640, 334: Z2, 335: ee, 336: te, 337: se }, D(r, [2, 659], { 114: 628, 331: 640, 99: S2, 112: A2, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 334: Z2, 335: ee, 336: te, 337: se }), { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1424, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, D(p3, [2, 275]), D(p3, [2, 277]), D(p3, [2, 279]), D(p3, [2, 281]), D(n2, [2, 161]), D(r, [2, 574]), { 148: [1, 1425] }, D(r, [2, 575]), D(Et, [2, 541], { 391: 882, 7: 883, 276: 1426, 4: Ut, 390: [1, 1427], 393: Ft }), D(r, [2, 576]), D(r, [2, 578]), { 74: ct, 78: [1, 1428] }, D(r, [2, 582]), D(re, [2, 349]), { 74: [1, 1429], 99: S2, 112: A2, 114: 628, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 331: 640, 334: Z2, 335: ee, 336: te, 337: se }, { 74: [1, 1430], 99: S2, 112: A2, 114: 628, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 331: 640, 334: Z2, 335: ee, 336: te, 337: se }, { 74: [1, 1431], 99: S2, 112: A2, 114: 628, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 331: 640, 334: Z2, 335: ee, 336: te, 337: se }, { 74: [1, 1432], 99: S2, 112: A2, 114: 628, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 331: 640, 334: Z2, 335: ee, 336: te, 337: se }, { 74: [1, 1433], 99: S2, 112: A2, 114: 628, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 331: 640, 334: Z2, 335: ee, 336: te, 337: se }, D(r, [2, 586]), { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 262, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 151: 1434, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 1435, 4: t, 5: s }, D(r, [2, 588]), { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1382, 111: 150, 113: 154, 120: 1436, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 241: 1380, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 77: [1, 1437] }, { 2: e, 3: 1438, 4: t, 5: s }, { 76: b3, 139: [2, 1154], 484: 1439, 487: 1440 }, D(Y3, [2, 1153]), { 139: [1, 1441] }, { 139: [2, 1157] }, D(Et, [2, 742]), D(Rt, [2, 749]), D(Rt, [2, 1171]), { 2: e, 3: 1273, 4: t, 5: s, 76: [1, 1444], 355: 1442, 362: 1443, 388: 1445 }, { 2: e, 3: 1015, 4: t, 5: s, 100: 1446, 111: 1447 }, { 40: 1448, 79: 75, 89: G, 184: 99, 189: H }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1449, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, D(x3, [2, 727]), { 2: e, 3: 1015, 4: t, 5: s, 111: 1069, 143: l3, 145: c3, 147: 1450, 340: 1068, 341: 1070 }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 262, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 151: 1451, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, D(x3, [2, 732]), { 2: e, 3: 246, 4: t, 5: s, 199: 1452 }, { 339: g3, 342: m3, 343: T3, 515: 1453 }, D(E2, [2, 696], { 114: 628, 331: 640, 99: S2, 112: A2, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 334: Z2, 335: ee, 336: te, 337: se }), { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1454, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 74: [1, 1455], 78: [1, 1456] }, D(n4, [2, 548]), D(n4, [2, 549]), { 74: t4, 78: [1, 1457] }, D(E2, [2, 570]), D(y3, [2, 385], { 114: 628, 331: 640, 115: y2, 116: v2, 123: N2, 133: C2, 136: R2, 138: I2, 141: x2, 142: k2, 179: U2, 180: F2, 316: P2, 320: j2, 321: V2, 322: B2, 323: H2 }), D(y3, [2, 387], { 114: 628, 331: 640, 115: y2, 116: v2, 123: N2, 133: C2, 136: R2, 138: I2, 141: x2, 142: k2, 179: U2, 180: F2, 316: P2, 320: j2, 321: V2, 322: B2, 323: H2 }), D(Q1, [2, 401]), D(Q1, [2, 405]), { 78: [1, 1458] }, { 74: ct, 78: [1, 1459] }, D(Q1, [2, 427]), D(Q1, [2, 429]), { 78: [1, 1460], 99: S2, 112: A2, 114: 628, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 331: 640, 334: Z2, 335: ee, 336: te, 337: se }, { 78: [1, 1461] }, { 74: ct, 78: [1, 1462] }, D(Q1, [2, 432]), D(Q1, [2, 330]), { 77: [1, 1463] }, D(Q1, z3, { 279: 1464, 280: Z3 }), D(Q1, z3, { 279: 1465, 280: Z3 }), D($3, [2, 287]), D(Q1, [2, 284]), D(Q1, [2, 374]), D(Yt, [2, 378], { 114: 628, 331: 640, 99: S2, 112: A2, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 334: Z2, 335: ee, 336: te, 337: se }), { 74: [1, 1467], 78: [1, 1466] }, { 74: [1, 1469], 78: [1, 1468], 99: S2, 112: A2, 114: 628, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 331: 640, 334: Z2, 335: ee, 336: te, 337: se }, { 2: e, 3: 1331, 4: t, 5: s }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1199, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 349: 1470, 423: 191, 424: $, 428: x }, D(D3, [2, 482]), D(D3, [2, 483]), { 40: 1473, 77: t3, 79: 75, 89: G, 143: f, 144: 983, 145: z1, 149: Zt, 152: p, 181: b, 184: 99, 189: H, 201: 984, 306: w, 345: 1471, 346: 1472, 348: e3, 423: 191, 424: $, 428: x }, { 2: e, 3: 1015, 4: t, 5: s, 111: 1474 }, D(D3, [2, 478]), { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1475, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 77: t3, 143: f, 144: 983, 145: z1, 152: p, 181: b, 201: 984, 306: w, 346: 1476, 423: 191, 424: $, 428: x }, D(x3, [2, 465], { 74: k3 }), D(x3, [2, 472]), D(r, [2, 699]), D(r4, [2, 704]), D(r4, [2, 705]), { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 820, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 174: 1477, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 257: 819, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 170: [1, 1479], 313: [1, 1478] }, { 464: [1, 1480] }, D(fe, [2, 180]), D(T4, [2, 240], { 85: 1481, 232: [1, 1482] }), { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1483, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1484, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 1485, 4: t, 5: s }, D(s3, [2, 170], { 216: 1363, 221: 1366, 215: 1486, 205: 1487, 206: o4, 208: u4, 222: l4, 223: c4, 224: h4, 225: d4, 226: f4, 227: p4, 228: b4, 229: E4 }), { 2: e, 3: 221, 4: t, 5: s, 77: J1, 132: Y1, 143: f, 144: 214, 145: I1, 152: p, 156: a, 181: b, 199: 215, 200: 217, 201: 216, 202: 219, 209: 1488, 213: W1, 214: 220, 293: i, 294: o, 295: u, 296: l, 297: c, 306: w, 423: 191, 424: $, 428: x }, D(S4, [2, 205]), D(S4, [2, 206]), { 2: e, 3: 221, 4: t, 5: s, 77: [1, 1493], 143: f, 144: 1491, 145: I1, 152: p, 156: a, 181: b, 199: 1490, 200: 1494, 201: 1492, 202: 1495, 217: 1489, 293: i, 294: o, 295: u, 296: l, 297: c, 306: w, 423: 191, 424: $, 428: x }, { 207: [1, 1496], 223: A4 }, { 207: [1, 1498], 223: y4 }, D(v4, [2, 222]), { 206: [1, 1502], 208: [1, 1501], 221: 1500, 223: c4, 224: h4, 225: d4, 226: f4, 227: p4, 228: b4, 229: E4 }, D(v4, [2, 224]), { 223: [1, 1503] }, { 208: [1, 1505], 223: [1, 1504] }, { 208: [1, 1507], 223: [1, 1506] }, { 208: [1, 1508] }, { 223: [1, 1509] }, { 223: [1, 1510] }, { 74: i4, 204: 1511, 205: 1362, 206: o4, 208: u4, 215: 1361, 216: 1363, 221: 1366, 222: l4, 223: c4, 224: h4, 225: d4, 226: f4, 227: p4, 228: b4, 229: E4 }, D(F3, [2, 84]), D(u3, [2, 100]), { 74: N4, 78: [1, 1512] }, { 78: [1, 1514] }, D(O4, [2, 261]), { 78: [2, 1065] }, D(O4, [2, 265], { 114: 628, 331: 640, 99: S2, 112: A2, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 246: [1, 1515], 247: [1, 1516], 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 334: Z2, 335: ee, 336: te, 337: se }), D(u3, [2, 99]), D(_3, [2, 1069], { 153: 1019, 179: a3, 180: i3, 181: o3 }), D(u3, [2, 101]), D(u3, [2, 102]), D(u3, [2, 103]), D(u3, [2, 121]), D(u3, [2, 124]), D(u3, [2, 127]), D(_3, [2, 1073], { 153: 1019, 179: a3, 180: i3, 181: o3 }), D(u3, [2, 128]), D(_3, [2, 1075], { 153: 1019, 179: a3, 180: i3, 181: o3 }), D(u3, [2, 129]), D(_3, [2, 1077], { 153: 1019, 179: a3, 180: i3, 181: o3 }), D(u3, [2, 130]), D(_3, [2, 1081], { 153: 1019, 179: a3, 180: i3, 181: o3 }), D(u3, [2, 131]), D(P3, [2, 1088], { 177: 1517 }), D(P3, [2, 1091], { 153: 1019, 179: a3, 180: i3, 181: o3 }), { 74: m4, 78: [1, 1518] }, D(u3, [2, 133]), D(_3, [2, 1083], { 153: 1019, 179: a3, 180: i3, 181: o3 }), D(u3, [2, 134]), D(_3, [2, 1085], { 153: 1019, 179: a3, 180: i3, 181: o3 }), D(u3, [2, 135]), D(u3, [2, 136]), D(u3, [2, 137]), D(u3, [2, 138]), D(u3, [2, 139]), D(u3, [2, 140]), { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 262, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 151: 1519, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, D(G3, [2, 1087], { 153: 1019, 179: a3, 180: i3, 181: o3 }), D(r, [2, 612]), D(r, [2, 608]), D(r, [2, 610]), D(r, [2, 606]), D(ut, [2, 71]), D(r, [2, 454], { 114: 628, 331: 640, 99: S2, 112: A2, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 334: Z2, 335: ee, 336: te, 337: se }), D(V3, [2, 457]), D(V3, [2, 458], { 114: 628, 331: 640, 99: S2, 112: A2, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 334: Z2, 335: ee, 336: te, 337: se }), { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1520, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, D(B3, [2, 667]), D(r, [2, 660], { 114: 628, 331: 640, 99: S2, 112: A2, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 334: Z2, 335: ee, 336: te, 337: se }), { 2: e, 3: 1521, 4: t, 5: s }, D(Et, [2, 550], { 389: 1522, 395: 1523, 396: 1524, 370: 1532, 154: C4, 187: R4, 230: I4, 301: w4, 347: $4, 360: x4, 372: k4, 373: L4, 377: D4, 378: M4 }), D(Et, [2, 540]), D(r, [2, 581], { 76: [1, 1536] }), { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1537, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1538, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1539, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1540, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1541, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 74: ct, 78: [1, 1542] }, D(r, [2, 590]), { 74: N4, 78: [1, 1543] }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1382, 111: 150, 113: 154, 120: 1544, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 241: 1380, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, D([10, 74, 78, 139, 310, 314, 606, 767], [2, 746]), { 139: [1, 1545] }, { 139: [2, 1155] }, { 2: e, 3: 1127, 4: t, 5: s, 132: d2, 137: f2, 143: t2, 145: s2, 152: p2, 435: 588, 479: 1129, 482: 1546, 486: 585, 497: 582, 501: 584 }, { 78: [1, 1547] }, { 74: [1, 1548], 78: [2, 511] }, { 40: 1549, 79: 75, 89: G, 184: 99, 189: H }, D(n4, [2, 537]), { 74: e4, 78: [1, 1550] }, D(g4, s4), D(r, [2, 1138], { 416: 1551, 417: 1552, 72: U4 }), D(x3, W3, { 79: 75, 184: 99, 114: 628, 331: 640, 40: 1305, 472: 1554, 89: G, 99: S2, 112: A2, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 146: X3, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 189: H, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 334: Z2, 335: ee, 336: te, 337: se, 474: K3 }), D(x3, [2, 730], { 74: j3 }), D(x3, [2, 731], { 74: ct }), D([10, 53, 72, 89, 124, 146, 156, 189, 270, 271, 293, 310, 314, 339, 342, 343, 400, 404, 405, 408, 410, 412, 413, 421, 422, 438, 440, 441, 443, 444, 445, 446, 447, 451, 452, 455, 456, 509, 511, 512, 521, 606, 767], [2, 1186], { 516: 1555, 3: 1556, 2: e, 4: t, 5: s, 76: [1, 1557] }), D(F4, [2, 1188], { 517: 1558, 76: [1, 1559] }), D(E2, [2, 697], { 114: 628, 331: 640, 99: S2, 112: A2, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 334: Z2, 335: ee, 336: te, 337: se }), { 131: [1, 1560] }, D(S3, [2, 543]), D(S3, [2, 545]), D(Q1, [2, 417]), D(Q1, [2, 418]), D(Q1, [2, 444]), D(Q1, [2, 428]), D(Q1, [2, 430]), { 118: _4, 281: 1561, 282: 1562, 283: [1, 1563] }, D(Q1, [2, 331]), D(Q1, [2, 332]), D(Q1, [2, 319]), { 131: [1, 1565] }, D(Q1, [2, 321]), { 131: [1, 1566] }, { 74: t4, 78: [1, 1567] }, { 77: t3, 143: f, 144: 983, 145: z1, 152: p, 181: b, 201: 984, 306: w, 346: 1568, 423: 191, 424: $, 428: x }, D(x3, [2, 470], { 74: k3 }), D(x3, [2, 473]), D(g4, [2, 493]), D(n4, [2, 485], { 114: 628, 331: 640, 99: S2, 112: A2, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 334: Z2, 335: ee, 336: te, 337: se }), D(x3, [2, 464], { 74: k3 }), D(r, [2, 723], { 74: f3, 198: [1, 1569] }), { 339: P4, 342: q4, 465: 1570 }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1573, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 119: [1, 1575], 170: [1, 1576], 313: [1, 1574] }, D(G4, [2, 259], { 86: 1577, 118: [1, 1578] }), { 119: [1, 1579] }, D(a4, [2, 239], { 114: 628, 331: 640, 99: S2, 112: A2, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 334: Z2, 335: ee, 336: te, 337: se }), { 95: [1, 1580], 99: S2, 112: A2, 114: 628, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 331: 640, 334: Z2, 335: ee, 336: te, 337: se }, { 95: [1, 1581] }, D(S4, [2, 203]), D(S4, [2, 204]), D(g4, [2, 178]), D(S4, [2, 237], { 218: 1582, 230: [1, 1583], 231: [1, 1584] }), D(j4, [2, 208], { 3: 1585, 2: e, 4: t, 5: s, 76: [1, 1586] }), D(V4, [2, 1100], { 219: 1587, 76: [1, 1588] }), { 2: e, 3: 1589, 4: t, 5: s, 76: [1, 1590] }, { 40: 1591, 79: 75, 89: G, 184: 99, 189: H }, D(j4, [2, 216], { 3: 1592, 2: e, 4: t, 5: s, 76: [1, 1593] }), D(j4, [2, 219], { 3: 1594, 2: e, 4: t, 5: s, 76: [1, 1595] }), { 77: [1, 1596] }, D(v4, [2, 234]), { 77: [1, 1597] }, D(v4, [2, 230]), D(v4, [2, 223]), { 223: y4 }, { 223: A4 }, D(v4, [2, 225]), D(v4, [2, 226]), { 223: [1, 1598] }, D(v4, [2, 228]), { 223: [1, 1599] }, { 223: [1, 1600] }, D(v4, [2, 232]), D(v4, [2, 233]), { 78: [1, 1601], 205: 1487, 206: o4, 208: u4, 215: 1486, 216: 1363, 221: 1366, 222: l4, 223: c4, 224: h4, 225: d4, 226: f4, 227: p4, 228: b4, 229: E4 }, D(u3, [2, 91]), { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1382, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 241: 1602, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, D(u3, [2, 92]), D(O4, [2, 266], { 242: 1603, 243: [1, 1604] }), { 248: [1, 1605] }, D(n4, [2, 142], { 423: 191, 3: 736, 114: 739, 144: 761, 158: 771, 160: 772, 117: 1606, 2: e, 4: t, 5: s, 72: me, 76: Te, 77: Se, 112: Ae, 115: y2, 116: v2, 118: ye, 122: ve, 123: Ne, 124: Oe, 128: Ce, 129: Re, 130: Ie, 131: we, 132: $e, 133: xe, 134: ke, 135: Le, 136: De, 137: Me, 138: Ue, 139: Fe, 140: _e, 141: Pe, 142: qe, 143: Ge, 145: je, 146: Ve, 148: Be, 149: He, 150: Je, 152: Ye, 154: We, 156: Xe, 162: Ke, 164: Qe, 166: ze, 168: Ze, 169: et, 170: tt, 171: st, 172: nt, 173: rt, 175: at, 185: it, 187: ot, 244: E, 245: g, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 424: $, 428: x }), D(u3, [2, 132]), { 74: ct, 78: [1, 1607] }, D(V3, [2, 459], { 114: 628, 331: 640, 99: S2, 112: A2, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 334: Z2, 335: ee, 336: te, 337: se }), D(r, [2, 577]), D(Et, [2, 539]), D(Et, [2, 551], { 370: 1532, 396: 1608, 154: C4, 187: R4, 230: I4, 301: w4, 347: $4, 360: x4, 372: k4, 373: L4, 377: D4, 378: M4 }), D(lt, [2, 553]), { 374: [1, 1609] }, { 374: [1, 1610] }, { 2: e, 3: 246, 4: t, 5: s, 199: 1611 }, D(lt, [2, 559], { 77: [1, 1612] }), { 2: e, 3: 114, 4: t, 5: s, 77: [1, 1614], 113: 253, 131: h, 132: d, 143: f, 152: p, 156: a, 181: b, 196: 252, 200: 1615, 201: 256, 261: 254, 262: 255, 269: Z1, 278: 1613, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 306: w }, D(lt, [2, 563]), { 301: [1, 1616] }, D(lt, [2, 565]), D(lt, [2, 566]), { 339: [1, 1617] }, { 77: [1, 1618] }, { 2: e, 3: 1619, 4: t, 5: s }, { 78: [1, 1620], 99: S2, 112: A2, 114: 628, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 331: 640, 334: Z2, 335: ee, 336: te, 337: se }, { 78: [1, 1621], 99: S2, 112: A2, 114: 628, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 331: 640, 334: Z2, 335: ee, 336: te, 337: se }, { 78: [1, 1622], 99: S2, 112: A2, 114: 628, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 331: 640, 334: Z2, 335: ee, 336: te, 337: se }, { 78: [1, 1623], 99: S2, 112: A2, 114: 628, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 331: 640, 334: Z2, 335: ee, 336: te, 337: se }, { 78: [1, 1624], 99: S2, 112: A2, 114: 628, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 331: 640, 334: Z2, 335: ee, 336: te, 337: se }, D(r, H3, { 411: 1625, 76: J3 }), D(r, [2, 596]), { 74: N4, 78: [1, 1626] }, { 2: e, 3: 1127, 4: t, 5: s, 132: d2, 137: f2, 143: t2, 145: s2, 152: p2, 435: 588, 479: 1129, 482: 1627, 486: 585, 497: 582, 501: 584 }, D(Et, [2, 740]), D(r, [2, 498], { 356: 1628, 358: 1629, 359: 1630, 4: B4, 247: H4, 347: J4, 360: Y4 }), D(W4, X4, { 3: 1273, 363: 1635, 388: 1636, 364: 1637, 365: 1638, 2: e, 4: t, 5: s, 371: K4 }), { 78: [2, 512] }, { 76: [1, 1640] }, D(r, [2, 614]), D(r, [2, 1139]), { 372: [1, 1642], 418: [1, 1641] }, D(x3, [2, 733]), D(r, F, { 17: 5, 18: 7, 19: 8, 20: 9, 21: 10, 22: 11, 23: 12, 24: 13, 25: 14, 26: 15, 27: 16, 28: 17, 29: 18, 30: 19, 31: 20, 32: 21, 33: 22, 34: 23, 35: 24, 36: 25, 37: 26, 38: 27, 39: 28, 40: 29, 41: 30, 42: 31, 43: 32, 44: 33, 45: 34, 46: 35, 47: 36, 48: 37, 49: 38, 50: 39, 51: 40, 52: 41, 54: 43, 55: 44, 56: 45, 57: 46, 58: 47, 59: 48, 60: 49, 61: 50, 62: 51, 63: 52, 64: 53, 65: 54, 66: 55, 67: 56, 68: 57, 69: 58, 70: 59, 71: 60, 79: 75, 508: 95, 184: 99, 3: 100, 12: 1643, 2: e, 4: t, 5: s, 53: P, 72: q, 89: G, 124: j, 146: V, 156: B, 189: H, 270: n, 271: J, 293: Y, 339: W, 342: X, 343: K, 400: Q, 404: z, 405: Z, 408: e1, 410: t1, 412: s1, 413: n1, 421: r1, 422: a1, 438: i1, 440: o1, 441: u1, 443: l1, 444: c1, 445: h1, 446: d1, 447: f1, 451: p1, 452: b1, 455: E1, 456: g1, 509: m1, 511: T1, 512: S1, 521: A1 }), D(r, [2, 767]), D(F4, [2, 1187]), D(r, F, { 17: 5, 18: 7, 19: 8, 20: 9, 21: 10, 22: 11, 23: 12, 24: 13, 25: 14, 26: 15, 27: 16, 28: 17, 29: 18, 30: 19, 31: 20, 32: 21, 33: 22, 34: 23, 35: 24, 36: 25, 37: 26, 38: 27, 39: 28, 40: 29, 41: 30, 42: 31, 43: 32, 44: 33, 45: 34, 46: 35, 47: 36, 48: 37, 49: 38, 50: 39, 51: 40, 52: 41, 54: 43, 55: 44, 56: 45, 57: 46, 58: 47, 59: 48, 60: 49, 61: 50, 62: 51, 63: 52, 64: 53, 65: 54, 66: 55, 67: 56, 68: 57, 69: 58, 70: 59, 71: 60, 79: 75, 508: 95, 184: 99, 3: 100, 12: 1644, 2: e, 4: t, 5: s, 53: P, 72: q, 89: G, 124: j, 146: V, 156: B, 189: H, 270: n, 271: J, 293: Y, 339: W, 342: X, 343: K, 400: Q, 404: z, 405: Z, 408: e1, 410: t1, 412: s1, 413: n1, 421: r1, 422: a1, 438: i1, 440: o1, 441: u1, 443: l1, 444: c1, 445: h1, 446: d1, 447: f1, 451: p1, 452: b1, 455: E1, 456: g1, 509: m1, 511: T1, 512: S1, 521: A1 }), D(F4, [2, 1189]), { 78: [1, 1645] }, { 78: [1, 1646], 118: _4, 282: 1647 }, { 78: [1, 1648] }, { 119: [1, 1649] }, { 119: [1, 1650] }, { 78: [1, 1651] }, { 78: [1, 1652] }, D(D3, [2, 481]), D(x3, [2, 469], { 74: k3 }), { 2: e, 3: 246, 4: t, 5: s, 143: t2, 145: s2, 199: 1654, 435: 1653 }, D(r4, [2, 708]), D(r4, [2, 710]), { 146: [1, 1655] }, { 99: S2, 112: A2, 114: 628, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 313: [1, 1656], 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 331: 640, 334: Z2, 335: ee, 336: te, 337: se }, { 343: Q4, 466: 1657 }, { 421: [1, 1660], 467: [1, 1659] }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1661, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, D(z4, [2, 270], { 87: 1662, 249: [1, 1663], 251: [1, 1664] }), { 119: [1, 1665] }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1671, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 233: 1666, 235: 1667, 236: Z4, 237: es, 238: ts, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 1672, 4: t, 5: s }, { 2: e, 3: 1673, 4: t, 5: s }, D(S4, [2, 207]), { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1674, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 1015, 4: t, 5: s, 100: 1675, 111: 1447 }, D(j4, [2, 209]), { 2: e, 3: 1676, 4: t, 5: s }, D(j4, [2, 1102], { 220: 1677, 3: 1678, 2: e, 4: t, 5: s }), D(V4, [2, 1101]), D(j4, [2, 212]), { 2: e, 3: 1679, 4: t, 5: s }, { 78: [1, 1680] }, D(j4, [2, 217]), { 2: e, 3: 1681, 4: t, 5: s }, D(j4, [2, 220]), { 2: e, 3: 1682, 4: t, 5: s }, { 40: 1683, 79: 75, 89: G, 184: 99, 189: H }, { 40: 1684, 79: 75, 89: G, 184: 99, 189: H }, D(v4, [2, 227]), D(v4, [2, 229]), D(v4, [2, 231]), D(s3, [2, 171]), D(O4, [2, 262]), D(O4, [2, 267]), { 244: [1, 1685], 245: [1, 1686] }, D(O4, [2, 268], { 246: [1, 1687] }), D(P3, [2, 1089], { 153: 1019, 179: a3, 180: i3, 181: o3 }), D(u3, [2, 141]), D(lt, [2, 552]), D(lt, [2, 555]), { 378: [1, 1688] }, D(lt, [2, 1132], { 399: 1689, 397: 1690, 77: ss }), { 131: h, 196: 1692 }, D(lt, [2, 560]), { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1693, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, D(lt, [2, 562]), D(lt, [2, 564]), { 2: e, 3: 114, 4: t, 5: s, 77: [1, 1695], 113: 253, 131: h, 132: d, 143: f, 152: p, 156: a, 181: b, 196: 252, 200: 257, 201: 256, 261: 254, 262: 255, 269: Z1, 278: 1694, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 306: w }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1696, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, D(r, [2, 583]), D(re, [2, 353]), D(re, [2, 354]), D(re, [2, 355]), D(re, [2, 356]), D(re, [2, 357]), D(r, [2, 587]), D(r, [2, 597]), D(Et, [2, 739]), D(r, [2, 494]), D(r, [2, 499], { 359: 1697, 4: B4, 247: H4, 347: J4, 360: Y4 }), D(ns, [2, 501]), D(ns, [2, 502]), { 124: [1, 1698] }, { 124: [1, 1699] }, { 124: [1, 1700] }, { 74: [1, 1701], 78: [2, 510] }, D(n4, [2, 538]), D(n4, [2, 513]), { 187: [1, 1709], 193: [1, 1710], 366: 1702, 367: 1703, 368: 1704, 369: 1705, 370: 1706, 372: k4, 373: [1, 1707], 374: [1, 1711], 377: [1, 1708] }, { 2: e, 3: 1712, 4: t, 5: s }, { 40: 1713, 79: 75, 89: G, 184: 99, 189: H }, { 419: [1, 1714] }, { 420: [1, 1715] }, D(r, [2, 766]), D(r, [2, 768]), D(S3, [2, 542]), D(Q1, [2, 334]), { 78: [1, 1716] }, D(Q1, [2, 335]), { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1671, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 233: 1717, 235: 1667, 236: Z4, 237: es, 238: ts, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1382, 111: 150, 113: 154, 120: 1718, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 241: 1380, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, D(Q1, [2, 320]), D(Q1, [2, 322]), { 2: e, 3: 1719, 4: t, 5: s }, D(r, [2, 725], { 77: [1, 1720] }), { 2: e, 3: 1015, 4: t, 5: s, 111: 1069, 143: l3, 145: c3, 147: 1721, 340: 1068, 341: 1070 }, { 339: P4, 342: q4, 465: 1722 }, D(r4, [2, 712]), { 77: [1, 1724], 347: [1, 1725], 348: [1, 1723] }, { 170: [1, 1727], 313: [1, 1726] }, { 170: [1, 1729], 313: [1, 1728] }, { 99: S2, 112: A2, 114: 628, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 313: [1, 1730], 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 331: 640, 334: Z2, 335: ee, 336: te, 337: se }, D(r3, [2, 250], { 88: 1731, 162: [1, 1732], 168: [1, 1734], 169: [1, 1733] }), { 131: h, 196: 1735 }, { 131: h, 196: 1736 }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1382, 111: 150, 113: 154, 120: 1737, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 241: 1380, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, D(T4, [2, 248], { 234: 1738, 74: rs, 239: [1, 1740] }), D(as, [2, 242]), { 146: [1, 1741] }, { 77: [1, 1742] }, { 77: [1, 1743] }, D(as, [2, 247], { 114: 628, 331: 640, 99: S2, 112: A2, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 334: Z2, 335: ee, 336: te, 337: se }), { 78: [2, 1056], 96: 1744, 99: [1, 1746], 102: 1745 }, { 99: [1, 1747] }, D(S4, [2, 235], { 114: 628, 331: 640, 99: S2, 112: A2, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 334: Z2, 335: ee, 336: te, 337: se }), D(S4, [2, 236], { 74: e4 }), D(j4, [2, 210]), D(j4, [2, 211]), D(j4, [2, 1103]), D(j4, [2, 213]), { 2: e, 3: 1748, 4: t, 5: s, 76: [1, 1749] }, D(j4, [2, 218]), D(j4, [2, 221]), { 78: [1, 1750] }, { 78: [1, 1751] }, D(O4, [2, 263]), D(O4, [2, 264]), D(O4, [2, 269]), { 2: e, 3: 246, 4: t, 5: s, 199: 1752 }, D(lt, [2, 557]), D(lt, [2, 1133]), { 2: e, 3: 1753, 4: t, 5: s }, { 74: [1, 1754] }, { 78: [1, 1755], 99: S2, 112: A2, 114: 628, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 331: 640, 334: Z2, 335: ee, 336: te, 337: se }, D(lt, [2, 567]), { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1756, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 78: [1, 1757], 99: S2, 112: A2, 114: 628, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 331: 640, 334: Z2, 335: ee, 336: te, 337: se }, D(ns, [2, 500]), { 2: e, 3: 1758, 4: t, 5: s }, { 131: h, 196: 1759 }, { 2: e, 3: 1760, 4: t, 5: s }, D(W4, X4, { 365: 1638, 364: 1761, 371: K4 }), D(Et, [2, 515]), D(Et, [2, 516]), D(Et, [2, 517]), D(Et, [2, 518]), D(Et, [2, 519]), { 374: [1, 1762] }, { 374: [1, 1763] }, D(is, [2, 1126], { 386: 1764, 374: [1, 1765] }), { 2: e, 3: 1766, 4: t, 5: s }, { 2: e, 3: 1767, 4: t, 5: s }, D(W4, [2, 521]), D(r, [2, 1136], { 415: 1768, 417: 1769, 72: U4 }), D(r, [2, 615]), D(r, [2, 616], { 371: [1, 1770] }), D(Q1, [2, 336]), D([78, 118], [2, 337], { 74: rs }), { 74: N4, 78: [2, 338] }, D(r, [2, 724]), { 2: e, 3: 1015, 4: t, 5: s, 100: 1771, 111: 1447 }, D(r4, [2, 711], { 74: j3 }), D(r4, [2, 709]), { 77: t3, 143: f, 144: 983, 145: z1, 152: p, 181: b, 201: 984, 306: w, 346: 1772, 423: 191, 424: $, 428: x }, { 2: e, 3: 1015, 4: t, 5: s, 100: 1773, 111: 1447 }, { 348: [1, 1774] }, { 343: Q4, 466: 1775 }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1776, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 343: Q4, 466: 1777 }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1778, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 343: Q4, 466: 1779 }, D(r3, [2, 72]), { 40: 1780, 79: 75, 89: G, 164: [1, 1781], 184: 99, 189: H, 240: [1, 1782] }, { 40: 1783, 79: 75, 89: G, 184: 99, 189: H, 240: [1, 1784] }, { 40: 1785, 79: 75, 89: G, 184: 99, 189: H, 240: [1, 1786] }, D(z4, [2, 273], { 250: 1787, 251: [1, 1788] }), { 252: 1789, 253: [2, 1104], 769: [1, 1790] }, D(G4, [2, 260], { 74: N4 }), D(T4, [2, 241]), { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1671, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 235: 1791, 236: Z4, 237: es, 238: ts, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1792, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 77: [1, 1793] }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1671, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 233: 1794, 235: 1667, 236: Z4, 237: es, 238: ts, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1671, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 233: 1795, 235: 1667, 236: Z4, 237: es, 238: ts, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 78: [1, 1796] }, { 78: [2, 1057] }, { 77: [1, 1797] }, { 77: [1, 1798] }, D(j4, [2, 214]), { 2: e, 3: 1799, 4: t, 5: s }, { 2: e, 3: 1800, 4: t, 5: s, 76: [1, 1801] }, { 2: e, 3: 1802, 4: t, 5: s, 76: [1, 1803] }, D(lt, [2, 1130], { 398: 1804, 397: 1805, 77: ss }), { 78: [1, 1806] }, { 131: h, 196: 1807 }, D(lt, [2, 561]), { 78: [1, 1808], 99: S2, 112: A2, 114: 628, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 331: 640, 334: Z2, 335: ee, 336: te, 337: se }, D(lt, [2, 522]), D(ns, [2, 503]), D(ns, [2, 504]), D(ns, [2, 505]), D(n4, [2, 514]), { 2: e, 3: 1810, 4: t, 5: s, 77: [2, 1122], 375: 1809 }, { 77: [1, 1811] }, { 2: e, 3: 1813, 4: t, 5: s, 77: [2, 1128], 387: 1812 }, D(is, [2, 1127]), { 77: [1, 1814] }, { 77: [1, 1815] }, D(r, [2, 613]), D(r, [2, 1137]), D(W4, X4, { 365: 1638, 364: 1816, 371: K4 }), { 74: e4, 78: [1, 1817] }, D(r4, [2, 718], { 74: k3 }), { 74: e4, 78: [1, 1818] }, D(r4, [2, 720]), D(r4, [2, 713]), { 99: S2, 112: A2, 114: 628, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 313: [1, 1819], 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 331: 640, 334: Z2, 335: ee, 336: te, 337: se }, D(r4, [2, 716]), { 99: S2, 112: A2, 114: 628, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 313: [1, 1820], 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 331: 640, 334: Z2, 335: ee, 336: te, 337: se }, D(r4, [2, 714]), D(r3, [2, 251]), { 40: 1821, 79: 75, 89: G, 184: 99, 189: H, 240: [1, 1822] }, { 40: 1823, 79: 75, 89: G, 184: 99, 189: H }, D(r3, [2, 253]), { 40: 1824, 79: 75, 89: G, 184: 99, 189: H }, D(r3, [2, 254]), { 40: 1825, 79: 75, 89: G, 184: 99, 189: H }, D(z4, [2, 271]), { 131: h, 196: 1826 }, { 253: [1, 1827] }, { 253: [2, 1105] }, D(as, [2, 243]), D(T4, [2, 249], { 114: 628, 331: 640, 99: S2, 112: A2, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 334: Z2, 335: ee, 336: te, 337: se }), { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1671, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 233: 1828, 235: 1667, 236: Z4, 237: es, 238: ts, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 74: rs, 78: [1, 1829] }, { 74: rs, 78: [1, 1830] }, D(U3, [2, 1058], { 97: 1831, 104: 1832, 3: 1834, 2: e, 4: t, 5: s, 76: os }), { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1837, 103: 1835, 105: 1836, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 1015, 4: t, 5: s, 100: 1838, 111: 1447 }, D(j4, [2, 215]), D(S4, [2, 173]), { 2: e, 3: 1839, 4: t, 5: s }, D(S4, [2, 175]), { 2: e, 3: 1840, 4: t, 5: s }, D(lt, [2, 556]), D(lt, [2, 1131]), D(lt, [2, 554]), { 78: [1, 1841] }, D(lt, [2, 568]), { 77: [1, 1842] }, { 77: [2, 1123] }, { 2: e, 3: 1844, 4: t, 5: s, 132: us, 376: 1843 }, { 77: [1, 1846] }, { 77: [2, 1129] }, { 2: e, 3: 1015, 4: t, 5: s, 100: 1847, 111: 1447 }, { 2: e, 3: 1015, 4: t, 5: s, 100: 1848, 111: 1447 }, D(r, [2, 617]), D(r, [2, 726]), { 347: [1, 1850], 348: [1, 1849] }, { 343: Q4, 466: 1851 }, { 339: P4, 342: q4, 465: 1852 }, D(r3, [2, 252]), { 40: 1853, 79: 75, 89: G, 184: 99, 189: H }, D(r3, [2, 255]), D(r3, [2, 257]), D(r3, [2, 258]), D(z4, [2, 274]), { 131: [2, 1106], 254: 1854, 649: [1, 1855] }, { 74: rs, 78: [1, 1856] }, D(as, [2, 245]), D(as, [2, 246]), D(U3, [2, 74]), D(U3, [2, 1059]), { 2: e, 3: 1857, 4: t, 5: s }, D(U3, [2, 78]), { 74: [1, 1859], 78: [1, 1858] }, D(n4, [2, 80]), D(n4, [2, 81], { 114: 628, 331: 640, 76: [1, 1860], 99: S2, 112: A2, 115: y2, 116: v2, 123: N2, 124: dt, 133: C2, 136: R2, 138: I2, 139: w2, 140: $2, 141: x2, 142: k2, 154: L2, 170: D2, 171: M2, 179: U2, 180: F2, 315: _2, 316: P2, 317: q2, 319: G2, 320: j2, 321: V2, 322: B2, 323: H2, 324: J2, 325: Y2, 326: W2, 327: X2, 328: K2, 329: Q2, 330: z2, 334: Z2, 335: ee, 336: te, 337: se }), { 74: e4, 78: [1, 1861] }, D(S4, [2, 174]), D(S4, [2, 176]), D(lt, [2, 558]), { 2: e, 3: 1844, 4: t, 5: s, 132: us, 376: 1862 }, { 74: ls, 78: [1, 1863] }, D(n4, [2, 533]), D(n4, [2, 534]), { 2: e, 3: 1015, 4: t, 5: s, 100: 1865, 111: 1447 }, { 74: e4, 78: [1, 1866] }, { 74: e4, 78: [1, 1867] }, { 77: t3, 143: f, 144: 983, 145: z1, 152: p, 181: b, 201: 984, 306: w, 346: 1868, 423: 191, 424: $, 428: x }, { 348: [1, 1869] }, D(r4, [2, 715]), D(r4, [2, 717]), D(r3, [2, 256]), { 131: h, 196: 1870 }, { 131: [2, 1107] }, D(as, [2, 244]), D(U3, [2, 77]), { 78: [2, 76] }, { 2: e, 3: 169, 4: t, 5: s, 56: 166, 77: C1, 94: 1837, 105: 1871, 111: 150, 113: 154, 131: h, 132: d, 137: R1, 143: f, 144: 162, 145: I1, 149: w1, 152: p, 154: $1, 156: a, 158: 168, 179: x1, 180: k1, 181: b, 196: 152, 200: 148, 201: 156, 202: 157, 244: E, 245: g, 258: 151, 259: 147, 260: 149, 261: 153, 262: 155, 263: 158, 264: 159, 265: 160, 266: 163, 267: 164, 269: L1, 270: n, 274: D1, 275: M1, 277: U1, 284: m, 285: T, 286: S, 287: A, 288: y, 289: v, 290: N, 291: O, 293: i, 294: o, 295: u, 296: l, 297: c, 298: C, 299: R, 300: I, 301: F1, 302: _1, 303: P1, 306: w, 307: q1, 316: G1, 321: j1, 423: 191, 424: $, 428: x }, { 2: e, 3: 1872, 4: t, 5: s }, { 78: [1, 1873] }, { 74: ls, 78: [1, 1874] }, { 378: [1, 1875] }, { 2: e, 3: 1876, 4: t, 5: s, 132: [1, 1877] }, { 74: e4, 78: [1, 1878] }, D(Et, [2, 531]), D(Et, [2, 532]), D(r4, [2, 719], { 74: k3 }), D(r4, [2, 721]), D(cs, [2, 1108], { 255: 1879, 769: [1, 1880] }), D(n4, [2, 79]), D(n4, [2, 82]), D(U3, [2, 1060], { 3: 1834, 101: 1881, 104: 1882, 2: e, 4: t, 5: s, 76: os }), D(Et, [2, 523]), { 2: e, 3: 246, 4: t, 5: s, 199: 1883 }, D(n4, [2, 535]), D(n4, [2, 536]), D(Et, [2, 530]), D(z4, [2, 1110], { 256: 1884, 419: [1, 1885] }), D(cs, [2, 1109]), D(U3, [2, 75]), D(U3, [2, 1061]), D(hs, [2, 1124], { 379: 1886, 381: 1887, 77: [1, 1888] }), D(z4, [2, 272]), D(z4, [2, 1111]), D(Et, [2, 526], { 380: 1889, 382: 1890, 230: [1, 1891] }), D(hs, [2, 1125]), { 2: e, 3: 1844, 4: t, 5: s, 132: us, 376: 1892 }, D(Et, [2, 524]), { 230: [1, 1894], 383: 1893 }, { 342: [1, 1895] }, { 74: ls, 78: [1, 1896] }, D(Et, [2, 527]), { 339: [1, 1897] }, { 384: [1, 1898] }, D(hs, [2, 525]), { 384: [1, 1899] }, { 385: [1, 1900] }, { 385: [1, 1901] }, { 230: [2, 528] }, D(Et, [2, 529])], defaultActions: { 105: [2, 6], 195: [2, 339], 196: [2, 340], 197: [2, 341], 198: [2, 342], 199: [2, 343], 200: [2, 344], 201: [2, 345], 202: [2, 346], 203: [2, 347], 204: [2, 348], 211: [2, 700], 594: [2, 1147], 656: [2, 1112], 657: [2, 1113], 713: [2, 701], 783: [2, 1078], 784: [2, 1079], 930: [2, 451], 931: [2, 452], 932: [2, 453], 991: [2, 702], 1294: [2, 1157], 1381: [2, 1065], 1440: [2, 1155], 1549: [2, 512], 1745: [2, 1057], 1790: [2, 1105], 1810: [2, 1123], 1813: [2, 1129], 1855: [2, 1107], 1858: [2, 76], 1900: [2, 528] }, parseError: function(e5, t5) {
          var s5;
          if (!t5.recoverable)
            throw (s5 = new Error(e5)).hash = t5, s5;
          this.trace(e5);
        }, parse: function(e5) {
          var t5, s5 = this, n5 = [0], r5 = [null], a5 = [], i5 = this.table, o5 = "", u5 = 0, l5 = 0, c5 = 0, h5 = 2, d5 = 1, f5 = a5.slice.call(arguments, 1), p5 = Object.create(this.lexer), b5 = { yy: {} };
          for (t5 in this.yy)
            Object.prototype.hasOwnProperty.call(this.yy, t5) && (b5.yy[t5] = this.yy[t5]);
          p5.setInput(e5, b5.yy), b5.yy.lexer = p5, b5.yy.parser = this, void 0 === p5.yylloc && (p5.yylloc = {});
          var E5 = p5.yylloc, g5 = (a5.push(E5), p5.options && p5.options.ranges);
          "function" == typeof b5.yy.parseError ? this.parseError = b5.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
          for (var m5, T5, S5, A5, y5, v5, N5, O5, C5 = function() {
            var e6 = p5.lex() || d5;
            return e6 = "number" != typeof e6 ? s5.symbols_[e6] || e6 : e6;
          }, R5 = {}; ; ) {
            if (S5 = n5[n5.length - 1], void 0 === (A5 = this.defaultActions[S5] || (null == m5 && (m5 = C5()), i5[S5] && i5[S5][m5])) || !A5.length || !A5[0]) {
              var I5, w5 = "", $5 = function(e6) {
                for (var t6 = n5.length - 1, s6 = 0; ; ) {
                  if (h5.toString() in i5[e6])
                    return s6;
                  if (0 === e6 || t6 < 2)
                    return false;
                  e6 = n5[t6 -= 2], ++s6;
                }
              };
              if (c5)
                T5 !== d5 && (I5 = $5(S5));
              else {
                for (y5 in I5 = $5(S5), O5 = [], i5[S5])
                  this.terminals_[y5] && h5 < y5 && O5.push("'" + this.terminals_[y5] + "'");
                w5 = p5.showPosition ? "Parse error on line " + (u5 + 1) + ":\n" + p5.showPosition() + "\nExpecting " + O5.join(", ") + ", got '" + (this.terminals_[m5] || m5) + "'" : "Parse error on line " + (u5 + 1) + ": Unexpected " + (m5 == d5 ? "end of input" : "'" + (this.terminals_[m5] || m5) + "'"), this.parseError(w5, { text: p5.match, token: this.terminals_[m5] || m5, line: p5.yylineno, loc: E5, expected: O5, recoverable: false !== I5 });
              }
              if (3 == c5) {
                if (m5 === d5 || T5 === d5)
                  throw new Error(w5 || "Parsing halted while starting to recover from another error.");
                l5 = p5.yyleng, o5 = p5.yytext, u5 = p5.yylineno, E5 = p5.yylloc, m5 = C5();
              }
              if (false === I5)
                throw new Error(w5 || "Parsing halted. No suitable error recovery rule available.");
              $5 = I5, n5.length = n5.length - 2 * $5, r5.length = r5.length - $5, a5.length = a5.length - $5, T5 = m5 == h5 ? null : m5, m5 = h5, S5 = n5[n5.length - 1], A5 = i5[S5] && i5[S5][h5], c5 = 3;
            }
            if (A5[0] instanceof Array && 1 < A5.length)
              throw new Error("Parse Error: multiple actions possible at state: " + S5 + ", token: " + m5);
            switch (A5[0]) {
              case 1:
                n5.push(m5), r5.push(p5.yytext), a5.push(p5.yylloc), n5.push(A5[1]), m5 = null, T5 ? (m5 = T5, T5 = null) : (l5 = p5.yyleng, o5 = p5.yytext, u5 = p5.yylineno, E5 = p5.yylloc, 0 < c5 && c5--);
                break;
              case 2:
                if (v5 = this.productions_[A5[1]][1], R5.$ = r5[r5.length - v5], R5._$ = { first_line: a5[a5.length - (v5 || 1)].first_line, last_line: a5[a5.length - 1].last_line, first_column: a5[a5.length - (v5 || 1)].first_column, last_column: a5[a5.length - 1].last_column }, g5 && (R5._$.range = [a5[a5.length - (v5 || 1)].range[0], a5[a5.length - 1].range[1]]), void 0 !== (N5 = this.performAction.apply(R5, [o5, l5, u5, b5.yy, A5[1], r5, a5].concat(f5))))
                  return N5;
                v5 && (n5 = n5.slice(0, -1 * v5 * 2), r5 = r5.slice(0, -1 * v5), a5 = a5.slice(0, -1 * v5)), n5.push(this.productions_[A5[1]][0]), r5.push(R5.$), a5.push(R5._$), N5 = i5[n5[n5.length - 2]][n5[n5.length - 1]], n5.push(N5);
                break;
              case 3:
                return true;
            }
          }
          return true;
        } }, ds = ["A", "ABSENT", "ABSOLUTE", "ACCORDING", "ACTION", "ADA", "ADD", "ADMIN", "AFTER", "ALWAYS", "ASC", "ASSERTION", "ASSIGNMENT", "ATTRIBUTE", "ATTRIBUTES", "BASE64", "BEFORE", "BERNOULLI", "BLOCKED", "BOM", "BREADTH", "C", "CASCADE", "CATALOG", "CATALOG_NAME", "CHAIN", "CHARACTERISTICS", "CHARACTERS", "CHARACTER_SET_CATALOG", "CHARACTER_SET_NAME", "CHARACTER_SET_SCHEMA", "CLASS_ORIGIN", "COBOL", "COLLATION", "COLLATION_CATALOG", "COLLATION_NAME", "COLLATION_SCHEMA", "COLUMNS", "COLUMN_NAME", "COMMAND_FUNCTION", "COMMAND_FUNCTION_CODE", "COMMITTED", "CONDITION_NUMBER", "CONNECTION", "CONNECTION_NAME", "CONSTRAINTS", "CONSTRAINT_CATALOG", "CONSTRAINT_NAME", "CONSTRAINT_SCHEMA", "CONSTRUCTOR", "CONTENT", "CONTINUE", "CONTROL", "CURSOR_NAME", "DATA", "DATETIME_INTERVAL_CODE", "DATETIME_INTERVAL_PRECISION", "DB", "DEFAULTS", "DEFERRABLE", "DEFERRED", "DEFINED", "DEFINER", "DEGREE", "DEPTH", "DERIVED", "DESC", "DESCRIPTOR", "DIAGNOSTICS", "DISPATCH", "DOCUMENT", "DOMAIN", "DYNAMIC_FUNCTION", "DYNAMIC_FUNCTION_CODE", "EMPTY", "ENCODING", "ENFORCED", "EXCLUDE", "EXCLUDING", "EXPRESSION", "FILE", "FINAL", "FIRST", "FLAG", "FOLLOWING", "FORTRAN", "FOUND", "FS", "G", "GENERAL", "GENERATED", "GO", "GOTO", "GRANTED", "HEX", "HIERARCHY", "ID", "IGNORE", "IMMEDIATE", "IMMEDIATELY", "IMPLEMENTATION", "INCLUDING", "INCREMENT", "INDENT", "INITIALLY", "INPUT", "INSTANCE", "INSTANTIABLE", "INSTEAD", "INTEGRITY", "INVOKER", "ISOLATION", "K", "KEY", "KEY_MEMBER", "KEY_TYPE", "LAST", "LENGTH", "LEVEL", "LIBRARY", "LIMIT", "LINK", "LOCATION", "LOCATOR", "M", "MAP", "MAPPING", "MATCHED", "MAXVALUE", "MESSAGE_LENGTH", "MESSAGE_OCTET_LENGTH", "MESSAGE_TEXT", "MINVALUE", "MORE", "MUMPS", "NAME", "NAMES", "NAMESPACE", "NESTING", "NEXT", "NFC", "NFD", "NFKC", "NFKD", "NIL", "NORMALIZED", "NULLABLE", "NULLS", "NUMBER", "OBJECT", "OCTETS", "OFF", "OPTION", "OPTIONS", "ORDERING", "ORDINALITY", "OTHERS", "OUTPUT", "OVERRIDING", "P", "PAD", "PARAMETER_MODE", "PARAMETER_NAME", "PARAMETER_ORDINAL_POSITION", "PARAMETER_SPECIFIC_CATALOG", "PARAMETER_SPECIFIC_NAME", "PARAMETER_SPECIFIC_SCHEMA", "PARTIAL", "PASCAL", "PASSING", "PASSTHROUGH", "PATH", "PERMISSION", "PLACING", "PLI", "PRECEDING", "PRESERVE", "PRIOR", "PRIVILEGES", "PUBLIC", "READ", "RECOVERY", "RELATIVE", "REPEATABLE", "REQUIRING", "RESPECT", "RESTART", "RESTORE", "RESTRICT", "RETURNED_CARDINALITY", "RETURNED_LENGTH", "RETURNED_OCTET_LENGTH", "RETURNED_SQLSTATE", "RETURNING", "ROLE", "ROUTINE", "ROUTINE_CATALOG", "ROUTINE_NAME", "ROUTINE_SCHEMA", "ROW_COUNT", "SCALE", "SCHEMA", "SCHEMA_NAME", "SCOPE_CATALOG", "SCOPE_NAME", "SCOPE_SCHEMA", "SECTION", "SECURITY", "SELECTIVE", "SELF", "SEQUENCE", "SERIALIZABLE", "SERVER", "SERVER_NAME", "SESSION", "SETS", "SIMPLE", "SIZE", "SOURCE", "SPACE", "SPECIFIC_NAME", "STANDALONE", "STATE", "STATEMENT", "STRIP", "STRUCTURE", "STYLE", "SUBCLASS_ORIGIN", "T", "TABLE_NAME", "TEMPORARY", "TIES", "TOKEN", "TOP_LEVEL_COUNT", "TRANSACTION", "TRANSACTIONS_COMMITTED", "TRANSACTIONS_ROLLED_BACK", "TRANSACTION_ACTIVE", "TRANSFORM", "TRANSFORMS", "TRIGGER_CATALOG", "TRIGGER_NAME", "TRIGGER_SCHEMA", "TYPE", "UNBOUNDED", "UNCOMMITTED", "UNDER", "UNLINK", "UNNAMED", "UNTYPED", "URI", "USAGE", "USER_DEFINED_TYPE_CATALOG", "USER_DEFINED_TYPE_CODE", "USER_DEFINED_TYPE_NAME", "USER_DEFINED_TYPE_SCHEMA", "VALID", "VERSION", "VIEW", "WHITESPACE", "WORK", "WRAPPER", "WRITE", "XMLDECLARATION", "XMLSCHEMA", "YES", "ZONE"], _.parseError = function(e5, t5) {
          if (!(t5.expected && -1 < t5.expected.indexOf("'LITERAL'") && /[a-zA-Z_][a-zA-Z_0-9]*/.test(t5.token) && -1 < ds.indexOf(t5.token)))
            throw new SyntaxError(e5);
        }, _.lexer = o2 = { EOF: 1, parseError: function(e5, t5) {
          if (!this.yy.parser)
            throw new Error(e5);
          this.yy.parser.parseError(e5, t5);
        }, setInput: function(e5, t5) {
          return this.yy = t5 || this.yy || {}, this._input = e5, this._more = this._backtrack = this.done = false, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
        }, input: function() {
          var e5 = this._input[0];
          return this.yytext += e5, this.yyleng++, this.offset++, this.match += e5, this.matched += e5, e5.match(/(?:\r\n?|\n).*/g) ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), e5;
        }, unput: function(e5) {
          var t5 = e5.length, s5 = e5.split(/(?:\r\n?|\n)/g), e5 = (this._input = e5 + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - t5), this.offset -= t5, this.match.split(/(?:\r\n?|\n)/g)), n5 = (this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), s5.length - 1 && (this.yylineno -= s5.length - 1), this.yylloc.range);
          return this.yylloc = { first_line: this.yylloc.first_line, last_line: this.yylineno + 1, first_column: this.yylloc.first_column, last_column: s5 ? (s5.length === e5.length ? this.yylloc.first_column : 0) + e5[e5.length - s5.length].length - s5[0].length : this.yylloc.first_column - t5 }, this.options.ranges && (this.yylloc.range = [n5[0], n5[0] + this.yyleng - t5]), this.yyleng = this.yytext.length, this;
        }, more: function() {
          return this._more = true, this;
        }, reject: function() {
          return this.options.backtrack_lexer ? (this._backtrack = true, this) : this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), { text: "", token: null, line: this.yylineno });
        }, less: function(e5) {
          this.unput(this.match.slice(e5));
        }, pastInput: function() {
          var e5 = this.matched.substr(0, this.matched.length - this.match.length);
          return (20 < e5.length ? "..." : "") + e5.substr(-20).replace(/\n/g, "");
        }, upcomingInput: function() {
          var e5 = this.match;
          return e5.length < 20 && (e5 += this._input.substr(0, 20 - e5.length)), (e5.substr(0, 20) + (20 < e5.length ? "..." : "")).replace(/\n/g, "");
        }, showPosition: function() {
          var e5 = this.pastInput(), t5 = new Array(e5.length + 1).join("-");
          return e5 + this.upcomingInput() + "\n" + t5 + "^";
        }, test_match: function(e5, t5) {
          var s5, n5;
          if (this.options.backtrack_lexer && (n5 = { yylineno: this.yylineno, yylloc: { first_line: this.yylloc.first_line, last_line: this.last_line, first_column: this.yylloc.first_column, last_column: this.yylloc.last_column }, yytext: this.yytext, match: this.match, matches: this.matches, matched: this.matched, yyleng: this.yyleng, offset: this.offset, _more: this._more, _input: this._input, yy: this.yy, conditionStack: this.conditionStack.slice(0), done: this.done }, this.options.ranges) && (n5.yylloc.range = this.yylloc.range.slice(0)), (s5 = e5[0].match(/(?:\r\n?|\n).*/g)) && (this.yylineno += s5.length), this.yylloc = { first_line: this.yylloc.last_line, last_line: this.yylineno + 1, first_column: this.yylloc.last_column, last_column: s5 ? s5[s5.length - 1].length - s5[s5.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + e5[0].length }, this.yytext += e5[0], this.match += e5[0], this.matches = e5, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = false, this._backtrack = false, this._input = this._input.slice(e5[0].length), this.matched += e5[0], s5 = this.performAction.call(this, this.yy, this, t5, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = false), s5)
            return s5;
          if (this._backtrack)
            for (var r5 in n5)
              this[r5] = n5[r5];
          return false;
        }, next: function() {
          if (this.done)
            return this.EOF;
          this._input || (this.done = true), this._more || (this.yytext = "", this.match = "");
          for (var e5, t5, s5, n5, r5 = this._currentRules(), a5 = 0; a5 < r5.length; a5++)
            if ((s5 = this._input.match(this.rules[r5[a5]])) && (!t5 || s5[0].length > t5[0].length)) {
              if (t5 = s5, n5 = a5, this.options.backtrack_lexer) {
                if (false !== (e5 = this.test_match(s5, r5[a5])))
                  return e5;
                if (!this._backtrack)
                  return false;
                t5 = false;
              } else if (!this.options.flex)
                break;
            }
          return t5 ? false !== (e5 = this.test_match(t5, r5[n5])) && e5 : "" === this._input ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), { text: "", token: null, line: this.yylineno });
        }, lex: function() {
          var e5 = this.next();
          return e5 || this.lex();
        }, begin: function(e5) {
          this.conditionStack.push(e5);
        }, popState: function() {
          return 0 < this.conditionStack.length - 1 ? this.conditionStack.pop() : this.conditionStack[0];
        }, _currentRules: function() {
          return (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]] : this.conditions.INITIAL).rules;
        }, topState: function(e5) {
          return 0 <= (e5 = this.conditionStack.length - 1 - Math.abs(e5 || 0)) ? this.conditionStack[e5] : "INITIAL";
        }, pushState: function(e5) {
          this.begin(e5);
        }, stateStackSize: function() {
          return this.conditionStack.length;
        }, options: { "case-insensitive": true }, performAction: function(e5, t5, s5, n5) {
          switch (s5) {
            case 0:
              return 270;
            case 1:
              return 306;
            case 2:
              return 424;
            case 3:
              return 303;
            case 4:
            case 5:
              return 5;
            case 6:
            case 7:
              return 300;
            case 8:
            case 9:
              return 132;
            case 10:
              return;
            case 11:
              break;
            case 12:
              return 320;
            case 13:
              return 323;
            case 14:
              return t5.yytext = "VALUE", 89;
            case 15:
              return t5.yytext = "VALUE", 189;
            case 16:
              return t5.yytext = "ROW", 189;
            case 17:
              return t5.yytext = "COLUMN", 189;
            case 18:
              return t5.yytext = "MATRIX", 189;
            case 19:
              return t5.yytext = "INDEX", 189;
            case 20:
              return t5.yytext = "RECORDSET", 189;
            case 21:
              return t5.yytext = "TEXT", 189;
            case 22:
              return t5.yytext = "SELECT", 189;
            case 23:
              return 524;
            case 24:
              return 385;
            case 25:
              return 406;
            case 26:
              return 519;
            case 27:
              return 290;
            case 28:
            case 29:
              return 273;
            case 30:
              return 164;
            case 31:
              return 404;
            case 32:
              return 170;
            case 33:
              return 229;
            case 34:
              return 166;
            case 35:
              return 207;
            case 36:
              return 291;
            case 37:
              return 76;
            case 38:
              return 422;
            case 39:
              return 246;
            case 40:
              return 408;
            case 41:
              return 360;
            case 42:
              return 289;
            case 43:
              return 518;
            case 44:
              return 441;
            case 45:
              return 334;
            case 46:
              return 445;
            case 47:
              return 335;
            case 48:
              return 319;
            case 49:
              return 119;
            case 50:
              return 112;
            case 51:
              return 319;
            case 52:
              return 112;
            case 53:
              return 319;
            case 54:
              return 112;
            case 55:
              return 319;
            case 56:
              return 512;
            case 57:
              return 307;
            case 58:
              return 275;
            case 59:
              return 372;
            case 60:
              return 130;
            case 61:
              return "CLOSE";
            case 62:
              return 247;
            case 63:
            case 64:
              return 190;
            case 65:
              return 438;
            case 66:
              return 371;
            case 67:
              return 474;
            case 68:
              return 444;
            case 69:
              return 277;
            case 70:
              return 240;
            case 71:
              return 286;
            case 72:
              return 271;
            case 73:
              return 206;
            case 74:
              return 238;
            case 75:
              return 269;
            case 76:
              return "CURSOR";
            case 77:
              return 409;
            case 78:
              return 294;
            case 79:
              return 295;
            case 80:
              return 296;
            case 81:
              return 452;
            case 82:
              return 347;
            case 83:
              return 342;
            case 84:
              return "DELETED";
            case 85:
              return 246;
            case 86:
              return 410;
            case 87:
              return 185;
            case 88:
              return 400;
            case 89:
              return 451;
            case 90:
              return 135;
            case 91:
              return 310;
            case 92:
              return 393;
            case 93:
              return 314;
            case 94:
              return 318;
            case 95:
              return 169;
            case 96:
            case 97:
              return 512;
            case 98:
              return 302;
            case 99:
              return 14;
            case 100:
              return 299;
            case 101:
              return 253;
            case 102:
              return 244;
            case 103:
              return 95;
            case 104:
              return 377;
            case 105:
              return 183;
            case 106:
              return 227;
            case 107:
              return 272;
            case 108:
              return 317;
            case 109:
              return 606;
            case 110:
              return 476;
            case 111:
              return 232;
            case 112:
              return 236;
            case 113:
              return 239;
            case 114:
              return 156;
            case 115:
              return 360;
            case 116:
              return 336;
            case 117:
              return 99;
            case 118:
              return 193;
            case 119:
              return 212;
            case 120:
              return 224;
            case 121:
              return 520;
            case 122:
              return 343;
            case 123:
              return 213;
            case 124:
              return 168;
            case 125:
              return 297;
            case 126:
              return 198;
            case 127:
              return 223;
            case 128:
              return 374;
            case 129:
              return 245;
            case 130:
              return "LET";
            case 131:
              return 225;
            case 132:
              return 112;
            case 133:
              return 249;
            case 134:
              return 464;
            case 135:
              return 191;
            case 136:
              return 288;
            case 137:
              return 394;
            case 138:
              return 287;
            case 139:
              return 456;
            case 140:
              return 169;
            case 141:
              return 407;
            case 142:
              return 222;
            case 143:
              return 649;
            case 144:
              return 274;
            case 145:
              return 248;
            case 146:
              return 384;
            case 147:
              return 154;
            case 148:
              return 301;
            case 149:
              return 243;
            case 150:
              return 437;
            case 151:
              return 230;
            case 152:
              return 419;
            case 153:
              return 129;
            case 154:
              return 251;
            case 155:
              return "OPEN";
            case 156:
              return 420;
            case 157:
              return 171;
            case 158:
              return 118;
            case 159:
              return 208;
            case 160:
              return 280;
            case 161:
              return 172;
            case 162:
              return 283;
            case 163:
              return 768;
            case 164:
              return 93;
            case 165:
              return 16;
            case 166:
              return 373;
            case 167:
              return 446;
            case 168:
              return 681;
            case 169:
              return 15;
            case 170:
              return 418;
            case 171:
              return 194;
            case 172:
              return "REDUCE";
            case 173:
              return 378;
            case 174:
              return 315;
            case 175:
              return 521;
            case 176:
              return 685;
            case 177:
              return 107;
            case 178:
              return 405;
            case 179:
              return 175;
            case 180:
              return 293;
            case 181:
              return 447;
            case 182:
              return 690;
            case 183:
            case 184:
              return 173;
            case 185:
              return 226;
            case 186:
              return 440;
            case 187:
              return 237;
            case 188:
              return 150;
            case 189:
              return 769;
            case 190:
              return 409;
            case 191:
              return 89;
            case 192:
              return 228;
            case 193:
            case 194:
              return 146;
            case 195:
              return 413;
            case 196:
              return 338;
            case 197:
              return 421;
            case 198:
              return "STRATEGY";
            case 199:
              return "STORE";
            case 200:
              return 284;
            case 201:
              return 285;
            case 202:
            case 203:
              return 357;
            case 204:
              return 467;
            case 205:
            case 206:
              return 361;
            case 207:
              return 192;
            case 208:
              return 313;
            case 209:
              return "TIMEOUT";
            case 210:
              return 148;
            case 211:
              return 195;
            case 212:
            case 213:
              return 439;
            case 214:
              return 513;
            case 215:
              return 298;
            case 216:
              return 455;
            case 217:
              return 162;
            case 218:
              return 187;
            case 219:
              return 98;
            case 220:
              return 339;
            case 221:
              return 412;
            case 222:
              return 231;
            case 223:
              return 149;
            case 224:
              return 348;
            case 225:
              return 134;
            case 226:
              return 414;
            case 227:
              return 312;
            case 228:
              return 128;
            case 229:
              return 443;
            case 230:
              return 72;
            case 231:
              return 439;
            case 232:
            case 233:
              return 131;
            case 234:
              return 115;
            case 235:
              return 137;
            case 236:
              return 179;
            case 237:
              return 321;
            case 238:
              return 180;
            case 239:
              return 133;
            case 240:
              return 138;
            case 241:
              return 330;
            case 242:
              return 327;
            case 243:
              return 329;
            case 244:
              return 326;
            case 245:
              return 324;
            case 246:
              return 322;
            case 247:
              return 323;
            case 248:
              return 142;
            case 249:
              return 141;
            case 250:
              return 139;
            case 251:
              return 325;
            case 252:
              return 328;
            case 253:
              return 140;
            case 254:
              return 124;
            case 255:
              return 328;
            case 256:
              return 77;
            case 257:
              return 78;
            case 258:
              return 145;
            case 259:
              return 428;
            case 260:
              return 430;
            case 261:
              return 304;
            case 262:
              return 509;
            case 263:
              return 511;
            case 264:
              return 122;
            case 265:
              return 116;
            case 266:
              return 74;
            case 267:
              return 337;
            case 268:
              return 152;
            case 269:
              return 767;
            case 270:
              return 143;
            case 271:
              return 181;
            case 272:
              return 136;
            case 273:
              return 123;
            case 274:
              return 316;
            case 275:
              return 4;
            case 276:
              return 10;
            case 277:
              return "INVALID";
          }
        }, rules: [/^(?:``([^\`])+``)/i, /^(?:\[\?\])/i, /^(?:@\[)/i, /^(?:ARRAY\[)/i, /^(?:\[([^\]'])*?\])/i, /^(?:`([^\`'])*?`)/i, /^(?:N(['](\\.|[^']|\\')*?['])+)/i, /^(?:X(['](\\.|[^']|\\')*?['])+)/i, /^(?:(['](\\.|[^']|\\')*?['])+)/i, /^(?:(["](\\.|[^"]|\\")*?["])+)/i, /^(?:--(.*?)($|\r\n|\r|\n))/i, /^(?:\s+)/i, /^(?:\|\|)/i, /^(?:\|)/i, /^(?:VALUE\s+OF\s+SEARCH\b)/i, /^(?:VALUE\s+OF\s+SELECT\b)/i, /^(?:ROW\s+OF\s+SELECT\b)/i, /^(?:COLUMN\s+OF\s+SELECT\b)/i, /^(?:MATRIX\s+OF\s+SELECT\b)/i, /^(?:INDEX\s+OF\s+SELECT\b)/i, /^(?:RECORDSET\s+OF\s+SELECT\b)/i, /^(?:TEXT\s+OF\s+SELECT\b)/i, /^(?:SELECT\b)/i, /^(?:ABSOLUTE\b)/i, /^(?:ACTION\b)/i, /^(?:ADD\b)/i, /^(?:AFTER\b)/i, /^(?:AGGR\b)/i, /^(?:AGGREGATE\b)/i, /^(?:AGGREGATOR\b)/i, /^(?:ALL\b)/i, /^(?:ALTER\b)/i, /^(?:AND\b)/i, /^(?:ANTI\b)/i, /^(?:ANY\b)/i, /^(?:APPLY\b)/i, /^(?:ARRAY\b)/i, /^(?:AS\b)/i, /^(?:ASSERT\b)/i, /^(?:ASC\b)/i, /^(?:ATTACH\b)/i, /^(?:AUTO(_)?INCREMENT\b)/i, /^(?:AVG\b)/i, /^(?:BEFORE\b)/i, /^(?:BEGIN\b)/i, /^(?:BETWEEN\b)/i, /^(?:BREAK\b)/i, /^(?:NOT\s+BETWEEN\b)/i, /^(?:NOT\s+LIKE\b)/i, /^(?:BY\b)/i, /^(?:~~\*)/i, /^(?:!~~\*)/i, /^(?:~~)/i, /^(?:!~~)/i, /^(?:ILIKE\b)/i, /^(?:NOT\s+ILIKE\b)/i, /^(?:CALL\b)/i, /^(?:CASE\b)/i, /^(?:CAST\b)/i, /^(?:CHECK\b)/i, /^(?:CLASS\b)/i, /^(?:CLOSE\b)/i, /^(?:COLLATE\b)/i, /^(?:COLUMN\b)/i, /^(?:COLUMNS\b)/i, /^(?:COMMIT\b)/i, /^(?:CONSTRAINT\b)/i, /^(?:CONTENT\b)/i, /^(?:CONTINUE\b)/i, /^(?:CONVERT\b)/i, /^(?:CORRESPONDING\b)/i, /^(?:COUNT\b)/i, /^(?:CREATE\b)/i, /^(?:CROSS\b)/i, /^(?:CUBE\b)/i, /^(?:CURRENT_TIMESTAMP\b)/i, /^(?:CURSOR\b)/i, /^(?:DATABASE(S)?)/i, /^(?:DATEADD\b)/i, /^(?:DATEDIFF\b)/i, /^(?:TIMESTAMPDIFF\b)/i, /^(?:DECLARE\b)/i, /^(?:DEFAULT\b)/i, /^(?:DELETE\b)/i, /^(?:DELETED\b)/i, /^(?:DESC\b)/i, /^(?:DETACH\b)/i, /^(?:DISTINCT\b)/i, /^(?:DROP\b)/i, /^(?:ECHO\b)/i, /^(?:EDGE\b)/i, /^(?:END\b)/i, /^(?:ENUM\b)/i, /^(?:ELSE\b)/i, /^(?:ESCAPE\b)/i, /^(?:EXCEPT\b)/i, /^(?:EXEC\b)/i, /^(?:EXECUTE\b)/i, /^(?:EXISTS\b)/i, /^(?:EXPLAIN\b)/i, /^(?:FALSE\b)/i, /^(?:FETCH\b)/i, /^(?:FIRST\b)/i, /^(?:FOR\b)/i, /^(?:FOREIGN\b)/i, /^(?:FROM\b)/i, /^(?:FULL\b)/i, /^(?:FUNCTION\b)/i, /^(?:GLOB\b)/i, /^(?:GO\b)/i, /^(?:GRAPH\b)/i, /^(?:GROUP\b)/i, /^(?:GROUPING\b)/i, /^(?:HAVING\b)/i, /^(?:IF\b)/i, /^(?:IDENTITY\b)/i, /^(?:IS\b)/i, /^(?:IN\b)/i, /^(?:INDEX\b)/i, /^(?:INDEXED\b)/i, /^(?:INNER\b)/i, /^(?:INSTEAD\b)/i, /^(?:INSERT\b)/i, /^(?:INSERTED\b)/i, /^(?:INTERSECT\b)/i, /^(?:INTERVAL\b)/i, /^(?:INTO\b)/i, /^(?:JOIN\b)/i, /^(?:KEY\b)/i, /^(?:LAST\b)/i, /^(?:LET\b)/i, /^(?:LEFT\b)/i, /^(?:LIKE\b)/i, /^(?:LIMIT\b)/i, /^(?:MATCHED\b)/i, /^(?:MATRIX\b)/i, /^(?:MAX(\s+)?(?=\())/i, /^(?:MAX(\s+)?(?=(,|\))))/i, /^(?:MIN(\s+)?(?=\())/i, /^(?:MERGE\b)/i, /^(?:MINUS\b)/i, /^(?:MODIFY\b)/i, /^(?:NATURAL\b)/i, /^(?:NEXT\b)/i, /^(?:NEW\b)/i, /^(?:NOCASE\b)/i, /^(?:NO\b)/i, /^(?:NOT\b)/i, /^(?:NULL\b)/i, /^(?:NULLS\b)/i, /^(?:OFF\b)/i, /^(?:ON\b)/i, /^(?:ONLY\b)/i, /^(?:OF\b)/i, /^(?:OFFSET\b)/i, /^(?:OPEN\b)/i, /^(?:OPTION\b)/i, /^(?:OR\b)/i, /^(?:ORDER\b)/i, /^(?:OUTER\b)/i, /^(?:OVER\b)/i, /^(?:PATH\b)/i, /^(?:PARTITION\b)/i, /^(?:PERCENT\b)/i, /^(?:PIVOT\b)/i, /^(?:PLAN\b)/i, /^(?:PRIMARY\b)/i, /^(?:PRINT\b)/i, /^(?:PRIOR\b)/i, /^(?:QUERY\b)/i, /^(?:READ\b)/i, /^(?:RECORDSET\b)/i, /^(?:REDUCE\b)/i, /^(?:REFERENCES\b)/i, /^(?:REGEXP\b)/i, /^(?:REINDEX\b)/i, /^(?:RELATIVE\b)/i, /^(?:REMOVE\b)/i, /^(?:RENAME\b)/i, /^(?:REPEAT\b)/i, /^(?:REPLACE\b)/i, /^(?:REQUIRE\b)/i, /^(?:RESTORE\b)/i, /^(?:RETURN\b)/i, /^(?:RETURNS\b)/i, /^(?:RIGHT\b)/i, /^(?:ROLLBACK\b)/i, /^(?:ROLLUP\b)/i, /^(?:ROW\b)/i, /^(?:ROWS\b)/i, /^(?:SCHEMA(S)?)/i, /^(?:SEARCH\b)/i, /^(?:SEMI\b)/i, /^(?:SET\b)/i, /^(?:SETS\b)/i, /^(?:SHOW\b)/i, /^(?:SOME\b)/i, /^(?:SOURCE\b)/i, /^(?:STRATEGY\b)/i, /^(?:STORE\b)/i, /^(?:SUM\b)/i, /^(?:TOTAL\b)/i, /^(?:TABLE\b)/i, /^(?:TABLES\b)/i, /^(?:TARGET\b)/i, /^(?:TEMP\b)/i, /^(?:TEMPORARY\b)/i, /^(?:TEXTSTRING\b)/i, /^(?:THEN\b)/i, /^(?:TIMEOUT\b)/i, /^(?:TO\b)/i, /^(?:TOP\b)/i, /^(?:TRAN\b)/i, /^(?:TRANSACTION\b)/i, /^(?:TRIGGER\b)/i, /^(?:TRUE\b)/i, /^(?:TRUNCATE\b)/i, /^(?:UNION\b)/i, /^(?:UNIQUE\b)/i, /^(?:UNPIVOT\b)/i, /^(?:UPDATE\b)/i, /^(?:USE\b)/i, /^(?:USING\b)/i, /^(?:VALUE\b)/i, /^(?:VALUES\b)/i, /^(?:VERTEX\b)/i, /^(?:VIEW\b)/i, /^(?:WHEN\b)/i, /^(?:WHERE\b)/i, /^(?:WHILE\b)/i, /^(?:WITH\b)/i, /^(?:WORK\b)/i, /^(?:(\d*[.])?\d+[eE]\d+)/i, /^(?:(\d*[.])?\d+)/i, /^(?:->)/i, /^(?:#)/i, /^(?:\+)/i, /^(?:-)/i, /^(?:\*)/i, /^(?:\/)/i, /^(?:%)/i, /^(?:!===)/i, /^(?:===)/i, /^(?:!==)/i, /^(?:==)/i, /^(?:>=)/i, /^(?:&)/i, /^(?:\|)/i, /^(?:<<)/i, /^(?:>>)/i, /^(?:>)/i, /^(?:<=)/i, /^(?:<>)/i, /^(?:<)/i, /^(?:=)/i, /^(?:!=)/i, /^(?:\()/i, /^(?:\))/i, /^(?:@)/i, /^(?:\{)/i, /^(?:\})/i, /^(?:\])/i, /^(?::-)/i, /^(?:\?-)/i, /^(?:\.\.)/i, /^(?:\.)/i, /^(?:,)/i, /^(?:::)/i, /^(?::)/i, /^(?:;)/i, /^(?:\$)/i, /^(?:\?)/i, /^(?:!)/i, /^(?:\^)/i, /^(?:~)/i, /^(?:[0-9]*[a-zA-Z_]+[a-zA-Z_0-9]*)/i, /^(?:$)/i, /^(?:.)/i], conditions: { INITIAL: { rules: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277], inclusive: true } } }, new ((ps.prototype = _).Parser = ps)());
        function D(e5, t5, s5, n5) {
          for (s5 = s5 || {}, n5 = e5.length; n5--; s5[e5[n5]] = t5)
            ;
          return s5;
        }
        function ps() {
          this.yy = {};
        }
        void 0 !== U && "undefined" != typeof exports && (exports.parser = fs, exports.Parser = fs.Parser, exports.parse = function() {
          return fs.parse.apply(fs, arguments);
        }, exports.main = function(e5) {
          e5[1] || (console.log("Usage: " + e5[0] + " FILE"), process.exit(1));
          e5 = U().readFileSync(U().normalize(e5[1]), "utf8");
          return exports.parser.parse(e5);
        }, "undefined" != typeof module) && U.main === module && exports.main(process.argv.slice(1)), L.prettyflag = false, L.pretty = function(e5, t5) {
          var s5 = L.prettyflag, t5 = (L.prettyflag = !t5, L.parse(e5).toString());
          return L.prettyflag = s5, t5;
        };
        var bs = L.utils = {};
        function Es(e5) {
          return "(y=" + e5 + ",y===y?y:undefined)";
        }
        function gs(e5, t5) {
          return "(y=" + e5 + ',typeof y=="undefined"?undefined:' + t5 + ")";
        }
        function ms() {
          return true;
        }
        function Ts(e5) {
          return e5 = e5[0] === String.fromCharCode(65279) ? e5.substr(1) : e5;
        }
        var Ss = bs.escapeq = function(e5) {
          return ("" + e5).replace(/["'\\\n\r\u2028\u2029]/g, function(e6) {
            switch (e6) {
              case '"':
              case "'":
              case "\\":
                return "\\" + e6;
              case "\n":
                return "\\n";
              case "\r":
                return "\\r";
              case "\u2028":
                return "\\u2028";
              case "\u2029":
                return "\\u2029";
            }
          });
        }, As = bs.undoubleq = function(e5) {
          return e5.replace(/(\')/g, "''");
        }, ys = bs.doubleq = function(e5) {
          return e5.replace(/(\'\')/g, "\\'");
        }, vs = (bs.doubleqq = function(e5) {
          return e5.replace(/\'/g, "'");
        }, bs.global = "undefined" != typeof self ? self : "undefined" != typeof window ? window : "undefined" != typeof global ? global : Function("return this")(), bs.isNativeFunction = function(e5) {
          return "function" == typeof e5 && !!~e5.toString().indexOf("[native code]");
        }, bs.isWebWorker = function() {
          try {
            var e5 = bs.global.importScripts;
            return bs.isNativeFunction(e5);
          } catch (e6) {
            return false;
          }
        }(), bs.isNode = function() {
          try {
            return bs.isNativeFunction(bs.global.process.reallyExit);
          } catch (e5) {
            return false;
          }
        }(), bs.isBrowser = function() {
          try {
            return bs.isNativeFunction(bs.global.location.reload);
          } catch (e5) {
            return false;
          }
        }(), bs.isBrowserify = bs.isBrowser && "undefined" != typeof process && process.browser, bs.isRequireJS = bs.isBrowser && "function" == typeof U.specified, bs.isMeteor = "undefined" != typeof Meteor && Meteor.release, bs.isMeteorClient = bs.isMeteorClient = bs.isMeteor && Meteor.isClient, bs.isMeteorServer = bs.isMeteor && Meteor.isServer, bs.isCordova = "object" == typeof cordova, bs.isReactNative = false, bs.hasIndexedDB = !!bs.global.indexedDB, bs.isArray = function(e5) {
          return "[object Array]" === Object.prototype.toString.call(e5);
        }, bs.loadFile = function(t5, e5, s5, n5) {
          var r5;
          bs.isNode || bs.isMeteorServer || (bs.isCordova ? bs.global.requestFileSystem(LocalFileSystem.PERSISTENT, 0, function(e6) {
            e6.root.getFile(t5, { create: false }, function(e7) {
              e7.file(function(e8) {
                var t6 = new FileReader();
                t6.onloadend = function(e9) {
                  s5(Ts(this.result));
                }, t6.readAsText(e8);
              });
            });
          }) : "string" == typeof t5 ? "#" === t5.substr(0, 1) && "undefined" != typeof document ? (r5 = document.querySelector(t5).textContent, s5(r5)) : async function(e6, t6, s6, n6) {
            if (n6)
              return Os(e6, t6, s6);
            return Os(e6, t6, s6);
          }(t5, (e6) => s5(Ts(e6)), n5, e5) : t5 instanceof Event && (r5 = t5.target.files, n5 = new FileReader(), r5[0].name, n5.onload = function(e6) {
            e6 = e6.target.result;
            s5(Ts(e6));
          }, n5.readAsText(r5[0])));
        });
        let Ns = "undefined" != typeof fetch ? fetch : null;
        function Os(e5, t5, s5) {
          return Ns(e5).then((e6) => e6.arrayBuffer()).then((e6) => {
            e6 = [...new Uint8Array(e6)].map((e7) => String.fromCharCode(e7)).join("");
            t5(e6);
          }).catch((e6) => {
            if (s5)
              return s5(e6);
            throw console.error(e6), e6;
          });
        }
        bs.loadBinaryFile = function(e5, t5, n5, s5 = (e6) => {
          throw e6;
        }) {
          var r5, a5;
          bs.isNode || bs.isMeteorServer || ("string" == typeof e5 ? ((r5 = new XMLHttpRequest()).open("GET", e5, t5), r5.responseType = "arraybuffer", r5.onload = function() {
            for (var e6 = new Uint8Array(r5.response), t6 = [], s6 = 0; s6 < e6.length; ++s6)
              t6[s6] = String.fromCharCode(e6[s6]);
            n5(t6.join(""));
          }, r5.onerror = s5, r5.send()) : e5 instanceof Event ? (t5 = e5.target.files, a5 = new FileReader(), t5[0].name, a5.onload = function(e6) {
            e6 = e6.target.result;
            n5(e6);
          }, a5.onerror = s5, a5.readAsArrayBuffer(t5[0])) : e5 instanceof Blob && n5(e5));
        }, bs.removeFile = function(e5, t5) {
          if (!bs.isNode)
            throw new Error("You can remove files only in Node.js and Apache Cordova");
        }, bs.deleteFile = function(e5, t5) {
        }, bs.autoExtFilename = function(e5, t5, s5) {
          return s5 = s5 || {}, "string" != typeof e5 || e5.match(/^[A-z]+:\/\/|\n|\..{2,4}$/) || 0 === s5.autoExt || false === s5.autoExt ? e5 : e5 + "." + t5;
        }, bs.fileExists = function(e5, t5) {
          if (!bs.isNode)
            throw new Error("You can use exists() only in Node.js or Apach Cordova");
        }, bs.saveFile = function(e5, t5, s5, n5) {
          var r5, a5 = 1;
          return void 0 === e5 ? (a5 = t5, s5 && (a5 = s5(a5))) : bs.isNode || (L.utils.extend(r5 = { disableAutoBom: false }, n5), n5 = new Blob([t5], { type: "text/plain;charset=utf-8" }), yn(n5, e5, r5.disableAutoBom), s5 && (a5 = s5(a5))), a5;
        };
        function Cs() {
          var e5 = L.private.externalXlsxLib || bs.global.XLSX || null;
          if (e5)
            return e5;
          if (bs.isNode || bs.isBrowserify || bs.isMeteorServer, e5)
            return e5;
          throw new Error("Please include the xlsx.js library");
        }
        var Rs = bs.hash = function(e5) {
          for (var t5 = 2166136261, s5 = e5.length; s5; )
            t5 = (t5 ^= e5.charCodeAt(--s5)) + ((t5 << 1) + (t5 << 4) + (t5 << 7) + (t5 << 8) + (t5 << 24));
          return t5;
        }, Is = bs.arrayUnion = function(e5, t5) {
          var s5 = t5.slice(0);
          return e5.forEach(function(e6) {
            s5.indexOf(e6) < 0 && s5.push(e6);
          }), s5;
        }, ws = bs.arrayDiff = function(e5, t5) {
          return e5.filter(function(e6) {
            return t5.indexOf(e6) < 0;
          });
        }, $s = bs.arrayIntersect = function(e5, n5) {
          var r5 = [];
          return e5.forEach(function(t5) {
            var s5 = false;
            n5.forEach(function(e6) {
              s5 = s5 || t5 === e6;
            }), s5 && r5.push(t5);
          }), r5;
        }, xs = bs.arrayUnionDeep = function(e5, t5) {
          var n5 = t5.slice(0);
          return e5.forEach(function(t6) {
            var s5 = false;
            n5.forEach(function(e6) {
              s5 = s5 || Ms(t6, e6);
            }), s5 || n5.push(t6);
          }), n5;
        }, ks = bs.arrayExceptDeep = function(e5, n5) {
          var r5 = [];
          return e5.forEach(function(t5) {
            var s5 = false;
            n5.forEach(function(e6) {
              s5 = s5 || Ms(t5, e6);
            }), s5 || r5.push(t5);
          }), r5;
        }, Ls = bs.arrayIntersectDeep = function(e5, n5) {
          var r5 = [];
          return e5.forEach(function(t5) {
            var s5 = false;
            n5.forEach(function(e6) {
              s5 = s5 || Ms(t5, e6, true);
            }), s5 && r5.push(t5);
          }), r5;
        }, Ds = bs.cloneDeep = function e5(t5) {
          if (null === t5 || "object" != typeof t5)
            return t5;
          if (t5 instanceof Date)
            return new Date(t5);
          if (t5 instanceof String)
            return t5.toString();
          if (t5 instanceof Number)
            return +t5;
          var s5, n5 = new t5.constructor();
          for (s5 in t5)
            t5.hasOwnProperty(s5) && (n5[s5] = e5(t5[s5]));
          return n5;
        }, Ms = bs.deepEqual = function(e5, t5) {
          if (e5 !== t5) {
            if ("object" != typeof e5 || null === e5 || "object" != typeof t5 || null === t5)
              return false;
            if (Object.keys(e5).length !== Object.keys(t5).length)
              return false;
            for (var s5 in e5)
              if (!Ms(e5[s5], t5[s5]))
                return false;
          }
          return true;
        }, Us = bs.distinctArray = function(t5) {
          for (var e5 = {}, s5 = 0, n5 = t5.length; s5 < n5; s5++) {
            var r5 = "object" == typeof t5[s5] ? Object.keys(t5[s5]).sort().map(function(e6) {
              return e6 + "`" + t5[s5][e6];
            }).join("`") : t5[s5];
            e5[r5] = t5[s5];
          }
          var a5, i5 = [];
          for (a5 in e5)
            i5.push(e5[a5]);
          return i5;
        }, Fs = bs.extend = function(e5, t5) {
          for (var s5 in e5 = e5 || {}, t5)
            t5.hasOwnProperty(s5) && (e5[s5] = t5[s5]);
          return e5;
        }, _s = bs.getValueOf = function(e5) {
          return "object" == typeof e5 && (e5 instanceof String || e5 instanceof Number) ? e5.valueOf() : e5;
        }, Ps = bs.flatArray = function(t5) {
          var s5;
          return t5 && 0 !== t5.length ? "object" == typeof t5 && t5 instanceof L.Recordset ? t5.data.map(function(e5) {
            return _s(e5[t5.columns[0].columnid]);
          }) : void 0 === (s5 = Object.keys(t5[0])[0]) ? [] : t5.map(function(e5) {
            return e5[s5];
          }) : [];
        }, qs = (bs.arrayOfArrays = function(e5) {
          return e5.map(function(e6) {
            var t5, s5 = [];
            for (t5 in e6)
              s5.push(e6[t5]);
            return s5;
          });
        }, Array.isArray || (Array.isArray = function(e5) {
          return "[object Array]" === Object.prototype.toString.call(e5);
        }), bs.xlsnc = function(e5) {
          var t5 = "", s5 = (701 < e5 && (t5 = String.fromCharCode(65 + (((e5 - 26) / 676 | 0) - 1) % 26), e5 %= 676), String.fromCharCode(65 + e5 % 26));
          return 26 <= e5 && (e5 = (e5 / 26 | 0) - 1, s5 = String.fromCharCode(65 + e5 % 26) + s5, 26 < e5) && (e5 = (e5 / 26 | 0) - 1, s5 = String.fromCharCode(65 + e5 % 26) + s5), t5 + s5;
        }, bs.xlscn = function(e5) {
          var t5 = e5.charCodeAt(0) - 65;
          return t5 = 1 < e5.length && (t5 = 26 * (t5 + 1) + e5.charCodeAt(1) - 65, 2 < e5.length) ? 26 * (t5 + 1) + e5.charCodeAt(2) - 65 : t5;
        }, bs.domEmptyChildren = function(e5) {
          for (var t5 = e5.childNodes.length; t5--; )
            e5.removeChild(e5.lastChild);
        }, bs.like = function(e5, t5, s5) {
          s5 = s5 || "";
          for (var n5 = 0, r5 = "^"; n5 < e5.length; ) {
            var a5 = e5[n5], i5 = "";
            n5 < e5.length - 1 && (i5 = e5[n5 + 1]), a5 === s5 ? (r5 += "\\" + i5, n5++) : "[" === a5 && "^" === i5 ? (r5 += "[^", n5++) : "[" === a5 || "]" === a5 ? r5 += a5 : "%" === a5 ? r5 += ".*" : "_" === a5 ? r5 += "." : -1 < "/.*+?|(){}".indexOf(a5) ? r5 += "\\" + a5 : r5 += a5, n5++;
          }
          return r5 += "$", -1 < ("" + (t5 || "")).toUpperCase().search(RegExp(r5.toUpperCase()));
        }, bs.glob = function(e5, t5) {
          for (var s5 = 0, n5 = "^"; s5 < t5.length; ) {
            var r5 = t5[s5], a5 = "";
            s5 < t5.length - 1 && (a5 = t5[s5 + 1]), "[" === r5 && "^" === a5 ? (n5 += "[^", s5++) : "[" === r5 || "]" === r5 ? n5 += r5 : "*" === r5 ? n5 += ".*" : "?" === r5 ? n5 += "." : -1 < "/.*+?|(){}".indexOf(r5) ? n5 += "\\" + r5 : n5 += r5, s5++;
          }
          return n5 += "$", -1 < ("" + (e5 || "")).toUpperCase().search(RegExp(n5.toUpperCase()));
        }, bs.findAlaSQLPath = function() {
          if (!bs.isWebWorker) {
            if (bs.isMeteorClient)
              return "/packages/dist/";
            if (bs.isMeteorServer)
              return "assets/packages/dist/";
            if (!bs.isNode && bs.isBrowser)
              for (var e5 = document.getElementsByTagName("script"), t5 = 0; t5 < e5.length; t5++) {
                if ("alasql-worker.js" === e5[t5].src.substr(-16).toLowerCase())
                  return e5[t5].src.substr(0, e5[t5].src.length - 16);
                if ("alasql-worker.min.js" === e5[t5].src.substr(-20).toLowerCase())
                  return e5[t5].src.substr(0, e5[t5].src.length - 20);
                if ("alasql.js" === e5[t5].src.substr(-9).toLowerCase())
                  return e5[t5].src.substr(0, e5[t5].src.length - 9);
                if ("alasql.min.js" === e5[t5].src.substr(-13).toLowerCase())
                  return e5[t5].src.substr(0, e5[t5].src.length - 13);
              }
          }
          return "";
        }, L.path = L.utils.findAlaSQLPath(), L.utils.uncomment = function(e5) {
          for (var t5, s5 = false, n5 = false, r5 = false, a5 = 0, i5 = (e5 = ("__" + e5 + "__").split("")).length; a5 < i5; a5++) {
            var o5 = "\\" !== e5[a5 - 1] || "\\" === e5[a5 - 2];
            s5 ? e5[a5] === t5 && o5 && (s5 = false) : n5 ? "*" === e5[a5] && "/" === e5[a5 + 1] ? (e5[a5] = e5[a5 + 1] = "", n5 = false, a5++) : e5[a5] = "" : r5 ? ("\n" !== e5[a5 + 1] && "\r" !== e5[a5 + 1] || (r5 = false), e5[a5] = "") : '"' === e5[a5] || "'" === e5[a5] ? (s5 = true, t5 = e5[a5]) : "[" === e5[a5] && "@" !== e5[a5 - 1] ? (s5 = true, t5 = "]") : "/" === e5[a5] && "*" === e5[a5 + 1] && (n5 = !(e5[a5] = ""));
          }
          return e5 = e5.join("").slice(2, -2);
        }, L.parser = fs, L.parser.parseError = function(e5, t5) {
          throw new Error("Have you used a reserved keyword without `escaping` it?\n" + e5);
        }, L.parse = function(e5) {
          return fs.parse(L.utils.uncomment(e5));
        }, L.engines = {}, L.databases = {}, L.databasenum = 0, L.options = { errorlog: false, valueof: true, dropifnotexists: false, datetimeformat: "sql", casesensitive: true, logtarget: "output", logprompt: true, progress: false, modifier: void 0, columnlookup: 10, autovertex: true, usedbo: true, autocommit: true, cache: true, tsql: true, mysql: true, postgres: true, oracle: true, sqlite: true, orientdb: true, nocount: false, nan: false, excel: { cellDates: true }, joinstar: "overwrite", loopbreak: 1e5 }, L.vars = {}, L.declares = {}, L.prompthistory = [], L.plugins = {}, L.from = {}, L.into = {}, L.fn = {}, L.aggr = {}, L.busy = 0, L.MAXSQLCACHESIZE = 1e4, L.DEFAULTDATABASEID = "alasql", L.lastid = 0, L.buffer = {}, L.private = { externalXlsxLib: null }, L.setXLSX = function(e5) {
          L.private.externalXlsxLib = e5;
        }, L.use = function(e5) {
          if (e5 = e5 || L.DEFAULTDATABASEID, L.useid !== e5) {
            if (void 0 === L.databases[e5])
              throw Error("Database does not exist: " + e5);
            L.useid = e5;
            e5 = L.databases[L.useid];
            L.tables = e5.tables, e5.resetSqlCache(), L.options.usedbo && (L.databases.dbo = e5);
          }
        }, L.autoval = function(e5, t5, s5, n5) {
          n5 = n5 ? L.databases[n5] : L.databases[L.useid];
          if (!n5.tables[e5])
            throw new Error("Tablename not found: " + e5);
          if (n5.tables[e5].identities[t5])
            return s5 ? n5.tables[e5].identities[t5].value || null : n5.tables[e5].identities[t5].value - n5.tables[e5].identities[t5].step || null;
          throw new Error("Colname not found: " + t5);
        }, L.exec = function(e5, t5, s5, n5) {
          if ("function" == typeof t5 && (n5 = s5, s5 = t5, t5 = {}), delete L.error, t5 = t5 || {}, !L.options.errorlog)
            return L.dexec(L.useid, e5, t5, s5, n5);
          try {
            return L.dexec(L.useid, e5, t5, s5, n5);
          } catch (e6) {
            L.error = e6, s5 && s5(null, L.error);
          }
        }, L.dexec = function(e5, t5, s5, n5, r5) {
          var a5 = L.databases[e5];
          if (L.options.cache) {
            var i5 = Rs(t5);
            if ((o5 = a5.sqlCache[i5]) && a5.dbversion === o5.dbversion)
              return o5(s5, n5);
          }
          var o5, u5 = L.parse(t5);
          if (u5.statements)
            return 0 === u5.statements.length ? 0 : 1 === u5.statements.length ? u5.statements[0].compile ? (o5 = u5.statements[0].compile(e5, s5)) ? (o5.sql = t5, o5.dbversion = a5.dbversion, L.options.cache && (a5.sqlCacheSize > L.MAXSQLCACHESIZE && a5.resetSqlCache(), a5.sqlCacheSize++, a5.sqlCache[i5] = o5), L.res = o5(s5, n5, r5)) : void 0 : (L.precompile(u5.statements[0], L.useid, s5), L.res = u5.statements[0].execute(e5, s5, n5, r5)) : n5 ? void L.adrun(e5, u5, s5, n5, r5) : L.drun(e5, u5, s5, n5, r5);
        }, L.drun = function(e5, t5, s5, n5, r5) {
          for (var a5, i5 = L.useid, o5 = (i5 !== e5 && L.use(e5), []), u5 = 0, l5 = t5.statements.length; u5 < l5; u5++)
            t5.statements[u5] && (t5.statements[u5].compile ? (a5 = t5.statements[u5].compile(L.useid), o5.push(L.res = a5(s5, null, r5))) : (L.precompile(t5.statements[u5], L.useid, s5), o5.push(L.res = t5.statements[u5].execute(L.useid, s5))));
          return i5 !== e5 && L.use(i5), n5 && n5(o5), L.res = o5;
        }, L.adrun = function(s5, n5, r5, a5, i5) {
          var o5 = 0, u5 = n5.statements.length, l5 = (false !== L.options.progress && L.options.progress(u5, o5++), L.useid), c5 = (l5 !== s5 && L.use(s5), []);
          !function e5(t5) {
            void 0 !== t5 && c5.push(t5);
            t5 = n5.statements.shift();
            t5 ? (t5.compile ? t5.compile(L.useid)(r5, e5, i5) : (L.precompile(n5.statements[0], L.useid, r5), t5.execute(L.useid, r5, e5)), false !== L.options.progress && L.options.progress(u5, o5++)) : (l5 !== s5 && L.use(l5), a5(c5));
          }();
        }, L.compile = function(e5, t5) {
          t5 = t5 || L.useid;
          var r5, e5 = L.parse(e5);
          if (1 === e5.statements.length)
            return (r5 = e5.statements[0].compile(t5)).promise = function(e6) {
              return new Promise(function(s5, n5) {
                r5(e6, function(e7, t6) {
                  t6 ? n5(t6) : s5(e7);
                });
              });
            }, r5;
          throw new Error("Cannot compile, because number of statements in SQL is not equal to 1");
        }, bs.global.Promise || (bs.global.Promise = Promise), function(e5, t5, r5, a5) {
          return new bs.global.Promise(function(s5, n5) {
            L(e5, t5, function(e6, t6) {
              t6 ? n5(t6) : (r5 && a5 && false !== L.options.progress && L.options.progress(r5, a5), s5(e6));
            });
          });
        }), Gs = (L.promise = function(e5, t5) {
          if ("undefined" == typeof Promise)
            throw new Error("Please include a Promise/A+ library");
          if ("string" == typeof e5)
            return qs(e5, t5);
          if (!bs.isArray(e5) || e5.length < 1 || void 0 !== t5)
            throw new Error("Error in .promise parameters");
          var s5 = e5;
          if (!(s5.length < 1)) {
            for (var n5, r5, a5 = [], i5 = 0; i5 < s5.length; i5++) {
              if ("string" == typeof (r5 = s5[i5]) && (r5 = [r5]), !bs.isArray(r5) || r5.length < 1 || 2 < r5.length)
                throw new Error("Error in .promise parameter");
              n5 = r5[0], r5 = r5[1] || void 0, a5.push(qs(n5, r5, i5, s5.length));
            }
            return bs.global.Promise.all(a5);
          }
        }, L.Database = function(e5) {
          var t5 = this;
          if (t5 === L)
            if (e5) {
              if (t5 = L.databases[e5], !(L.databases[e5] = t5))
                throw new Error('Database "' + e5 + '" not found');
            } else
              t5 = L.databases.alasql, L.options.tsql && (L.databases.tempdb = L.databases.alasql);
          return e5 = e5 || "db" + L.databasenum++, t5.databaseid = e5, (L.databases[e5] = t5).dbversion = 0, t5.tables = {}, t5.views = {}, t5.triggers = {}, t5.indices = {}, t5.objects = {}, t5.counter = 0, t5.resetSqlCache(), t5;
        });
        Gs.prototype.resetSqlCache = function() {
          this.sqlCache = {}, this.sqlCacheSize = 0;
        }, Gs.prototype.exec = function(e5, t5, s5) {
          return L.dexec(this.databaseid, e5, t5, s5);
        }, Gs.prototype.autoval = function(e5, t5, s5) {
          return L.autoval(e5, t5, s5, this.databaseid);
        }, Gs.prototype.transaction = function(e5) {
          return e5(new L.Transaction(this.databaseid));
        };
        class js {
          transactionid = Date.now();
          committed = false;
          bank;
          constructor(e5) {
            this.databaseid = e5, this.dbversion = L.databases[e5].dbversion, this.bank = JSON.stringify(L.databases[e5]);
          }
          commit() {
            this.committed = true, L.databases[this.databaseid].dbversion = Date.now(), delete this.bank;
          }
          rollback() {
            if (this.committed)
              throw new Error("Transaction already commited");
            L.databases[this.databaseid] = JSON.parse(this.bank), delete this.bank;
          }
          exec(e5, t5, s5) {
            return L.dexec(this.databaseid, e5, t5, s5);
          }
        }
        js.prototype.executeSQL = js.prototype.exec, L.Transaction = js;
        var Vs = L.Table = function(e5) {
          this.data = [], this.columns = [], this.xcolumns = {}, this.inddefs = {}, this.indices = {}, this.uniqs = {}, this.uniqdefs = {}, this.identities = {}, this.checks = [], this.checkfns = [], this.beforeinsert = {}, this.afterinsert = {}, this.insteadofinsert = {}, this.beforedelete = {}, this.afterdelete = {}, this.insteadofdelete = {}, this.beforeupdate = {}, this.afterupdate = {}, this.insteadofupdate = {}, Object.assign(this, e5);
        };
        Vs.prototype.indexColumns = function() {
          var t5 = this;
          t5.xcolumns = {}, t5.columns.forEach(function(e5) {
            t5.xcolumns[e5.columnid] = e5;
          });
        };
        class Bs {
          constructor(e5) {
            this.columns = [], this.xcolumns = {}, this.query = [], Object.assign(this, e5);
          }
        }
        L.View = Bs;
        class Hs {
          constructor(e5) {
            this.alasql = L, this.columns = [], this.xcolumns = {}, this.selectGroup = [], this.groupColumns = {}, Object.assign(this, e5);
          }
        }
        L.Recordset = class {
          constructor(e5) {
            Object.assign(this, e5);
          }
        }, L.Query = Hs;
        var M = { extend: Object.assign, casesensitive: L.options.casesensitive, Base: class {
          constructor(e5) {
            Object.assign(this, e5);
          }
          toString() {
          }
          toType() {
          }
          toJS() {
          }
          exec() {
          }
          compile() {
          }
        } }, Js = ((fs.yy = L.yy = M).Statements = class {
          constructor(e5) {
            Object.assign(this, e5);
          }
          toString() {
            return this.statements.map((e5) => e5.toString()).join("; ");
          }
          compile(t5) {
            const n5 = this.statements.map((e5) => e5.compile(t5));
            return 1 === n5.length ? n5[0] : (t6, e5) => {
              var s5 = n5.map((e6) => e6(t6));
              return e5 && e5(s5), s5;
            };
          }
        }, M.Search = class {
          constructor(e5) {
            Object.assign(this, e5);
          }
          toString() {
            let e5 = "SEARCH ";
            return this.selectors && (e5 += this.selectors.toString()), this.from && (e5 += "FROM " + this.from.toString()), e5;
          }
          toJS(e5) {
            return `this.queriesfn[${this.queriesidx - 1}](this.params,null,${e5})`;
          }
          compile(e5) {
            var n5 = e5, r5 = (e6, t5) => {
              var s5;
              return this.#doSearch(n5, e6, function(e7) {
                s5 = Ks(r5.query, e7), t5 && (s5 = t5(s5));
              }), s5;
            };
            return r5.query = {}, r5;
          }
          #doSearch(e5, I5, t5) {
            var w5, s5, n5, r5, $5 = {}, a5 = Ds(this.selectors);
            return void 0 !== a5 && 0 < a5.length && (a5 && a5[0] && "PROP" === a5[0].srchid && a5[0].args && a5[0].args[0] && ("XML" === a5[0].args[0].toUpperCase() ? ($5.mode = "XML", a5.shift()) : "HTML" === a5[0].args[0].toUpperCase() ? ($5.mode = "HTML", a5.shift()) : "JSON" === a5[0].args[0].toUpperCase() && ($5.mode = "JSON", a5.shift())), 0 < a5.length) && "VALUE" === a5[0].srchid && ($5.value = true, a5.shift()), this.from instanceof M.Column ? (s5 = this.from.databaseid || e5, w5 = L.databases[s5].tables[this.from.columnid].data) : this.from instanceof M.FuncValue && L.from[this.from.funcid.toUpperCase()] ? (s5 = this.from.args.map(function(e6) {
              e6 = e6.toJS();
              return new Function("params,alasql", "var y;return " + e6).bind(this)(I5, L);
            }), w5 = L.from[this.from.funcid.toUpperCase()].apply(this, s5)) : void 0 === this.from ? w5 = L.databases[e5].objects : (s5 = new Function("params,alasql", "var y;return " + this.from.toJS()), w5 = s5(I5, L), "object" == typeof Mongo && "object" != typeof Mongo.Collection && w5 instanceof Mongo.Collection && (w5 = w5.find().fetch())), e5 = void 0 !== a5 && 0 < a5.length ? function t6(s6, n6, r6) {
              var e6, a6, i5, o5, u5 = s6[n6], l5 = L.options.loopbreak || 1e5;
              if (u5.selid) {
                if ("PATH" === u5.selid) {
                  for (var c5 = [{ node: r6, stack: [] }], h5 = {}, d5 = L.databases[L.useid].objects; 0 < c5.length; ) {
                    var f5, p5 = c5.shift(), b5 = p5.node, E5 = p5.stack;
                    if (0 < (O5 = t6(u5.args, 0, b5)).length)
                      return n6 + 1 + 1 > s6.length ? E5 : (f5 = [], E5 && 0 < E5.length && E5.forEach(function(e7) {
                        f5 = f5.concat(t6(s6, n6 + 1, e7));
                      }), f5);
                    void 0 === h5[b5.$id] && (h5[b5.$id] = true, b5.$out) && 0 < b5.$out.length && b5.$out.forEach(function(e7) {
                      var e7 = d5[e7], t7 = E5.concat(e7);
                      t7.push(d5[e7.$out[0]]), c5.push({ node: d5[e7.$out[0]], stack: t7 });
                    });
                  }
                  return [];
                }
                if ("NOT" === u5.selid)
                  return 0 < (N5 = t6(u5.args, 0, r6)).length ? [] : n6 + 1 + 1 > s6.length ? [r6] : t6(s6, n6 + 1, r6);
                if ("DISTINCT" === u5.selid)
                  return 0 === (N5 = void 0 === u5.args || 0 === u5.args.length ? Us(r6) : t6(u5.args, 0, r6)).length ? [] : (C5 = Us(N5), n6 + 1 + 1 > s6.length ? C5 : t6(s6, n6 + 1, C5));
                if ("AND" === u5.selid)
                  return C5 = true, u5.args.forEach(function(e7) {
                    C5 = C5 && 0 < t6(e7, 0, r6).length;
                  }), C5 ? n6 + 1 + 1 > s6.length ? [r6] : t6(s6, n6 + 1, r6) : [];
                if ("OR" === u5.selid)
                  return C5 = false, u5.args.forEach(function(e7) {
                    C5 = C5 || 0 < t6(e7, 0, r6).length;
                  }), C5 ? n6 + 1 + 1 > s6.length ? [r6] : t6(s6, n6 + 1, r6) : [];
                if ("ALL" === u5.selid)
                  return 0 === (N5 = t6(u5.args[0], 0, r6)).length ? [] : n6 + 1 + 1 > s6.length ? N5 : t6(s6, n6 + 1, N5);
                if ("ANY" === u5.selid)
                  return 0 === (N5 = t6(u5.args[0], 0, r6)).length ? [] : n6 + 1 + 1 > s6.length ? [N5[0]] : t6(s6, n6 + 1, [N5[0]]);
                if ("UNIONALL" === u5.selid)
                  return N5 = [], u5.args.forEach(function(e7) {
                    N5 = N5.concat(t6(e7, 0, r6));
                  }), 0 === N5.length ? [] : n6 + 1 + 1 > s6.length ? N5 : t6(s6, n6 + 1, N5);
                if ("UNION" === u5.selid)
                  return N5 = [], u5.args.forEach(function(e7) {
                    N5 = N5.concat(t6(e7, 0, r6));
                  }), 0 === (N5 = Us(N5)).length ? [] : n6 + 1 + 1 > s6.length ? N5 : t6(s6, n6 + 1, N5);
                if ("IF" === u5.selid)
                  return 0 === (N5 = t6(u5.args, 0, r6)).length ? [] : n6 + 1 + 1 > s6.length ? [r6] : t6(s6, n6 + 1, r6);
                if ("REPEAT" === u5.selid) {
                  var g5, m5 = u5.args[0].value, T5 = u5.args[1] ? u5.args[1].value : m5, S5 = (u5.args[2] && (g5 = u5.args[2].variable), []);
                  if (0 === m5 && (S5 = n6 + 1 + 1 > s6.length ? [r6] : (g5 && (L.vars[g5] = 0), S5.concat(t6(s6, n6 + 1, r6)))), 0 < T5)
                    for (var A5 = [{ value: r6, lvl: 1 }], y5 = 0; 0 < A5.length; ) {
                      var v5, N5 = A5[0];
                      if (A5.shift(), N5.lvl <= T5 && (g5 && (L.vars[g5] = N5.lvl), (v5 = t6(u5.sels, 0, N5.value)).forEach(function(e7) {
                        A5.push({ value: e7, lvl: N5.lvl + 1 });
                      }), N5.lvl >= m5) && (n6 + 1 + 1 > s6.length ? S5 = S5.concat(v5) : v5.forEach(function(e7) {
                        S5 = S5.concat(t6(s6, n6 + 1, e7));
                      })), l5 < ++y5)
                        throw new Error("Infinite loop brake. Number of iterations = " + y5);
                    }
                  return S5;
                }
                if ("OF" === u5.selid)
                  return n6 + 1 + 1 > s6.length ? [r6] : (a6 = [], Object.keys(r6).forEach(function(e7) {
                    L.vars[u5.args[0].variable] = e7, a6 = a6.concat(t6(s6, n6 + 1, r6[e7]));
                  }), a6);
                if ("TO" === u5.selid)
                  return i5 = [], (i5 = void 0 !== (e6 = L.vars[u5.args[0]]) ? e6.slice(0) : []).push(r6), n6 + 1 + 1 > s6.length ? [r6] : (L.vars[u5.args[0]] = i5, a6 = t6(s6, n6 + 1, r6), L.vars[u5.args[0]] = e6, a6);
                if ("ARRAY" === u5.selid)
                  return 0 < (N5 = t6(u5.args, 0, r6)).length ? (o5 = N5, n6 + 1 + 1 > s6.length ? [o5] : t6(s6, n6 + 1, o5)) : [];
                if ("SUM" === u5.selid)
                  return 0 < (N5 = t6(u5.args, 0, r6)).length ? (o5 = N5.reduce(function(e7, t7) {
                    return e7 + t7;
                  }, 0), n6 + 1 + 1 > s6.length ? [o5] : t6(s6, n6 + 1, o5)) : [];
                if ("AVG" === u5.selid)
                  return 0 < (N5 = t6(u5.args, 0, r6)).length ? (o5 = N5.reduce(function(e7, t7) {
                    return e7 + t7;
                  }, 0) / N5.length, n6 + 1 + 1 > s6.length ? [o5] : t6(s6, n6 + 1, o5)) : [];
                if ("COUNT" === u5.selid)
                  return 0 < (N5 = t6(u5.args, 0, r6)).length ? (o5 = N5.length, n6 + 1 + 1 > s6.length ? [o5] : t6(s6, n6 + 1, o5)) : [];
                if ("FIRST" === u5.selid)
                  return 0 < (N5 = t6(u5.args, 0, r6)).length ? (o5 = N5[0], n6 + 1 + 1 > s6.length ? [o5] : t6(s6, n6 + 1, o5)) : [];
                if ("LAST" === u5.selid)
                  return 0 < (N5 = t6(u5.args, 0, r6)).length ? (o5 = N5[N5.length - 1], n6 + 1 + 1 > s6.length ? [o5] : t6(s6, n6 + 1, o5)) : [];
                if ("MIN" === u5.selid)
                  return 0 === (N5 = t6(u5.args, 0, r6)).length ? [] : (o5 = N5.reduce(function(e7, t7) {
                    return Math.min(e7, t7);
                  }, 1 / 0), n6 + 1 + 1 > s6.length ? [o5] : t6(s6, n6 + 1, o5));
                if ("MAX" === u5.selid)
                  return 0 === (N5 = t6(u5.args, 0, r6)).length ? [] : (o5 = N5.reduce(function(e7, t7) {
                    return Math.max(e7, t7);
                  }, -1 / 0), n6 + 1 + 1 > s6.length ? [o5] : t6(s6, n6 + 1, o5));
                if ("PLUS" === u5.selid) {
                  for (S5 = [], A5 = t6(u5.args, 0, r6).slice(), y5 = (n6 + 1 + 1 > s6.length ? S5 = S5.concat(A5) : A5.forEach(function(e7) {
                    S5 = S5.concat(t6(s6, n6 + 1, e7));
                  }), 0); 0 < A5.length; ) {
                    N5 = A5.shift();
                    if (N5 = t6(u5.args, 0, N5), A5 = A5.concat(N5), n6 + 1 + 1 > s6.length ? S5 = S5.concat(N5) : N5.forEach(function(e7) {
                      e7 = t6(s6, n6 + 1, e7), S5 = S5.concat(e7);
                    }), l5 < ++y5)
                      throw new Error("Infinite loop brake. Number of iterations = " + y5);
                  }
                  return S5;
                }
                if ("STAR" === u5.selid) {
                  for (S5 = [], S5 = t6(s6, n6 + 1, r6), A5 = t6(u5.args, 0, r6).slice(), n6 + 1 + 1 > s6.length ? S5 = S5.concat(A5) : A5.forEach(function(e7) {
                    S5 = S5.concat(t6(s6, n6 + 1, e7));
                  }), y5 = 0; 0 < A5.length; ) {
                    N5 = A5[0];
                    if (A5.shift(), N5 = t6(u5.args, 0, N5), A5 = A5.concat(N5), n6 + 1 + 1 <= s6.length && N5.forEach(function(e7) {
                      S5 = S5.concat(t6(s6, n6 + 1, e7));
                    }), l5 < ++y5)
                      throw new Error("Infinite loop brake. Number of iterations = " + y5);
                  }
                  return S5;
                }
                if ("QUESTION" === u5.selid)
                  return S5 = (S5 = []).concat(t6(s6, n6 + 1, r6)), N5 = t6(u5.args, 0, r6), n6 + 1 + 1 <= s6.length && N5.forEach(function(e7) {
                    S5 = S5.concat(t6(s6, n6 + 1, e7));
                  }), S5;
                if ("WITH" !== u5.selid) {
                  if ("ROOT" === u5.selid)
                    return n6 + 1 + 1 > s6.length ? [r6] : t6(s6, n6 + 1, w5);
                  throw new Error("Wrong selector " + u5.selid);
                }
                if (0 === (N5 = t6(u5.args, 0, r6)).length)
                  return [];
                var O5 = { status: 1, values: N5 };
              } else {
                if (!u5.srchid)
                  throw new Error("Selector not found");
                O5 = L.srch[u5.srchid.toUpperCase()](r6, u5.args, $5, I5);
              }
              var C5 = [];
              if (1 === (O5 = void 0 === O5 ? { status: 1, values: [r6] } : O5).status) {
                var R5 = O5.values;
                if (n6 + 1 + 1 > s6.length)
                  C5 = R5;
                else
                  for (y5 = 0; y5 < O5.values.length; y5++)
                    C5 = C5.concat(t6(s6, n6 + 1, R5[y5]));
              }
              return C5;
            }(a5, 0, w5) : w5, this.into ? (void 0 !== this.into.args[0] && (n5 = new Function("params,alasql", "var y;return " + this.into.args[0].toJS())(I5, L)), void 0 !== this.into.args[1] && (r5 = new Function("params,alasql", "var y;return " + this.into.args[1].toJS())(I5, L)), e5 = L.into[this.into.funcid.toUpperCase()](n5, r5, e5, [], t5)) : ($5.value && 0 < e5.length && (e5 = e5[0]), t5 && (e5 = t5(e5))), e5;
          }
        }, L.srch = { PROP(e5, t5, s5) {
          return "XML" === s5.mode ? { status: (s5 = e5.children.filter((e6) => e6.name.toUpperCase() === t5[0].toUpperCase())).length ? 1 : -1, values: s5 } : "object" != typeof e5 || null === e5 || "object" != typeof t5 || void 0 === e5[t5[0]] ? { status: -1, values: [] } : { status: 1, values: [e5[t5[0]]] };
        }, APROP(e5, t5) {
          return "object" != typeof e5 || null === e5 || "object" != typeof t5 || void 0 === e5[t5[0]] ? { status: 1, values: [void 0] } : { status: 1, values: [e5[t5[0]]] };
        }, EQ(e5, t5, s5, n5) {
          t5 = t5[0].toJS("x", "");
          return e5 === new Function("x,alasql,params", "return " + t5)(e5, L, n5) ? { status: 1, values: [e5] } : { status: -1, values: [] };
        }, LIKE(e5, t5, s5, n5) {
          t5 = t5[0].toJS("x", ""), t5 = new Function("x,alasql,params", "return " + t5);
          return e5.toUpperCase().match(new RegExp("^" + t5(e5, L, n5).toUpperCase().replace(/%/g, ".*").replace(/\?|_/g, ".") + "$"), "g") ? { status: 1, values: [e5] } : { status: -1, values: [] };
        }, ATTR(e5, t5, s5) {
          if ("XML" === s5.mode)
            return void 0 === t5 ? { status: 1, values: [e5.attributes] } : "object" == typeof e5 && "object" == typeof e5.attributes && void 0 !== e5.attributes[t5[0]] ? { status: 1, values: [e5.attributes[t5[0]]] } : { status: -1, values: [] };
          throw new Error("ATTR is not using in usual mode");
        }, CONTENT(e5, t5, s5) {
          if ("XML" !== s5.mode)
            throw new Error("ATTR is not using in usual mode");
          return { status: 1, values: [e5.content] };
        }, SHARP(e5, t5) {
          t5 = L.databases[L.useid].objects[t5[0]];
          return void 0 !== e5 && e5 === t5 ? { status: 1, values: [e5] } : { status: -1, values: [] };
        }, PARENT() {
          return console.error("PARENT not implemented", arguments), { status: -1, values: [] };
        }, CHILD(t5, e5, s5) {
          return "object" == typeof t5 ? Array.isArray(t5) ? { status: 1, values: t5 } : "XML" === s5.mode ? { status: 1, values: Object.keys(t5.children).map(function(e6) {
            return t5.children[e6];
          }) } : { status: 1, values: Object.keys(t5).map(function(e6) {
            return t5[e6];
          }) } : { status: 1, values: [] };
        }, KEYS(e5) {
          return "object" == typeof e5 && null !== e5 ? { status: 1, values: Object.keys(e5) } : { status: 1, values: [] };
        }, WHERE(e5, t5, s5, n5) {
          t5 = t5[0].toJS("x", "");
          return new Function("x,alasql,params", "return " + t5)(e5, L, n5) ? { status: 1, values: [e5] } : { status: -1, values: [] };
        }, NAME(e5, t5) {
          return e5.name === t5[0] ? { status: 1, values: [e5] } : { status: -1, values: [] };
        }, CLASS(e5, t5) {
          return e5.$class == t5 ? { status: 1, values: [e5] } : { status: -1, values: [] };
        }, VERTEX(e5) {
          return "VERTEX" === e5.$node ? { status: 1, values: [e5] } : { status: -1, values: [] };
        }, INSTANCEOF(e5, t5) {
          return e5 instanceof L.fn[t5[0]] ? { status: 1, values: [e5] } : { status: -1, values: [] };
        }, EDGE(e5) {
          return "EDGE" === e5.$node ? { status: 1, values: [e5] } : { status: -1, values: [] };
        }, EX(e5, t5, s5, n5) {
          t5 = t5[0].toJS("x", "");
          return { status: 1, values: [new Function("x,alasql,params", "return " + t5)(e5, L, n5)] };
        }, RETURN(s5, e5, t5, n5) {
          var r5 = {};
          return e5 && 0 < e5.length && e5.forEach(function(e6) {
            var t6 = e6.toJS("x", ""), t6 = new Function("x,alasql,params", "return " + t6);
            void 0 === e6.as && (e6.as = e6.toString()), r5[e6.as] = t6(s5, L, n5);
          }), { status: 1, values: [r5] };
        }, REF(e5) {
          return { status: 1, values: [L.databases[L.useid].objects[e5]] };
        }, OUT(e5) {
          return e5.$out && 0 < e5.$out.length ? { status: 1, values: e5.$out.map(function(e6) {
            return L.databases[L.useid].objects[e6];
          }) } : { status: -1, values: [] };
        }, OUTOUT(e5) {
          var t5;
          return e5.$out && 0 < e5.$out.length ? (t5 = [], e5.$out.forEach(function(e6) {
            e6 = L.databases[L.useid].objects[e6];
            e6 && e6.$out && 0 < e6.$out.length && e6.$out.forEach(function(e7) {
              t5 = t5.concat(L.databases[L.useid].objects[e7]);
            });
          }), { status: 1, values: t5 }) : { status: -1, values: [] };
        }, IN(e5) {
          return e5.$in && 0 < e5.$in.length ? { status: 1, values: e5.$in.map(function(e6) {
            return L.databases[L.useid].objects[e6];
          }) } : { status: -1, values: [] };
        }, ININ(e5) {
          var t5;
          return e5.$in && 0 < e5.$in.length ? (t5 = [], e5.$in.forEach(function(e6) {
            e6 = L.databases[L.useid].objects[e6];
            e6 && e6.$in && 0 < e6.$in.length && e6.$in.forEach(function(e7) {
              t5 = t5.concat(L.databases[L.useid].objects[e7]);
            });
          }), { status: 1, values: t5 }) : { status: -1, values: [] };
        }, AS(e5, t5) {
          return { status: 1, values: [L.vars[t5[0]] = e5] };
        }, AT(e5, t5) {
          return { status: 1, values: [L.vars[t5[0]]] };
        }, CLONEDEEP(e5) {
          return { status: 1, values: [Ds(e5)] };
        }, SET(e5, t5, s5, n5) {
          t5 = t5.map(function(e6) {
            return "@" === e6.method ? "alasql.vars['" + e6.variable + "']=" + e6.expression.toJS("x", "") : "$" === e6.method ? "params['" + e6.variable + "']=" + e6.expression.toJS("x", "") : "x['" + e6.column.columnid + "']=" + e6.expression.toJS("x", "");
          }).join(";");
          return new Function("x,params,alasql", t5)(e5, n5, L), { status: 1, values: [e5] };
        }, ROW(e5, t5, s5, n5) {
          var r5 = (r5 = "var y;return [") + t5.map((e6) => e6.toJS("x", "")).join(",") + "]";
          return { status: 1, values: [new Function("x,params,alasql", r5)(e5, n5, L)] };
        }, D3(e5) {
          return "VERTEX" !== e5.$node && "EDGE" === e5.$node && (e5.source = e5.$in[0], e5.target = e5.$out[0]), { status: 1, values: [e5] };
        }, ORDERBY(e5, t5) {
          return { status: 1, values: e5.sort(Js(t5)) };
        } }, function(e5) {
          var s5, n5, r5;
          if (e5)
            return "function" == typeof e5?.[0]?.expression ? (s5 = e5[0].expression, function(e6, t5) {
              e6 = s5(e6), t5 = s5(t5);
              return t5 < e6 ? 1 : e6 === t5 ? 0 : -1;
            }) : (r5 = n5 = "", e5.forEach(function(e6) {
              var t5, s6 = "";
              e6.expression instanceof M.NumValue && (e6.expression = self.columns[e6.expression.value - 1]), n5 = e6.expression instanceof M.Column ? (t5 = e6.expression.columnid, L.options.valueof && (s6 = ".valueOf()"), e6.nocase && (s6 += ".toUpperCase()"), "_" === t5 ? n5 + ("if(a" + s6 + ("ASC" === e6.direction ? ">" : "<")) + "b" + s6 + ")return 1;if(a" + s6 + "==b" + s6 + "){" : n5 + ("if((a['" + t5 + "']||'')" + s6 + ("ASC" === e6.direction ? ">" : "<")) + "(b['" + t5 + "']||'')" + s6 + ")return 1;if((a['" + t5 + "']||'')" + s6 + "==(b['" + t5 + "']||'')" + s6 + "){") : (s6 = ".valueOf()", e6.nocase && (s6 += ".toUpperCase()"), (n5 += "if((" + e6.toJS("a", "") + "||'')" + s6 + ("ASC" === e6.direction ? ">(" : "<(") + e6.toJS("b", "") + "||'')" + s6 + ")return 1;") + "if((" + e6.toJS("a", "") + "||'')" + s6 + "==(" + e6.toJS("b", "") + "||'')" + s6 + "){"), r5 += "}";
            }), n5 = n5 + "return 0;" + r5 + "return -1", new Function("a,b", n5));
        });
        function Ys(e5, t5, s5) {
          var n5;
          if (0 <= t5 ? ((n5 = s5.sources[t5]).data = e5, "function" == typeof n5.data && (n5.getfn = n5.data, n5.dontcache = n5.getfn.dontcache, "OUTER" != n5.joinmode && "RIGHT" != n5.joinmode && "ANTI" != n5.joinmode || (n5.dontcache = false), n5.data = {})) : s5.queriesdata[-t5 - 1] = Ps(e5), s5.sourceslen--, !(0 < s5.sourceslen))
            return Ws(s5);
        }
        function Ws(e5) {
          var t5, s5, n5, r5, a5, i5 = e5.scope;
          Xs(e5), e5.data = [], e5.xgroups = {}, e5.groups = [];
          if (!function s6(n6, r6, a6) {
            if (a6 >= n6.sources.length)
              n6.wherefn(r6, n6.params, L) && (n6.groupfn ? n6.groupfn(r6, n6.params, L) : n6.data.push(n6.selectfn(r6, n6.params, L)));
            else if (n6.sources[a6].applyselect)
              (i6 = n6.sources[a6]).applyselect(n6.params, function(e7) {
                if (0 < e7.length)
                  for (var t7 = 0; t7 < e7.length; t7++)
                    r6[i6.alias] = e7[t7], s6(n6, r6, a6 + 1);
                else
                  "OUTER" == i6.applymode && (r6[i6.alias] = {}, s6(n6, r6, a6 + 1));
              }, r6);
            else {
              var i6 = n6.sources[a6], e6 = n6.sources[a6 + 1], t6 = i6.alias || i6.tableid, o6 = false, u6 = i6.data, l6 = false, c6 = (i6.getfn && (!i6.getfn || i6.dontcache) || "RIGHT" == i6.joinmode || "OUTER" == i6.joinmode || "ANTI" == i6.joinmode || "ix" != i6.optimization || (u6 = i6.ix[i6.onleftfn(r6, n6.params, L)] || [], l6 = true), 0);
              if (void 0 === u6)
                throw new Error("Data source number " + a6 + " in undefined");
              for (var h6 = u6.length; (E6 = u6[c6]) || !l6 && i6.getfn && (E6 = i6.getfn(c6)) || c6 < h6; ) {
                l6 || !i6.getfn || i6.dontcache || (u6[c6] = E6), r6[t6] = E6;
                var d6, f6, p6 = !i6.onleftfn;
                p6 || (d6 = i6.onleftfn(r6, n6.params, L), f6 = i6.onrightfn(r6, n6.params, L), (d6 instanceof String || d6 instanceof Number) && (d6 = d6.valueOf()), (f6 instanceof String || f6 instanceof Number) && (f6 = d6.valueOf()), p6 = d6 == f6), p6 && i6.onmiddlefn(r6, n6.params, L) && ("SEMI" != i6.joinmode && "ANTI" != i6.joinmode && s6(n6, r6, a6 + 1), "LEFT" != i6.joinmode && "INNER" != i6.joinmode && (E6._rightjoin = true), o6 = true), c6++;
              }
              if ("LEFT" != i6.joinmode && "OUTER" != i6.joinmode && "SEMI" != i6.joinmode || o6 || (r6[t6] = {}, s6(n6, r6, a6 + 1)), 0 == a6)
                for (var b6 = a6 + 1; b6 < n6.sources.length; b6++) {
                  if ("OUTER" == e6.joinmode || "RIGHT" == e6.joinmode || "ANTI" == e6.joinmode) {
                    r6[i6.alias] = {};
                    for (var E6, g6 = 0, m6 = e6.data.length; (E6 = e6.data[g6]) || e6.getfn && (E6 = e6.getfn(g6)) || g6 < m6; )
                      e6.getfn && !e6.dontcache && (e6.data[g6] = E6), E6._rightjoin ? delete E6._rightjoin : (r6[e6.alias] = E6, s6(n6, r6, b6 + 1)), g6++;
                  }
                  i6 = n6.sources[b6], e6 = n6.sources[b6 + 1];
                }
              r6[t6] = void 0;
            }
          }(e5, i5, 0), e5.groupfn) {
            e5.data = [], 0 === e5.groups.length && 0 === e5.allgroups.length && (c5 = {}, 0 < e5.selectGroup.length && e5.selectGroup.forEach(function(e6) {
              "COUNT" == e6.aggregatorid || "SUM" == e6.aggregatorid || "TOTAL" == e6.aggregatorid ? c5[e6.nick] = 0 : c5[e6.nick] = void 0;
            }), e5.groups = [c5]), 0 < e5.aggrKeys.length && (t5 = "", e5.aggrKeys.forEach(function(e6) {
              t5 += "g['" + e6.nick + "']=alasql.aggr['" + e6.funcid + "'](undefined,g['" + e6.nick + "'],3);";
            }), s5 = new Function("g,params,alasql", "var y;" + t5));
            for (var o5 = 0, u5 = e5.groups.length; o5 < u5; o5++) {
              var l5, c5 = e5.groups[o5];
              s5 && s5(c5, e5.params, L), e5.havingfn && !e5.havingfn(c5, e5.params, L) || (l5 = e5.selectgfn(c5, e5.params, L), e5.data.push(l5));
            }
          }
          var h5 = e5;
          if (h5.distinct) {
            for (var d5, f5 = {}, p5 = Object.keys(h5.data[0] || []), b5 = 0, E5 = h5.data.length; b5 < E5; b5++) {
              var g5 = p5.map(function(e6) {
                return h5.data[b5][e6];
              }).join("`");
              f5[g5] = h5.data[b5];
            }
            for (d5 in h5.data = [], f5)
              h5.data.push(f5[d5]);
          }
          if (e5.unionallfn) {
            if (e5.corresponding)
              e5.unionallfn.query.modifier || (e5.unionallfn.query.modifier = void 0), A5 = e5.unionallfn(e5.params);
            else {
              e5.unionallfn.query.modifier || (e5.unionallfn.query.modifier = "RECORDSET"), A5 = [], u5 = (y5 = e5.unionallfn(e5.params)).data.length;
              for (o5 = 0; o5 < u5; o5++) {
                for (var m5 = {}, T5 = Math.min(e5.columns.length, y5.columns.length) - 1; 0 <= T5; T5--)
                  m5[e5.columns[T5].columnid] = y5.data[o5][y5.columns[T5].columnid];
                A5.push(m5);
              }
            }
            e5.data = e5.data.concat(A5);
          } else if (e5.unionfn) {
            if (e5.corresponding)
              e5.unionfn.query.modifier || (e5.unionfn.query.modifier = "ARRAY"), A5 = e5.unionfn(e5.params);
            else {
              e5.unionfn.query.modifier || (e5.unionfn.query.modifier = "RECORDSET"), A5 = [], u5 = (y5 = e5.unionfn(e5.params)).data.length;
              for (o5 = 0; o5 < u5; o5++) {
                if (m5 = {}, e5.columns.length)
                  for (var S5 = Math.min(e5.columns.length, y5.columns.length), T5 = 0; T5 < S5; T5++)
                    m5[e5.columns[T5].columnid] = y5.data[o5][y5.columns[T5].columnid];
                else {
                  S5 = y5.columns.length;
                  for (T5 = 0; T5 < S5; T5++)
                    m5[y5.columns[T5].columnid] = y5.data[o5][y5.columns[T5].columnid];
                }
                A5.push(m5);
              }
            }
            e5.data = xs(e5.data, A5);
          } else if (e5.exceptfn) {
            if (e5.corresponding) {
              e5.exceptfn.query.modifier || (e5.exceptfn.query.modifier = "ARRAY");
              var A5 = e5.exceptfn(e5.params);
            } else {
              e5.exceptfn.query.modifier || (e5.exceptfn.query.modifier = "RECORDSET");
              for (var y5, A5 = [], o5 = 0, u5 = (y5 = e5.exceptfn(e5.params)).data.length; o5 < u5; o5++) {
                for (m5 = {}, T5 = Math.min(e5.columns.length, y5.columns.length) - 1; 0 <= T5; T5--)
                  m5[e5.columns[T5].columnid] = y5.data[o5][y5.columns[T5].columnid];
                A5.push(m5);
              }
            }
            e5.data = ks(e5.data, A5);
          } else if (e5.intersectfn) {
            if (e5.corresponding)
              e5.intersectfn.query.modifier || (e5.intersectfn.query.modifier = void 0), A5 = e5.intersectfn(e5.params);
            else
              for (e5.intersectfn.query.modifier || (e5.intersectfn.query.modifier = "RECORDSET"), A5 = [], u5 = (y5 = e5.intersectfn(e5.params)).data.length, o5 = 0; o5 < u5; o5++) {
                for (m5 = {}, S5 = Math.min(e5.columns.length, y5.columns.length), T5 = 0; T5 < S5; T5++)
                  m5[e5.columns[T5].columnid] = y5.data[o5][y5.columns[T5].columnid];
                A5.push(m5);
              }
            e5.data = Ls(e5.data, A5);
          }
          e5.orderfn && (e5.explain && (n5 = Date.now()), e5.data = e5.data.sort(e5.orderfn), e5.explain) && e5.explaination.push({ explid: e5.explid++, description: "QUERY BY", ms: Date.now() - n5 });
          i5 = e5;
          if (i5.limit && (n5 = 0, i5.offset && (n5 = (n5 = 0 | i5.offset || 0) < 0 ? 0 : n5), r5 = i5.percent ? (i5.data.length * i5.limit / 100 | 0) + n5 : (0 | i5.limit) + n5, i5.data = i5.data.slice(n5, r5)), "undefined" != typeof angular && e5.removeKeys.push("$$hashKey"), 0 < e5.removeKeys.length) {
            var v5 = e5.removeKeys;
            if (0 < (S5 = v5.length))
              for (u5 = e5.data.length, o5 = 0; o5 < u5; o5++)
                for (T5 = 0; T5 < S5; T5++)
                  delete e5.data[o5][v5[T5]];
            0 < e5.columns.length && (e5.columns = e5.columns.filter(function(t6) {
              var s6 = false;
              return v5.forEach(function(e6) {
                t6.columnid == e6 && (s6 = true);
              }), !s6;
            }));
          }
          if (void 0 !== e5.removeLikeKeys && 0 < e5.removeLikeKeys.length) {
            for (var N5 = e5.removeLikeKeys, o5 = 0, u5 = e5.data.length; o5 < u5; o5++)
              for (var O5 in m5 = e5.data[o5])
                for (T5 = 0; T5 < e5.removeLikeKeys.length; T5++)
                  L.utils.like(e5.removeLikeKeys[T5], O5) && delete m5[O5];
            0 < e5.columns.length && (e5.columns = e5.columns.filter(function(t6) {
              var s6 = false;
              return N5.forEach(function(e6) {
                L.utils.like(e6, t6.columnid) && (s6 = true);
              }), !s6;
            }));
          }
          if (e5.pivotfn && e5.pivotfn(), e5.unpivotfn && e5.unpivotfn(), e5.intoallfn)
            return a5 = e5.intoallfn(e5.columns, e5.cb, e5.params, e5.alasql);
          if (e5.intofn) {
            for (u5 = e5.data.length, o5 = 0; o5 < u5; o5++)
              e5.intofn(e5.data[o5], o5, e5.params, e5.alasql);
            return e5.cb && e5.cb(e5.data.length, e5.A, e5.B), e5.data.length;
          }
          return a5 = e5.data, a5 = e5.cb ? e5.cb(e5.data, e5.A, e5.B) : a5;
        }
        var Xs = function(t5) {
          for (var e5 = 0, s5 = t5.sources.length; e5 < s5; e5++) {
            var n5, r5 = t5.sources[e5];
            if (delete r5.ix, 0 < e5 && "ix" == r5.optimization && r5.onleftfn && r5.onrightfn) {
              if (r5.databaseid && L.databases[r5.databaseid].tables[r5.tableid] && (L.databases[r5.databaseid].tables[r5.tableid].indices || (t5.database.tables[r5.tableid].indices = {}), n5 = L.databases[r5.databaseid].tables[r5.tableid].indices[Rs(r5.onrightfns + "`" + r5.srcwherefns)], !L.databases[r5.databaseid].tables[r5.tableid].dirty) && n5 && (r5.ix = n5), !r5.ix) {
                r5.ix = {};
                for (var a5, i5, o5 = {}, u5 = 0, l5 = r5.data.length; (a5 = r5.data[u5]) || r5.getfn && (a5 = r5.getfn(u5)) || u5 < l5; )
                  r5.getfn && !r5.dontcache && (r5.data[u5] = a5), o5[r5.alias || r5.tableid] = a5, r5.srcwherefn(o5, t5.params, L) && (i5 = r5.onrightfn(o5, t5.params, L), (r5.ix[i5] || (r5.ix[i5] = [])).push(a5)), u5++;
                r5.databaseid && L.databases[r5.databaseid].tables[r5.tableid] && (L.databases[r5.databaseid].tables[r5.tableid].indices[Rs(r5.onrightfns + "`" + r5.srcwherefns)] = r5.ix);
              }
            } else if (r5.wxleftfn) {
              if (L.databases[r5.databaseid].engineid || (n5 = L.databases[r5.databaseid].tables[r5.tableid].indices[Rs(r5.wxleftfns + "`")]), !L.databases[r5.databaseid].tables[r5.tableid].dirty && n5)
                r5.ix = n5, r5.data = r5.ix[r5.wxrightfn(null, t5.params, L)];
              else {
                for (r5.ix = {}, o5 = {}, u5 = 0, l5 = r5.data.length; (a5 = r5.data[u5]) || r5.getfn && (a5 = r5.getfn(u5)) || u5 < l5; )
                  r5.getfn && !r5.dontcache && (r5.data[u5] = a5), o5[r5.alias || r5.tableid] = r5.data[u5], i5 = r5.wxleftfn(o5, t5.params, L), (r5.ix[i5] || (r5.ix[i5] = [])).push(r5.data[u5]), u5++;
                L.databases[r5.databaseid].engineid || (L.databases[r5.databaseid].tables[r5.tableid].indices[Rs(r5.wxleftfns + "`")] = r5.ix);
              }
              r5.srcwherefns && (r5.data ? (o5 = {}, r5.data = r5.data.filter(function(e6) {
                return o5[r5.alias] = e6, r5.srcwherefn(o5, t5.params, L);
              })) : r5.data = []);
            } else if (r5.srcwherefns && !r5.dontcache)
              if (r5.data) {
                for (var o5 = {}, c5 = (r5.data = r5.data.filter(function(e6) {
                  return o5[r5.alias] = e6, r5.srcwherefn(o5, t5.params, L);
                }), o5 = {}, u5 = 0, l5 = r5.data.length, []); (a5 = r5.data[u5]) || r5.getfn && (a5 = r5.getfn(u5)) || u5 < l5; )
                  r5.getfn && !r5.dontcache && (r5.data[u5] = a5), o5[r5.alias] = a5, r5.srcwherefn(o5, t5.params, L) && c5.push(a5), u5++;
                r5.data = c5;
              } else
                r5.data = [];
            r5.databaseid && L.databases[r5.databaseid].tables[r5.tableid];
          }
        };
        function Ks(e5, t5) {
          if (void 0 !== t5 && "number" != typeof t5 && "string" != typeof t5 && "boolean" != typeof t5) {
            var s5 = e5.modifier || L.options.modifier, n5 = e5.columns;
            if (void 0 === n5 || 0 == n5.length)
              if (0 < t5.length) {
                for (var r5 = {}, a5 = Math.min(t5.length, L.options.columnlookup || 10) - 1; 0 <= a5; a5--)
                  for (var i5 in t5[a5])
                    r5[i5] = true;
                n5 = Object.keys(r5).map(function(e6) {
                  return { columnid: e6 };
                });
              } else
                n5 = [];
            if ("VALUE" === s5)
              t5 = 0 < t5.length ? (i5 = n5 && 0 < n5.length ? n5[0].columnid : Object.keys(t5[0])[0], t5[0][i5]) : void 0;
            else if ("ROW" === s5)
              if (0 < t5.length) {
                var o5 = [];
                for (i5 in t5[0])
                  o5.push(t5[0][i5]);
                t5 = o5;
              } else
                t5 = void 0;
            else if ("COLUMN" === s5) {
              var u5 = [];
              if (0 < t5.length) {
                i5 = n5 && 0 < n5.length ? n5[0].columnid : Object.keys(t5[0])[0];
                for (var a5 = 0, l5 = t5.length; a5 < l5; a5++)
                  u5.push(t5[a5][i5]);
              }
              t5 = u5;
            } else if ("MATRIX" === s5) {
              for (u5 = [], a5 = 0; a5 < t5.length; a5++) {
                for (var o5 = [], c5 = t5[a5], h5 = 0; h5 < n5.length; h5++)
                  o5.push(c5[n5[h5].columnid]);
                u5.push(o5);
              }
              t5 = u5;
            } else if ("INDEX" === s5) {
              for (var u5 = {}, d5 = n5 && 0 < n5.length ? (i5 = n5[0].columnid, n5[1].columnid) : (i5 = (e5 = Object.keys(t5[0]))[0], e5[1]), a5 = 0, l5 = t5.length; a5 < l5; a5++)
                u5[t5[a5][i5]] = t5[a5][d5];
              t5 = u5;
            } else if ("RECORDSET" === s5)
              t5 = new L.Recordset({ columns: n5, data: t5 });
            else if ("TEXTSTRING" === s5) {
              i5 = n5 && 0 < n5.length ? n5[0].columnid : Object.keys(t5[0])[0];
              for (a5 = 0, l5 = t5.length; a5 < l5; a5++)
                t5[a5] = t5[a5][i5];
              t5 = t5.join("\n");
            }
          }
          return t5;
        }
        function Qs(r5, e5, a5) {
          var i5 = "", o5 = [], u5 = {};
          return e5.forEach(function(n5) {
            var e6;
            r5.ixsources = {}, r5.sources.forEach(function(e7) {
              r5.ixsources[e7.alias] = e7;
            }), r5.ixsources[n5] && (e6 = r5.ixsources[n5].columns), a5 && "json" == L.options.joinstar && (i5 += "r['" + n5 + "']={};"), e6 && 0 < e6.length ? e6.forEach(function(e7) {
              a5 && "underscore" == L.options.joinstar ? o5.push("'" + n5 + "_" + e7.columnid + "':p['" + n5 + "']['" + e7.columnid + "']") : a5 && "json" == L.options.joinstar ? i5 += "r['" + n5 + "']['" + e7.columnid + "']=p['" + n5 + "']['" + e7.columnid + "'];" : (s5 = "p['" + n5 + "']['" + e7.columnid + "']", u5[e7.columnid] ? (t5 = s5 + " !== undefined ? " + s5 + " : " + u5[e7.columnid].value, o5[u5[e7.columnid].id] = u5[e7.columnid].key + t5, u5[e7.columnid].value = t5) : (t5 = "'" + e7.columnid + "':", o5.push(t5 + s5), u5[e7.columnid] = { id: o5.length - 1, value: s5, key: t5 })), r5.selectColumns[Ss(e7.columnid)] = true;
              var t5, s5 = { columnid: e7.columnid, dbtypeid: e7.dbtypeid, dbsize: e7.dbsize, dbprecision: e7.dbprecision, dbenum: e7.dbenum };
              r5.columns.push(s5), r5.xcolumns[s5.columnid] = s5;
            }) : (i5 += 'var w=p["' + n5 + '"];for(var k in w){r[k]=w[k]};', r5.dirtyColumns = true);
          }), { s: o5.join(","), sp: i5 };
        }
        M.Select = class {
          constructor(e5) {
            Object.assign(this, e5);
          }
          toString() {
            var e5 = "";
            return this.explain && (e5 += "EXPLAIN "), e5 += "SELECT ", this.modifier && (e5 += this.modifier + " "), this.distinct && (e5 += "DISTINCT "), this.top && (e5 += "TOP " + this.top.value + " ", this.percent) && (e5 += "PERCENT "), e5 += this.columns.map(function(e6) {
              var t5 = e6.toString();
              return void 0 !== e6.as && (t5 += " AS " + e6.as), t5;
            }).join(", "), this.from && (e5 += " FROM " + this.from.map(function(e6) {
              var t5 = e6.toString();
              return e6.as && (t5 += " AS " + e6.as), t5;
            }).join(",")), this.joins && (e5 += this.joins.map(function(e6) {
              var t5 = " ";
              if (e6.joinmode && (t5 += e6.joinmode + " "), e6.table)
                t5 += "JOIN " + e6.table.toString();
              else if (e6.select)
                t5 += "JOIN (" + e6.select.toString() + ")";
              else {
                if (!(e6 instanceof L.yy.Apply))
                  throw new Error("Wrong type in JOIN mode");
                t5 += e6.toString();
              }
              return e6.as && (t5 += " AS " + e6.as), e6.using && (t5 += " USING " + e6.using.toString()), e6.on && (t5 += " ON " + e6.on.toString()), t5;
            }).join("")), this.where && (e5 += " WHERE " + this.where.toString()), this.group && 0 < this.group.length && (e5 += " GROUP BY " + this.group.map(function(e6) {
              return e6.toString();
            }).join(", ")), this.having && (e5 += " HAVING " + this.having.toString()), this.order && 0 < this.order.length && (e5 += " ORDER BY " + this.order.map(function(e6) {
              return e6.toString();
            }).join(", ")), this.limit && (e5 += " LIMIT " + this.limit.value), this.offset && (e5 += " OFFSET " + this.offset.value), this.union && (e5 += " UNION " + (this.corresponding ? "CORRESPONDING " : "") + this.union.toString()), this.unionall && (e5 += " UNION ALL " + (this.corresponding ? "CORRESPONDING " : "") + this.unionall.toString()), this.except && (e5 += " EXCEPT " + (this.corresponding ? "CORRESPONDING " : "") + this.except.toString()), this.intersect && (e5 += " INTERSECT " + (this.corresponding ? "CORRESPONDING " : "") + this.intersect.toString()), e5;
          }
          toJS(e5) {
            return "alasql.utils.flatArray(this.queriesfn[" + (this.queriesidx - 1) + "](this.params,null," + e5 + "))[0]";
          }
          compile(e5, t5) {
            function s5(e6, i5, t6) {
              var s6, n6, r5, a5, o5;
              return u5.params = e6, e6 = t6, t6 = function(e7, t7) {
                if (t7)
                  return i5(t7, null);
                if (0 < u5.rownums.length)
                  for (var s7 = 0, n7 = e7.length; s7 < n7; s7++)
                    for (var r6 = 0, a6 = u5.rownums.length; r6 < a6; r6++)
                      e7[s7][u5.rownums[r6]] = s7 + 1;
                t7 = Ks(u5, e7);
                return i5 && i5(t7), t7;
              }, (s6 = u5).sources.length, s6.sourceslen = s6.sources.length, o5 = s6.sourceslen, (s6.query = s6).A = n6, s6.B = r5, s6.cb = t6, s6.oldscope = e6, s6.queriesfn && (s6.sourceslen += s6.queriesfn.length, o5 += s6.queriesfn.length, s6.queriesdata = [], s6.queriesfn.forEach(function(e7, t7) {
                e7.query.params = s6.params, Ys([], -t7 - 1, s6);
              })), n6 = e6 ? Ds(e6) : {}, s6.scope = n6, s6.sources.forEach(function(e7, t7) {
                e7.query = s6;
                t7 = e7.datafn(s6, s6.params, Ys, t7, L);
                void 0 !== t7 && ((s6.intofn || s6.intoallfn) && Array.isArray(t7) && (t7 = t7.length), a5 = t7), e7.queriesdata = s6.queriesdata;
              }), a5 = 0 != s6.sources.length && 0 !== o5 ? a5 : Ws(s6);
            }
            var n5 = L.databases[e5], u5 = new Hs();
            u5.removeKeys = [], u5.aggrKeys = [], u5.explain = this.explain, u5.explaination = [], u5.explid = 1, u5.modifier = this.modifier, u5.database = n5, this.compileWhereExists(u5), this.compileQueries(u5), u5.defcols = this.compileDefCols(u5, e5), u5.fromfn = this.compileFrom(u5), this.joins && this.compileJoins(u5), u5.rownums = [], this.compileSelectGroup0(u5), this.group || 0 < u5.selectGroup.length ? u5.selectgfns = this.compileSelectGroup1(u5) : u5.selectfns = this.compileSelect1(u5, t5), this.compileRemoveColumns(u5), this.where && this.compileWhereJoins(u5), u5.wherefn = this.compileWhere(u5), (this.group || 0 < u5.selectGroup.length) && (u5.groupfn = this.compileGroup(u5)), this.having && (u5.havingfn = this.compileHaving(u5)), this.order && (u5.orderfn = this.compileOrder(u5, t5)), this.group || 0 < u5.selectGroup.length ? u5.selectgfn = this.compileSelectGroup2(u5) : u5.selectfn = this.compileSelect2(u5, t5), u5.distinct = this.distinct, this.pivot && (u5.pivotfn = this.compilePivot(u5)), this.unpivot && (u5.pivotfn = this.compileUnpivot(u5)), this.top ? u5.limit = this.top.value : this.limit && (u5.limit = this.limit.value, this.offset) && (u5.offset = this.offset.value), u5.percent = this.percent, u5.corresponding = this.corresponding, this.union ? (u5.unionfn = this.union.compile(e5), this.union.order ? u5.orderfn = this.union.compileOrder(u5, t5) : u5.orderfn = null) : this.unionall ? (u5.unionallfn = this.unionall.compile(e5), this.unionall.order ? u5.orderfn = this.unionall.compileOrder(u5, t5) : u5.orderfn = null) : this.except ? (u5.exceptfn = this.except.compile(e5), this.except.order ? u5.orderfn = this.except.compileOrder(u5, t5) : u5.orderfn = null) : this.intersect && (u5.intersectfn = this.intersect.compile(e5), this.intersect.order ? u5.intersectfn = this.intersect.compileOrder(u5, t5) : u5.orderfn = null), this.into && (this.into instanceof M.Table ? L.options.autocommit && L.databases[this.into.databaseid || e5].engineid ? u5.intoallfns = 'return alasql.engines["' + L.databases[this.into.databaseid || e5].engineid + '"].intoTable("' + (this.into.databaseid || e5) + '","' + this.into.tableid + '",this.data, columns, cb);' : u5.intofns = "alasql.databases['" + (this.into.databaseid || e5) + "'].tables['" + this.into.tableid + "'].data.push(r);" : this.into instanceof M.VarValue ? u5.intoallfns = 'alasql.vars["' + this.into.variable + '"]=this.data;res=this.data.length;if(cb)res=cb(res);return res;' : this.into instanceof M.FuncValue ? (n5 = "return alasql.into[" + JSON.stringify(this.into.funcid.toUpperCase()) + "](", this.into.args && 0 < this.into.args.length ? (n5 += this.into.args[0].toJS() + ",", 1 < this.into.args.length ? n5 += this.into.args[1].toJS() + "," : n5 += "undefined,") : n5 += "undefined, undefined,", u5.intoallfns = n5 + "this.data,columns,cb)") : this.into instanceof M.ParamValue && (u5.intofns = "params['" + this.into.param + "'].push(r)"), u5.intofns ? u5.intofn = new Function("r,i,params,alasql", "var y;" + u5.intofns) : u5.intoallfns && (u5.intoallfn = new Function("columns,cb,params,alasql", "var y;" + u5.intoallfns)));
            return s5.query = u5, s5;
          }
          execute(e5, t5, s5) {
            return this.compile(e5)(t5, s5);
          }
          compileWhereExists(t5) {
            this.exists && (t5.existsfn = this.exists.map(function(e5) {
              e5 = e5.compile(t5.database.databaseid);
              return e5.query.modifier = "RECORDSET", e5;
            }));
          }
          compileQueries(t5) {
            this.queries && (t5.queriesfn = this.queries.map(function(e5) {
              e5 = e5.compile(t5.database.databaseid);
              return e5.query.modifier = "RECORDSET", e5;
            }));
          }
        }, M.ExistsValue = class {
          constructor(e5) {
            Object.assign(this, e5);
          }
          toString() {
            return "EXISTS(" + this.value.toString() + ")";
          }
          toType() {
            return "boolean";
          }
          toJS(e5, t5, s5) {
            return "this.existsfn[" + this.existsidx + "](params,null," + e5 + ").data.length";
          }
        }, L.precompile = function(t5, s5, e5) {
          t5 && (t5.params = e5, t5.queries && (t5.queriesfn = t5.queries.map(function(e6) {
            e6 = e6.compile(s5 || t5.database.databaseid);
            return e6.query.modifier = "RECORDSET", e6;
          })), t5.exists) && (t5.existsfn = t5.exists.map(function(e6) {
            e6 = e6.compile(s5 || t5.database.databaseid);
            return e6.query.modifier = "RECORDSET", e6;
          }));
        }, M.Select.prototype.compileFrom = function(s5) {
          s5.sources = [], s5.aliases = {}, this.from && (this.from.forEach(function(i5) {
            var e5 = "", t5 = i5.as || i5.tableid;
            if (i5 instanceof M.Table)
              s5.aliases[t5] = { tableid: i5.tableid, databaseid: i5.databaseid || s5.database.databaseid, type: "table" };
            else if (i5 instanceof M.Select)
              s5.aliases[t5] = { type: "subquery" };
            else if (i5 instanceof M.Search)
              s5.aliases[t5] = { type: "subsearch" };
            else if (i5 instanceof M.ParamValue)
              s5.aliases[t5] = { type: "paramvalue" };
            else if (i5 instanceof M.FuncValue)
              s5.aliases[t5] = { type: "funcvalue" };
            else if (i5 instanceof M.VarValue)
              s5.aliases[t5] = { type: "varvalue" };
            else if (i5 instanceof M.FromData)
              s5.aliases[t5] = { type: "fromdata" };
            else if (i5 instanceof M.Json)
              s5.aliases[t5] = { type: "json" };
            else {
              if (!i5.inserted)
                throw new Error("Wrong table at FROM");
              s5.aliases[t5] = { type: "inserted" };
            }
            var o5 = { alias: t5, databaseid: i5.databaseid || s5.database.databaseid, tableid: i5.tableid, joinmode: "INNER", onmiddlefn: ms, srcwherefns: "", srcwherefn: ms };
            if (i5 instanceof M.Table)
              o5.columns = L.databases[o5.databaseid].tables[o5.tableid].columns, L.options.autocommit && L.databases[o5.databaseid].engineid && !L.databases[o5.databaseid].tables[o5.tableid].view ? o5.datafn = function(e6, t6, s6, n5, r5) {
                return r5.engines[r5.databases[o5.databaseid].engineid].fromTable(o5.databaseid, o5.tableid, s6, n5, e6);
              } : L.databases[o5.databaseid].tables[o5.tableid].view ? o5.datafn = function(e6, t6, s6, n5, r5) {
                r5 = r5.databases[o5.databaseid].tables[o5.tableid].select(t6);
                return r5 = s6 ? s6(r5, n5, e6) : r5;
              } : o5.datafn = function(e6, t6, s6, n5, r5) {
                r5 = r5.databases[o5.databaseid].tables[o5.tableid].data;
                return r5 = s6 ? s6(r5, n5, e6) : r5;
              };
            else if (i5 instanceof M.Select)
              o5.subquery = i5.compile(s5.database.databaseid), void 0 === o5.subquery.query.modifier && (o5.subquery.query.modifier = "RECORDSET"), o5.columns = o5.subquery.query.columns, o5.datafn = function(t6, e6, s6, n5, r5) {
                var a5;
                return o5.subquery(t6.params, function(e7) {
                  return a5 = e7.data, a5 = s6 ? s6(a5, n5, t6) : a5;
                }), a5;
              };
            else if (i5 instanceof M.Search)
              o5.subsearch = i5, o5.columns = [], o5.datafn = function(t6, e6, s6, n5, r5) {
                var a5;
                return o5.subsearch.execute(t6.database.databaseid, t6.params, function(e7) {
                  return a5 = e7, a5 = s6 ? s6(a5, n5, t6) : a5;
                }), a5;
              };
            else if (i5 instanceof M.ParamValue)
              e5 = "var res = alasql.prepareFromData(params['" + i5.param + "']", i5.array && (e5 += ",true"), e5 += ");if(cb)res=cb(res,idx,query);return res", o5.datafn = new Function("query,params,cb,idx,alasql", e5);
            else if (i5.inserted)
              e5 = "var res = alasql.prepareFromData(alasql.inserted", i5.array && (e5 += ",true"), e5 += ");if(cb)res=cb(res,idx,query);return res", o5.datafn = new Function("query,params,cb,idx,alasql", e5);
            else if (i5 instanceof M.Json)
              e5 = "var res = alasql.prepareFromData(" + i5.toJS(), i5.array && (e5 += ",true"), e5 += ");if(cb)res=cb(res,idx,query);return res", o5.datafn = new Function("query,params,cb,idx,alasql", e5);
            else if (i5 instanceof M.VarValue)
              e5 = "var res = alasql.prepareFromData(alasql.vars['" + i5.variable + "']", i5.array && (e5 += ",true"), e5 += ");if(cb)res=cb(res,idx,query);return res", o5.datafn = new Function("query,params,cb,idx,alasql", e5);
            else if (i5 instanceof M.FuncValue)
              e5 = "var res=alasql.from[" + JSON.stringify(i5.funcid.toUpperCase()) + "](", i5.args && 0 < i5.args.length ? (i5.args[0] ? e5 += i5.args[0].toJS("query.oldscope") + "," : e5 += "null,", i5.args[1] ? e5 += i5.args[1].toJS("query.oldscope") + "," : e5 += "null,") : e5 += "null,null,", e5 += "cb,idx,query);/*if(cb)res=cb(res,idx,query);*/return res", o5.datafn = new Function("query, params, cb, idx, alasql", e5);
            else {
              if (!(i5 instanceof M.FromData))
                throw new Error("Wrong table at FROM");
              o5.datafn = function(e6, t6, s6, n5, r5) {
                var a5 = i5.data;
                return a5 = s6 ? s6(a5, n5, e6) : a5;
              };
            }
            s5.sources.push(o5);
          }), s5.defaultTableid = s5.sources[0].alias);
        }, L.prepareFromData = function(e5, t5) {
          var s5, n5, r5 = e5;
          if ("string" == typeof e5) {
            if (r5 = e5.split(/\r?\n/), t5)
              for (s5 = 0, n5 = r5.length; s5 < n5; s5++)
                r5[s5] = [r5[s5]];
          } else if (t5)
            for (r5 = [], s5 = 0, n5 = e5.length; s5 < n5; s5++)
              r5.push([e5[s5]]);
          else if ("object" == typeof e5 && !Array.isArray(e5))
            if ("undefined" != typeof Mongo && void 0 !== Mongo.Collection && e5 instanceof Mongo.Collection)
              r5 = e5.find().fetch();
            else
              for (var a5 in r5 = [], e5)
                e5.hasOwnProperty(a5) && r5.push([a5, e5[a5]]);
          return r5;
        }, M.Select.prototype.compileJoins = function(c5) {
          this.joins.forEach(function(e5) {
            var a5;
            if ("CROSS" === e5.joinmode) {
              if (e5.using || e5.on)
                throw new Error("CROSS JOIN cannot have USING or ON clauses");
              e5.joinmode = "INNER";
            }
            if (e5 instanceof M.Apply)
              (a5 = { alias: e5.as, applymode: e5.applymode, onmiddlefn: ms, srcwherefns: "", srcwherefn: ms, columns: [] }).applyselect = e5.select.compile(c5.database.databaseid), a5.columns = a5.applyselect.query.columns, a5.datafn = function(e6, t6, s6, n6, r6) {
                var a6;
                return a6 = s6 ? s6(a6, n6, e6) : a6;
              };
            else {
              if (e5.table) {
                if (l5 = e5.table, a5 = { alias: e5.as || l5.tableid, databaseid: l5.databaseid || c5.database.databaseid, tableid: l5.tableid, joinmode: e5.joinmode, onmiddlefn: ms, srcwherefns: "", srcwherefn: ms, columns: [] }, !L.databases[a5.databaseid].tables[a5.tableid])
                  throw new Error("Table '" + a5.tableid + "' is not exists in database '" + a5.databaseid + "'");
                a5.columns = L.databases[a5.databaseid].tables[a5.tableid].columns, L.options.autocommit && L.databases[a5.databaseid].engineid ? a5.datafn = function(e6, t6, s6, n6, r6) {
                  return r6.engines[r6.databases[a5.databaseid].engineid].fromTable(a5.databaseid, a5.tableid, s6, n6, e6);
                } : L.databases[a5.databaseid].tables[a5.tableid].view ? a5.datafn = function(e6, t6, s6, n6, r6) {
                  r6 = r6.databases[a5.databaseid].tables[a5.tableid].select(t6);
                  return r6 = s6 ? s6(r6, n6, e6) : r6;
                } : a5.datafn = function(e6, t6, s6, n6, r6) {
                  r6 = r6.databases[a5.databaseid].tables[a5.tableid].data;
                  return r6 = s6 ? s6(r6, n6, e6) : r6;
                }, c5.aliases[a5.alias] = { tableid: l5.tableid, databaseid: l5.databaseid || c5.database.databaseid };
              } else
                e5.select ? (l5 = e5.select, (a5 = { alias: e5.as, joinmode: e5.joinmode, onmiddlefn: ms, srcwherefns: "", srcwherefn: ms, columns: [] }).subquery = l5.compile(c5.database.databaseid), void 0 === a5.subquery.query.modifier && (a5.subquery.query.modifier = "RECORDSET"), a5.columns = a5.subquery.query.columns, a5.datafn = function(e6, t6, s6, n6, r6) {
                  return a5.subquery(e6.params, null, s6, n6).data;
                }, c5.aliases[a5.alias] = { type: "subquery" }) : e5.param ? (a5 = { alias: e5.as, joinmode: e5.joinmode, onmiddlefn: ms, srcwherefns: "", srcwherefn: ms }, u5 = "var res=alasql.prepareFromData(params['" + e5.param.param + "']", e5.array && (u5 += ",true"), u5 += ");if(cb)res=cb(res, idx, query);return res", a5.datafn = new Function("query,params,cb,idx, alasql", u5), c5.aliases[a5.alias] = { type: "paramvalue" }) : e5.variable ? (a5 = { alias: e5.as, joinmode: e5.joinmode, onmiddlefn: ms, srcwherefns: "", srcwherefn: ms }, u5 = "var res=alasql.prepareFromData(alasql.vars['" + e5.variable + "']", e5.array && (u5 += ",true"), u5 += ");if(cb)res=cb(res, idx, query);return res", a5.datafn = new Function("query,params,cb,idx, alasql", u5), c5.aliases[a5.alias] = { type: "varvalue" }) : e5.func && (a5 = { alias: e5.as, joinmode: e5.joinmode, onmiddlefn: ms, srcwherefns: "", srcwherefn: ms }, l5 = "var res=alasql.from[" + JSON.stringify(e5.func.funcid.toUpperCase()) + "](", (u5 = e5.func.args) && 0 < u5.length ? (u5[0] ? l5 += u5[0].toJS("query.oldscope") + "," : l5 += "null,", u5[1] ? l5 += u5[1].toJS("query.oldscope") + "," : l5 += "null,") : l5 += "null,null,", l5 += "cb,idx,query);/*if(cb)res=cb(res,idx,query);*/return res", a5.datafn = new Function("query, params, cb, idx, alasql", l5), c5.aliases[a5.alias] = { type: "funcvalue" });
              var t5, s5, n5, r5, i5 = a5.alias;
              if (e5.natural) {
                if (e5.using || e5.on)
                  throw new Error("NATURAL JOIN cannot have USING or ON clauses");
                if (0 < c5.sources.length) {
                  var o5 = c5.sources[c5.sources.length - 1], u5 = L.databases[o5.databaseid].tables[o5.tableid], l5 = L.databases[a5.databaseid].tables[a5.tableid];
                  if (!u5 || !l5)
                    throw new Error("In this version of Alasql NATURAL JOIN works for tables with predefined columns only");
                  var u5 = u5.columns.map(function(e6) {
                    return e6.columnid;
                  }), l5 = l5.columns.map(function(e6) {
                    return e6.columnid;
                  });
                  e5.using = $s(u5, l5).map(function(e6) {
                    return { columnid: e6 };
                  });
                }
              }
              e5.using ? (o5 = c5.sources[c5.sources.length - 1], a5.onleftfns = e5.using.map(function(e6) {
                return "p['" + (o5.alias || o5.tableid) + "']['" + e6.columnid + "']";
              }).join('+"`"+'), a5.onleftfn = new Function("p,params,alasql", "var y;return " + a5.onleftfns), a5.onrightfns = e5.using.map(function(e6) {
                return "p['" + (a5.alias || a5.tableid) + "']['" + e6.columnid + "']";
              }).join('+"`"+'), a5.onrightfn = new Function("p,params,alasql", "var y;return " + a5.onrightfns), a5.optimization = "ix") : e5.on && (e5.on instanceof M.Op && "=" === e5.on.op && !e5.on.allsome ? (t5 = l5 = u5 = "", s5 = !(a5.optimization = "ix"), n5 = e5.on.left.toJS("p", c5.defaultTableid, c5.defcols), r5 = e5.on.right.toJS("p", c5.defaultTableid, c5.defcols), -1 < n5.indexOf("p['" + i5 + "']") && !(-1 < r5.indexOf("p['" + i5 + "']")) ? (n5.match(/p\['.*?'\]/g) || []).every(function(e6) {
                return e6 === "p['" + i5 + "']";
              }) ? l5 = n5 : s5 = true : !(-1 < n5.indexOf("p['" + i5 + "']")) && -1 < r5.indexOf("p['" + i5 + "']") && (r5.match(/p\['.*?'\]/g) || []).every(function(e6) {
                return e6 === "p['" + i5 + "']";
              }) ? u5 = n5 : s5 = true, -1 < r5.indexOf("p['" + i5 + "']") && !(-1 < n5.indexOf("p['" + i5 + "']")) ? (r5.match(/p\['.*?'\]/g) || []).every(function(e6) {
                return e6 === "p['" + i5 + "']";
              }) ? l5 = r5 : s5 = true : !(-1 < r5.indexOf("p['" + i5 + "']")) && -1 < n5.indexOf("p['" + i5 + "']") && (n5.match(/p\['.*?'\]/g) || []).every(function(e6) {
                return e6 === "p['" + i5 + "']";
              }) ? u5 = r5 : s5 = true, s5 && (u5 = l5 = "", t5 = e5.on.toJS("p", c5.defaultTableid, c5.defcols), a5.optimization = "no"), a5.onleftfns = u5, a5.onrightfns = l5, a5.onmiddlefns = t5 || "true", a5.onleftfn = new Function("p,params,alasql", "var y;return " + a5.onleftfns), a5.onrightfn = new Function("p,params,alasql", "var y;return " + a5.onrightfns), a5.onmiddlefn = new Function("p,params,alasql", "var y;return " + a5.onmiddlefns)) : (a5.optimization = "no", a5.onmiddlefns = e5.on.toJS("p", c5.defaultTableid, c5.defcols), a5.onmiddlefn = new Function("p,params,alasql", "var y;return " + e5.on.toJS("p", c5.defaultTableid, c5.defcols))));
            }
            c5.sources.push(a5);
          });
        }, M.Select.prototype.compileWhere = function(e5) {
          var t5;
          return this.where ? "function" == typeof this.where ? this.where : (t5 = this.where.toJS("p", e5.defaultTableid, e5.defcols), e5.wherefns = t5, new Function("p,params,alasql", "var y;return " + t5)) : function() {
            return true;
          };
        }, M.Select.prototype.compileWhereJoins = function(e5) {
        }, M.Select.prototype.compileGroup = function(i5) {
          o5 = 0 < i5.sources.length ? i5.sources[0].alias : "";
          var o5, u5 = i5.defcols, e5 = [[]], s5 = (this.group && (e5 = sn(this.group, i5)), []), n5 = (e5.forEach(function(e6) {
            s5 = Is(s5, e6);
          }), i5.allgroups = s5, i5.ingroup = [], "");
          return e5.forEach(function(e6) {
            n5 += "var g=this.xgroups[";
            var t5 = e6.map(function(e7) {
              var t6 = e7.split("	")[0], e7 = e7.split("	")[1];
              return "" === t6 ? "1" : (i5.ingroup.push(t6), e7);
            }), t5 = (0 === t5.length && (t5 = ["''"]), n5 = (n5 = (n5 = n5 + t5.join('+"`"+') + "];if(!g) {this.groups.push((g=this.xgroups[") + t5.join('+"`"+') + "] = {") + e6.map(function(e7) {
              var t6 = e7.split("	")[0], e7 = e7.split("	")[1];
              return "" === t6 ? "" : "'" + t6 + "':" + e7 + ",";
            }).join(""), ws(s5, e6)), a5 = (n5 += t5.map(function(e7) {
              return "'" + e7.split("	")[0] + "':null,";
            }).join(""), ""), e6 = "";
            void 0 !== i5.groupStar && (e6 += "for(var f in p['" + i5.groupStar + "']) {g[f]=p['" + i5.groupStar + "'][f];};"), n5 = (n5 = (n5 += i5.selectGroup.map(function(e7) {
              var t6, s6 = e7.expression.toJS("p", o5, u5), n6 = e7.nick, r5 = (e8) => {
                return e8.args[0].toJS("p", o5, u5);
              };
              return e7 instanceof M.AggrValue ? (e7.distinct && (a5 += ",g['$$_VALUES_" + n6 + "']={},g['$$_VALUES_" + n6 + "'][" + s6 + "]=true"), "SUM" === e7.aggregatorid ? "funcid" in e7.expression ? `'${n6}':(${t6 = r5(e7.expression)})|| typeof ${t6} == 'number' ? ${t6} : null,` : `'${n6}':(${s6})|| typeof ${s6} == 'number' ? ${s6} : null,` : "TOTAL" === e7.aggregatorid ? "funcid" in e7.expression ? `'${n6}':(${t6 = r5(e7.expression)}) || typeof ${t6} == 'number' ? 
							${t6} : ${t6} == 'string' && typeof Number(${t6}) == 'number' ? Number(${t6}) : 
							typeof ${t6} == 'boolean' ?  Number(${t6}) : 0,` : `'${n6}':(${s6})|| typeof ${s6} == 'number' ? 
							${s6} : ${s6} == 'string' && typeof Number(${s6}) == 'number' ? Number(${s6}) : 
							typeof ${s6} === 'boolean' ?  Number(${s6}) : 0,` : "FIRST" === e7.aggregatorid || "LAST" === e7.aggregatorid ? "'" + n6 + "':" + s6 + "," : "MIN" === e7.aggregatorid ? "funcid" in e7.expression ? `'${n6}': (typeof ${t6 = r5(e7.expression)} == 'number' ? ${t6} : typeof ${t6} == 'object' ? 
							typeof Number(${t6}) == 'number' && ${t6}!== null? ${t6} : null : null),` : `'${n6}': (typeof ${s6} == 'number' ? ${s6} : typeof ${s6} == 'object' ? 
							typeof Number(${s6}) == 'number' && ${s6}!== null? ${s6} : null : null),` : "MAX" === e7.aggregatorid ? "funcid" in e7.expression ? `'${n6}' : (typeof ${t6 = r5(e7.expression)} == 'number' ? ${t6} : typeof ${t6} == 'object' ? 
							typeof Number(${t6}) == 'number' ? ${t6} : null : null),` : `'${n6}' : (typeof ${s6} == 'number' ? ${s6} : typeof ${s6} == 'object' ? 
							typeof Number(${s6}) == 'number' ? ${s6} : null : null),` : "ARRAY" === e7.aggregatorid ? "'" + n6 + "':[" + s6 + "]," : "COUNT" === e7.aggregatorid ? "*" === e7.expression.columnid ? "'" + n6 + "':1," : "'" + n6 + "':(typeof " + s6 + ' == "undefined" || ' + s6 + " === null) ? 0 : 1," : "AVG" === e7.aggregatorid ? (i5.removeKeys.push("_SUM_" + n6), i5.removeKeys.push("_COUNT_" + n6), "'" + n6 + "':" + s6 + ",'_SUM_" + n6 + "':(" + s6 + ")||0,'_COUNT_" + n6 + "':(typeof " + s6 + ' == "undefined" || ' + s6 + " === null) ? 0 : 1,") : "AGGR" === e7.aggregatorid ? (a5 += ",g['" + n6 + "']=" + e7.expression.toJS("g", -1), "") : "REDUCE" === e7.aggregatorid ? (i5.aggrKeys.push(e7), "'" + n6 + "':alasql.aggr['" + e7.funcid + "'](" + s6 + ",undefined,1),") : "") : "";
            }).join("")) + "}" + a5 + ",g));" + e6 + "} else {") + i5.selectGroup.map(function(e7) {
              var t6, s6, n6, r5 = e7.nick, a6 = e7.expression.toJS("p", o5, u5), i6 = (e8) => {
                return e8.args[0].toJS("p", o5, u5);
              };
              return e7 instanceof M.AggrValue ? (s6 = t6 = "", e7.distinct && (t6 = "if(typeof " + a6 + `!="undefined" && (!g['$$_VALUES_` + r5 + "'][" + a6 + "])) {", s6 = "g['$$_VALUES_" + r5 + "'][" + a6 + "]=true;}"), "SUM" === e7.aggregatorid ? "funcid" in e7.expression ? t6 + `if(g['${r5}'] == null && ${n6 = i6(e7.expression)} == null){g['${r5}'] = null}
							else if(typeof g['${r5}']!== 'object' && typeof g['${r5}']!== 'number' && typeof ${n6}!== 'object' && typeof ${n6}!== 'number'){g['${r5}'] = null}
							else if(typeof g['${r5}']!== 'object' && typeof g['${r5}']!== 'number' && typeof ${n6} == 'number'){g['${r5}'] = ${n6}}
							else if(typeof g['${r5}']!== 'number' && typeof ${n6}!== 'number' && typeof ${n6}!== 'object'){g['${r5}'] = g['${r5}']}
							else if((g['${r5}'] == null || (typeof g['${r5}']!== 'number' && typeof g['${r5}']!== 'object')) && (${n6} == null || (typeof ${n6}!== 'number' && typeof ${n6}!== 'object'))){g['${r5}'] = null}
							else if(typeof g['${r5}'] == 'number' && typeof ${n6} ==null){g['${r5}'] = g['${r5}']}
							else if(typeof g['${r5}'] == null && typeof ${n6} =='number'){g['${r5}'] = ${n6}}
							else{g['${r5}'] += ${n6}||0}` + s6 : t6 + `if(g['${r5}'] == null && ${a6} == null){g['${r5}'] = null} 
							 else if(typeof g['${r5}']!== 'object' && typeof g['${r5}']!== 'number'&& typeof ${a6}!== 'object' && typeof ${a6}!== 'number'){g['${r5}'] = null}
							 else if(typeof g['${r5}']!== 'object' && typeof g['${r5}']!== 'number' && typeof ${a6} == 'number'){g['${r5}'] = ${a6}}
							 else if(typeof g['${r5}']!== 'number' && typeof ${a6}!== 'number' && typeof ${a6}!== 'object'){g['${r5}'] = g['${r5}']}
							 else if((g['${r5}'] == null || (typeof g['${r5}']!== 'number' && typeof g['${r5}']!== 'object')) && (${a6} == null || (typeof ${a6}!== 'number' && typeof ${a6}!== 'object'))){g['${r5}'] = null}
							 else if(typeof g['${r5}'] == 'number' && typeof ${a6} ==null){g['${r5}'] = g['${r5}']}
							 else if(typeof g['${r5}'] == null && typeof ${a6} =='number'){g['${r5}'] = ${a6}}
							 else{g['${r5}'] += ${a6}||0}` + s6 : "TOTAL" === e7.aggregatorid ? "funcid" in e7.expression ? t6 + `if(typeof g['${r5}'] == 'string' && !isNaN(g['${r5}']) && typeof Number(g['${r5}']) == 'number' && 
						typeof ${n6 = i6(e7.expression)} == 'string' && !isNaN(${n6}) && typeof Number(${n6}) == 'number'){g['${r5}'] = Number(g['${r5}']) + Number(${n6})}
						else if(typeof g['${r5}'] == 'string' && typeof ${n6} == 'string'){g['${r5}'] = 0}
						else if(typeof g['${r5}'] == 'string' && typeof ${n6} == 'number'){g['${r5}'] = ${n6}}
						else if(typeof ${n6} == 'string' && typeof g['${r5}'] == 'number'){g['${r5}'] = g['${r5}']}
						else{g['${r5}'] += ${n6}||0}` + s6 : t6 + `if(typeof g['${r5}'] == 'string' && !isNaN(g['${r5}']) && typeof Number(g['${r5}']) == 'number' && 
						typeof ${a6} == 'string' && !isNaN(${a6}) && typeof Number(${a6}) == 'number'){g['${r5}'] = Number(g['${r5}']) + Number(${a6})}
						else if(typeof g['${r5}'] == 'string' && typeof ${a6} == 'string'){g['${r5}'] = 0}
						else if(typeof g['${r5}'] == 'string' && typeof ${a6} == 'number'){g['${r5}'] = ${a6}}
						else if(typeof ${a6} == 'string' && typeof g['${r5}'] == 'number'){g['${r5}'] = g['${r5}']}
						else{g['${r5}'] += ${a6}||0}` + s6 : "COUNT" === e7.aggregatorid ? "*" === e7.expression.columnid ? t6 + "g['" + r5 + "']++;" + s6 : t6 + "if(typeof " + a6 + '!="undefined" && ' + a6 + " !== null) g['" + r5 + "']++;" + s6 : "ARRAY" === e7.aggregatorid ? t6 + "g['" + r5 + "'].push(" + a6 + ");" + s6 : "MIN" === e7.aggregatorid ? "funcid" in e7.expression ? t6 + `if((g['${r5}'] == null && ${n6 = i6(e7.expression)}!== null) ? y = ${n6} : (g['${r5}']!== null && 
							${n6} == null) ? y = g['${r5}']:((y=${n6}) < g['${r5}'])){ if(typeof y == 'number')
							{g['${r5}'] = y;}else if(typeof y == 'object' && y instanceof Date){g['${r5}'] = y;}
							else if(typeof y == 'object' && typeof Number(y) == 'number'){g['${r5}'] = Number(y);}}
							else if(g['${r5}']!== null && typeof g['${r5}'] == 'object' && y instanceof Date){g['${r5}'] = g['${r5}']} 
							else if(g['${r5}']!== null && typeof g['${r5}'] == 'object'){g['${r5}'] = Number(g['${r5}'])}` + s6 : t6 + `if((g['${r5}'] == null && ${a6}!== null) ? y = ${a6} : (g['${r5}']!== null && 
							${a6} == null) ? y = g['${r5}']:((y=${a6}) < g['${r5}'])){ if(typeof y == 'number')
							{g['${r5}'] = y;}else if(typeof y == 'object' && y instanceof Date){g['${r5}'] = y;}
							else if(typeof y == 'object' && typeof Number(y) == 'number'){g['${r5}'] = Number(y);}}
							else if(g['${r5}']!== null && typeof g['${r5}'] == 'object' && y instanceof Date){g['${r5}'] = g['${r5}']} 
							else if(g['${r5}']!== null && typeof g['${r5}'] == 'object'){g['${r5}'] = Number(g['${r5}'])}` + s6 : "MAX" === e7.aggregatorid ? "funcid" in e7.expression ? t6 + `if((y=${i6(e7.expression)}) > g['${r5}']){if(typeof y == 'number'){g['${r5}'] = y;} 
							else if(typeof y == 'object' && y instanceof Date){g['${r5}'] = y;}
							else if(typeof y == 'object' && typeof Number(y) == 'number'){g['${r5}'] = Number(y);}}` + s6 : t6 + `if((y=${a6}) > g['${r5}']){if(typeof y == 'number'){g['${r5}'] = y;} 
							else if(typeof y == 'object' && y instanceof Date){g['${r5}'] = y;}
							else if(typeof y == 'object' && typeof Number(y) == 'number'){g['${r5}'] = Number(y);}}` + s6 : "FIRST" === e7.aggregatorid ? "" : "LAST" === e7.aggregatorid ? t6 + "g['" + r5 + "']=" + a6 + ";" + s6 : "AVG" === e7.aggregatorid ? t6 + "g['_SUM_" + r5 + "']+=(y=" + a6 + ")||0;g['_COUNT_" + r5 + `']+=(typeof y == "undefined" || y === null) ? 0 : 1;g['` + r5 + "']=g['_SUM_" + r5 + "']/g['_COUNT_" + r5 + "'];" + s6 : "AGGR" === e7.aggregatorid ? t6 + "g['" + r5 + "']=" + e7.expression.toJS("g", -1) + ";" + s6 : "REDUCE" === e7.aggregatorid ? t6 + "g['" + r5 + "']=alasql.aggr." + e7.funcid + "(" + a6 + ",g['" + r5 + "'],2);" + s6 : "") : "";
            }).join("") + "}";
          }), new Function("p,params,alasql", "var y;" + n5);
        }, M.Select.prototype.compileSelect1 = function(a5, i5) {
          var o5 = this, e5 = (a5.columns = [], a5.xcolumns = {}, a5.selectColumns = {}, a5.dirtyColumns = false, "var r={"), u5 = "", l5 = [];
          return this.columns.forEach(function(e6) {
            if (e6 instanceof M.Column)
              if ("*" === e6.columnid)
                e6.func ? u5 += "r=params['" + e6.param + "'](p['" + a5.sources[0].alias + "'],p,params,alasql);" : (e6.tableid ? (t5 = Qs(a5, [e6.tableid], false)).s && (l5 = l5.concat(t5.s)) : (t5 = Qs(a5, Object.keys(a5.aliases), true)).s && (l5 = l5.concat(t5.s)), u5 += t5.sp);
              else {
                var t5 = e6.tableid, s5 = e6.databaseid || a5.sources[0].databaseid || a5.database.databaseid;
                if (t5 = (t5 = t5 || a5.defcols[e6.columnid]) || a5.defaultTableid, "_" !== e6.columnid ? i5 && 1 < i5.length && Array.isArray(i5[0]) && 1 <= i5[0].length && i5[0][0].hasOwnProperty("sheetid") ? u5 = 'var r={};var w=p["' + t5 + '"];var cols=[' + o5.columns.map(function(e7) {
                  return "'" + e7.columnid + "'";
                }).join(",") + "];var colas=[" + o5.columns.map(function(e7) {
                  return "'" + (e7.as || e7.columnid) + "'";
                }).join(",") + "];for (var i=0;i<Object.keys(p['" + t5 + "']).length;i++) for(var k=0;k<cols.length;k++){if (!r.hasOwnProperty(i)) r[i]={}; r[i][colas[k]]=w[i][cols[k]];}" : l5.push("'" + Ss(e6.as || e6.columnid) + "':p['" + t5 + "']['" + e6.columnid + "']") : l5.push("'" + Ss(e6.as || e6.columnid) + "':p['" + t5 + "']"), a5.selectColumns[Ss(e6.as || e6.columnid)] = true, a5.aliases[t5] && "table" === a5.aliases[t5].type) {
                  if (!L.databases[s5].tables[a5.aliases[t5].tableid])
                    throw new Error("Table '" + t5 + "' does not exist in database");
                  var n5 = L.databases[s5].tables[a5.aliases[t5].tableid].columns, s5 = L.databases[s5].tables[a5.aliases[t5].tableid].xcolumns;
                  if (s5 && 0 < n5.length) {
                    t5 = s5[e6.columnid];
                    if (void 0 === t5)
                      throw new Error("Column does not exist: " + e6.columnid);
                    var r5 = { columnid: e6.as || e6.columnid, dbtypeid: t5.dbtypeid, dbsize: t5.dbsize, dbpecision: t5.dbprecision, dbenum: t5.dbenum };
                    a5.columns.push(r5), a5.xcolumns[r5.columnid] = r5;
                  } else {
                    var r5 = { columnid: e6.as || e6.columnid };
                    a5.columns.push(r5), a5.xcolumns[r5.columnid] = r5, a5.dirtyColumns = true;
                  }
                } else {
                  var r5 = { columnid: e6.as || e6.columnid };
                  a5.columns.push(r5), a5.xcolumns[r5.columnid] = r5;
                }
              }
            else
              r5 = (e6 instanceof M.AggrValue ? (o5.group || (o5.group = [""]), e6.as || (e6.as = Ss(e6.toString())), "SUM" === e6.aggregatorid || "MAX" === e6.aggregatorid || "MIN" === e6.aggregatorid || "FIRST" === e6.aggregatorid || "LAST" === e6.aggregatorid || "AVG" === e6.aggregatorid || "ARRAY" === e6.aggregatorid || "REDUCE" === e6.aggregatorid || "TOTAL" === e6.aggregatorid ? l5.push("'" + Ss(e6.as) + "':" + Es(e6.expression.toJS("p", a5.defaultTableid, a5.defcols))) : "COUNT" === e6.aggregatorid && l5.push("'" + Ss(e6.as) + "':1")) : (l5.push("'" + Ss(e6.as || e6.columnid || e6.toString()) + "':" + Es(e6.toJS("p", a5.defaultTableid, a5.defcols))), a5.selectColumns[Ss(e6.as || e6.columnid || e6.toString())] = true), { columnid: e6.as || e6.columnid || e6.toString() }), a5.columns.push(r5), a5.xcolumns[r5.columnid] = r5;
          }), e5 += l5.join(",") + "};" + u5;
        }, M.Select.prototype.compileSelect2 = function(s5, n5) {
          var r5 = s5.selectfns;
          return this.orderColumns && 0 < this.orderColumns.length && this.orderColumns.forEach(function(e5, t5) {
            t5 = "$$$" + t5;
            e5 instanceof M.Column && s5.xcolumns[e5.columnid] ? r5 += "r['" + t5 + "']=r['" + e5.columnid + "'];" : e5 instanceof M.ParamValue && s5.xcolumns[n5[e5.param]] ? r5 += "r['" + t5 + "']=r['" + n5[e5.param] + "'];" : r5 += "r['" + t5 + "']=" + e5.toJS("p", s5.defaultTableid, s5.defcols) + ";", s5.removeKeys.push(t5);
          }), new Function("p,params,alasql", "var y;" + r5 + "return r");
        }, M.Select.prototype.compileSelectGroup0 = function(a5) {
          var i5 = this;
          i5.columns.forEach(function(t5, e5) {
            if (t5 instanceof M.Column && "*" === t5.columnid)
              a5.groupStar = t5.tableid || "default";
            else {
              for (var s5, n5 = t5 instanceof M.Column ? Ss(t5.columnid) : Ss(t5.toString(true)), r5 = 0; r5 < e5; r5++)
                if (n5 === i5.columns[r5].nick) {
                  n5 = i5.columns[r5].nick + ":" + e5;
                  break;
                }
              t5.nick = n5, i5.group && -1 < (s5 = i5.group.findIndex(function(e6) {
                return e6.columnid === t5.columnid && e6.tableid === t5.tableid;
              })) && (i5.group[s5].nick = n5), !t5.funcid || "ROWNUM" !== t5.funcid.toUpperCase() && "ROW_NUMBER" !== t5.funcid.toUpperCase() || a5.rownums.push(t5.as);
            }
          }), this.columns.forEach(function(e5) {
            e5.findAggregator && e5.findAggregator(a5);
          }), this.having && this.having.findAggregator && this.having.findAggregator(a5);
        }, M.Select.prototype.compileSelectGroup1 = function(n5) {
          var r5 = "var r = {};";
          return this.columns.forEach(function(e5) {
            if (e5 instanceof M.Column && "*" === e5.columnid)
              return r5 += "for(var k in g) {r[k]=g[k]};", "";
            var t5 = e5.as;
            void 0 === t5 && (t5 = e5 instanceof M.Column ? Ss(e5.columnid) : e5.nick), n5.groupColumns[t5] = e5.nick, r5 = (r5 += "r['" + t5 + "']=") + Es(e5.toJS("g", "")) + ";";
            for (var s5 = 0; s5 < n5.removeKeys.length; s5++)
              if (n5.removeKeys[s5] === t5) {
                n5.removeKeys.splice(s5, 1);
                break;
              }
          }), r5;
        }, M.Select.prototype.compileSelectGroup2 = function(s5) {
          var n5 = s5.selectgfns;
          return this.columns.forEach(function(e5) {
            -1 < s5.ingroup.indexOf(e5.nick) && (n5 += "r['" + (e5.as || e5.nick) + "']=g['" + e5.nick + "'];");
          }), this.orderColumns && 0 < this.orderColumns.length && this.orderColumns.forEach(function(e5, t5) {
            t5 = "$$$" + t5;
            e5 instanceof M.Column && s5.groupColumns[e5.columnid] ? n5 += "r['" + t5 + "']=r['" + e5.columnid + "'];" : n5 += "r['" + t5 + "']=" + e5.toJS("g", "") + ";", s5.removeKeys.push(t5);
          }), new Function("g,params,alasql", "var y;" + n5 + "return r");
        }, M.Select.prototype.compileRemoveColumns = function(e5) {
          void 0 !== this.removecolumns && (e5.removeKeys = e5.removeKeys.concat(this.removecolumns.filter(function(e6) {
            return void 0 === e6.like;
          }).map(function(e6) {
            return e6.columnid;
          })), e5.removeLikeKeys = this.removecolumns.filter(function(e6) {
            return void 0 !== e6.like;
          }).map(function(e6) {
            return e6.like.value;
          }));
        }, M.Select.prototype.compileHaving = function(e5) {
          var t5;
          return this.having ? (t5 = this.having.toJS("g", -1), e5.havingfns = t5, new Function("g,params,alasql", "var y;return " + t5)) : function() {
            return true;
          };
        }, M.Select.prototype.compileOrder = function(a5, i5) {
          var s5, n5, o5, u5, l5 = this;
          if (l5.orderColumns = [], this.order)
            return this.order && 1 == this.order.length && this.order[0].expression && "function" == typeof this.order[0].expression ? (s5 = this.order[0].expression, n5 = "FIRST" == this.order[0].nullsOrder ? -1 : "LAST" == this.order[0].nullsOrder ? 1 : 0, function(e5, t5) {
              e5 = s5(e5), t5 = s5(t5);
              if (n5) {
                if (null == e5)
                  return null == t5 ? 0 : n5;
                if (null == t5)
                  return -n5;
              }
              return t5 < e5 ? 1 : e5 == t5 ? 0 : -1;
            }) : (u5 = o5 = "", this.order.forEach(function(e5, t5) {
              if (e5.expression instanceof M.NumValue) {
                if (e5.expression.value > l5.columns.length)
                  throw new Error(`You are trying to order by column number ${e5.expression.value} but you have only selected ${l5.columns.length} columns.`);
                var s6 = l5.columns[e5.expression.value - 1];
              } else
                s6 = e5.expression;
              l5.orderColumns.push(s6);
              var n6, r5, s6 = "$$$" + t5, t5 = "";
              e5.expression instanceof M.Column && (n6 = e5.expression.columnid, L.options.valueof || a5.xcolumns[n6] && ("DATE" == (r5 = a5.xcolumns[n6].dbtypeid) || "DATETIME" == r5 || "DATETIME2" == r5 || "STRING" == r5 || "NUMBER" == r5)) && (t5 = ".valueOf()"), e5.expression instanceof M.ParamValue && (n6 = i5[e5.expression.param], L.options.valueof || a5.xcolumns[n6] && ("DATE" == (r5 = a5.xcolumns[n6].dbtypeid) || "DATETIME" == r5 || "DATETIME2" == r5 || "STRING" == r5 || "NUMBER" == r5)) && (t5 = ".valueOf()"), e5.nocase && (t5 += ".toUpperCase()"), e5.nullsOrder && ("FIRST" == e5.nullsOrder ? o5 += "if((a['" + s6 + "'] != null) && (b['" + s6 + "'] == null)) return 1;" : "LAST" == e5.nullsOrder && (o5 += "if((a['" + s6 + "'] == null) && (b['" + s6 + "'] != null)) return 1;"), o5 += "if((a['" + s6 + "'] == null) == (b['" + s6 + "'] == null)) {", u5 += "}"), o5 = o5 + ("if((a['" + s6 + "']||'')" + t5 + ("ASC" == e5.direction ? ">" : "<")) + "(b['" + s6 + "']||'')" + t5 + ")return 1;if((a['" + s6 + "']||'')" + t5 + "==(b['" + s6 + "']||'')" + t5 + "){", u5 += "}";
            }), o5 = o5 + "return 0;" + u5 + "return -1", a5.orderfns = o5, new Function("a,b", "var y;" + o5));
        }, M.Select.prototype.compilePivot = function(e5) {
          var t5 = this, h5 = t5.pivot.columnid, d5 = t5.pivot.expr.aggregatorid, f5 = t5.pivot.inlist, p5 = null;
          if (null == (p5 = (t5.pivot.expr.expression.hasOwnProperty("columnid") ? t5.pivot.expr : t5.pivot.expr.expression).expression.columnid))
            throw "columnid not found";
          return f5 = f5 && f5.map(function(e6) {
            return e6.expr.columnid;
          }), function() {
            var s5 = this, n5 = s5.columns.filter(function(e7) {
              return e7.columnid != h5 && e7.columnid != p5;
            }).map(function(e7) {
              return e7.columnid;
            }), r5 = [], a5 = {}, i5 = {}, o5 = {}, u5 = [];
            if (s5.data.forEach(function(t7) {
              if (!f5 || -1 < f5.indexOf(t7[h5])) {
                var e7 = n5.map(function(e8) {
                  return t7[e8];
                }).join("`"), s6 = i5[e7];
                if (s6 || (s6 = {}, i5[e7] = s6, u5.push(s6), n5.forEach(function(e8) {
                  s6[e8] = t7[e8];
                })), o5[e7] || (o5[e7] = {}), o5[e7][t7[h5]] ? o5[e7][t7[h5]]++ : o5[e7][t7[h5]] = 1, a5[t7[h5]] || (a5[t7[h5]] = true, r5.push(t7[h5])), "SUM" == d5 || "AVG" == d5 || "TOTAL" == d5)
                  void 0 === s6[t7[h5]] && (s6[t7[h5]] = 0), s6[t7[h5]] += +t7[p5];
                else if ("COUNT" == d5)
                  void 0 === s6[t7[h5]] && (s6[t7[h5]] = 0), s6[t7[h5]]++;
                else if ("MIN" == d5)
                  void 0 === s6[t7[h5]] && (s6[t7[h5]] = t7[p5]), t7[p5] < s6[t7[h5]] && (s6[t7[h5]] = t7[p5]);
                else if ("MAX" == d5)
                  void 0 === s6[t7[h5]] && (s6[t7[h5]] = t7[p5]), t7[p5] > s6[t7[h5]] && (s6[t7[h5]] = t7[p5]);
                else if ("FIRST" == d5)
                  void 0 === s6[t7[h5]] && (s6[t7[h5]] = t7[p5]);
                else if ("LAST" == d5)
                  s6[t7[h5]] = t7[p5];
                else {
                  if (!L.aggr[d5])
                    throw new Error("Wrong aggregator in PIVOT clause");
                  L.aggr[d5](s6[t7[h5]], t7[p5]);
                }
              }
            }), "AVG" == d5)
              for (var e6 in i5) {
                var t6, l5 = i5[e6];
                for (t6 in l5)
                  -1 == n5.indexOf(t6) && t6 != p5 && (l5[t6] = l5[t6] / o5[e6][t6]);
              }
            s5.data = u5, f5 && (r5 = f5);
            var c5 = s5.columns.filter(function(e7) {
              return e7.columnid == p5;
            })[0];
            s5.columns = s5.columns.filter(function(e7) {
              return !(e7.columnid == h5 || e7.columnid == p5);
            }), r5.forEach(function(e7) {
              var t7 = Ds(c5);
              t7.columnid = e7, s5.columns.push(t7);
            });
          };
        }, M.Select.prototype.compileUnpivot = function(e5) {
          var a5 = this.unpivot.tocolumnid, i5 = this.unpivot.forcolumnid, t5 = this.unpivot.inlist.map(function(e6) {
            return e6.columnid;
          });
          return function() {
            var n5 = [], r5 = e5.columns.map(function(e6) {
              return e6.columnid;
            }).filter(function(e6) {
              return -1 == t5.indexOf(e6) && e6 != i5 && e6 != a5;
            });
            e5.data.forEach(function(s5) {
              t5.forEach(function(e6) {
                var t6 = {};
                r5.forEach(function(e7) {
                  t6[e7] = s5[e7];
                }), t6[i5] = e6, t6[a5] = s5[e6], n5.push(t6);
              });
            }), e5.data = n5;
          };
        };
        var zs = function(e5, t5) {
          for (var s5 = [], n5 = 0, r5 = e5.length, a5 = 0; a5 < r5 + 1; a5++) {
            for (var i5, o5 = [], u5 = 0; u5 < r5; u5++)
              i5 = e5[u5] instanceof M.Column ? (e5[u5].nick = Ss(e5[u5].columnid), t5.groupColumns[Ss(e5[u5].columnid)] = e5[u5].nick, e5[u5].nick + "	" + e5[u5].toJS("p", t5.sources[0].alias, t5.defcols)) : (t5.groupColumns[Ss(e5[u5].toString())] = Ss(e5[u5].toString()), Ss(e5[u5].toString()) + "	" + e5[u5].toJS("p", t5.sources[0].alias, t5.defcols)), n5 & 1 << u5 && o5.push(i5);
            s5.push(o5), n5 = 1 + (n5 << 1);
          }
          return s5;
        }, Zs = function(e5, t5) {
          for (var s5 = [], n5 = e5.length, r5 = 1 << n5, a5 = 0; a5 < r5; a5++) {
            for (var i5 = [], o5 = 0; o5 < n5; o5++)
              a5 & 1 << o5 && (i5 = i5.concat(sn(e5[o5], t5)));
            s5.push(i5);
          }
          return s5;
        }, en = function(e5, s5) {
          return e5.reduce(function(e6, t5) {
            return e6 = e6.concat(sn(t5, s5));
          }, []);
        }, tn = function(e5, t5) {
          for (var s5 = [], n5 = 0; n5 < e5.length; n5++)
            for (var r5 = 0; r5 < t5.length; r5++)
              s5.push(e5[n5].concat(t5[r5]));
          return s5;
        };
        function sn(t5, s5) {
          if (Array.isArray(t5)) {
            for (var e5 = [[]], n5 = 0; n5 < t5.length; n5++)
              if (t5[n5] instanceof M.Column)
                t5[n5].nick = t5[n5].nick ? Ss(t5[n5].nick) : Ss(t5[n5].columnid), s5.groupColumns[t5[n5].nick] = t5[n5].nick, e5 = e5.map(function(e6) {
                  return e6.concat(t5[n5].nick + "	" + t5[n5].toJS("p", s5.sources[0].alias, s5.defcols));
                });
              else if (t5[n5] instanceof M.FuncValue)
                s5.groupColumns[Ss(t5[n5].toString())] = Ss(t5[n5].toString()), e5 = e5.map(function(e6) {
                  return e6.concat(Ss(t5[n5].toString()) + "	" + t5[n5].toJS("p", s5.sources[0].alias, s5.defcols));
                });
              else if (t5[n5] instanceof M.GroupExpression)
                if ("ROLLUP" == t5[n5].type)
                  e5 = tn(e5, zs(t5[n5].group, s5));
                else if ("CUBE" == t5[n5].type)
                  e5 = tn(e5, Zs(t5[n5].group, s5));
                else {
                  if ("GROUPING SETS" != t5[n5].type)
                    throw new Error("Unknown grouping function");
                  e5 = tn(e5, en(t5[n5].group, s5));
                }
              else
                e5 = "" === t5[n5] ? [["1	1"]] : e5.map(function(e6) {
                  return s5.groupColumns[Ss(t5[n5].toString())] = Ss(t5[n5].toString()), e6.concat(Ss(t5[n5].toString()) + "	" + t5[n5].toJS("p", s5.sources[0].alias, s5.defcols));
                });
            return e5;
          }
          return t5 instanceof M.FuncValue ? (s5.groupColumns[Ss(t5.toString())] = Ss(t5.toString()), [t5.toString() + "	" + t5.toJS("p", s5.sources[0].alias, s5.defcols)]) : t5 instanceof M.Column ? (t5.nick = Ss(t5.columnid), s5.groupColumns[t5.nick] = t5.nick, [t5.nick + "	" + t5.toJS("p", s5.sources[0].alias, s5.defcols)]) : (s5.groupColumns[Ss(t5.toString())] = Ss(t5.toString()), [Ss(t5.toString()) + "	" + t5.toJS("p", s5.sources[0].alias, s5.defcols)]);
        }
        M.Select.prototype.compileDefCols = function(e5, n5) {
          var r5 = { ".": {} };
          return this.from && this.from.forEach(function(e6) {
            if (r5["."][e6.as || e6.tableid] = true, e6 instanceof M.Table) {
              var t5 = e6.as || e6.tableid, s5 = L.databases[e6.databaseid || n5].tables[e6.tableid];
              if (void 0 === s5)
                throw new Error("Table does not exist: " + e6.tableid);
              s5.columns && s5.columns.forEach(function(e7) {
                r5[e7.columnid] ? r5[e7.columnid] = "-" : r5[e7.columnid] = t5;
              });
            } else if (!(e6 instanceof M.Select || e6 instanceof M.Search || e6 instanceof M.ParamValue || e6 instanceof M.VarValue || e6 instanceof M.FuncValue || e6 instanceof M.FromData || e6 instanceof M.Json || e6.inserted))
              throw new Error("Unknown type of FROM clause");
          }), this.joins && this.joins.forEach(function(e6) {
            if (r5["."][e6.as || e6.table.tableid] = true, e6.table) {
              var t5 = e6.table.tableid, t5 = (e6.as && (t5 = e6.as), e6.as || e6.table.tableid), s5 = L.databases[e6.table.databaseid || n5].tables[e6.table.tableid];
              s5.columns && s5.columns.forEach(function(e7) {
                r5[e7.columnid] ? r5[e7.columnid] = "-" : r5[e7.columnid] = t5;
              });
            } else if (!e6.select && !e6.param && !e6.func)
              throw new Error("Unknown type of FROM clause");
          }), r5;
        }, M.Union = class {
          constructor(e5) {
            Object.assign(this, e5);
          }
          toString() {
            return "UNION";
          }
          compile(e5) {
            return null;
          }
        }, M.Apply = class {
          constructor(e5) {
            Object.assign(this, e5);
          }
          toString() {
            var e5 = this.applymode + " APPLY (" + this.select.toString() + ")";
            return this.as && (e5 += " AS " + this.as), e5;
          }
        }, M.Over = class {
          constructor(e5) {
            Object.assign(this, e5);
          }
          toString() {
            var e5 = "OVER (";
            return this.partition && (e5 += "PARTITION BY " + this.partition.toString(), this.order) && (e5 += " "), this.order && (e5 += "ORDER BY " + this.order.toString()), e5 += ")";
          }
        };
        {
          const vn = Object.assign;
          class Nn {
            constructor(e5) {
              vn(this, e5);
            }
            toString() {
              return this.expression.toString();
            }
            execute(e5, t5, s5) {
              if (this.expression)
                return L.precompile(this, e5, t5), e5 = new Function("params,alasql,p", "var y;return " + this.expression.toJS("({})", "", null)).bind(this)(t5, L), s5 ? s5(e5) : e5;
            }
          }
          class On {
            constructor(e5) {
              vn(this, e5);
            }
            toString() {
              var e5 = this.expression.toString();
              return this.order && (e5 += " " + this.order.toString()), this.nocase && (e5 += " COLLATE NOCASE"), this.direction && (e5 += " " + this.direction), e5;
            }
            findAggregator(e5) {
              this.expression.findAggregator && this.expression.findAggregator(e5);
            }
            toJS(e5, t5, s5) {
              return this.expression.reduced ? "true" : this.expression.toJS(e5, t5, s5);
            }
            compile(e5, t5, s5) {
              return !!this.reduced || new Function("p", "var y;return " + this.toJS(e5, t5, s5));
            }
          }
          class Cn {
            constructor(e5) {
              vn(this, e5);
            }
            toString() {
              return "``" + this.value + "``";
            }
            toJS() {
              return "(" + this.value + ")";
            }
            execute(e5, t5, s5) {
              var n5 = 1;
              return new Function("params,alasql,p", this.value)(t5, L), n5 = s5 ? s5(n5) : n5;
            }
          }
          class Rn {
            constructor(e5) {
              vn(this, e5);
            }
            toString() {
              var e5 = this.value;
              return e5 = this.value1 ? this.value1 + "." + e5 : e5;
            }
          }
          class In {
            constructor(e5) {
              vn(this, e5);
            }
            toString() {
              var e5 = " ";
              return this.joinmode && (e5 += this.joinmode + " "), e5 += "JOIN " + this.table.toString();
            }
          }
          class Vs2 {
            constructor(e5) {
              vn(this, e5);
            }
            toString() {
              var e5 = this.tableid;
              return e5 = this.databaseid ? this.databaseid + "." + e5 : e5;
            }
          }
          class Bs2 {
            constructor(e5) {
              vn(this, e5);
            }
            toString() {
              var e5 = this.viewid;
              return e5 = this.databaseid ? this.databaseid + "." + e5 : e5;
            }
          }
          class wn {
            constructor(e5) {
              vn(this, e5);
            }
            toString() {
              var e5;
              return "IN" === this.op || "NOT IN" === this.op ? this.left.toString() + " " + this.op + " (" + this.right.toString() + ")" : this.allsome ? this.left.toString() + " " + this.op + " " + this.allsome + " (" + this.right.toString() + ")" : "->" === this.op || "!" === this.op ? (e5 = this.left.toString() + this.op, "string" != typeof this.right && "number" != typeof this.right && (e5 += "("), e5 += this.right.toString(), "string" != typeof this.right && "number" != typeof this.right && (e5 += ")"), e5) : "BETWEEN" === this.op || "NOT BETWEEN" === this.op ? this.left.toString() + " " + this.op + " " + this.right1.toString() + " AND " + this.right2.toString() : this.left.toString() + " " + this.op + " " + (this.allsome ? this.allsome + " " : "") + this.right.toString();
            }
            findAggregator(e5) {
              this.left && this.left.findAggregator && this.left.findAggregator(e5), this.right && this.right.findAggregator && !this.allsome && this.right.findAggregator(e5);
            }
            toType(e5) {
              if (-1 < ["-", "*", "/", "%", "^"].indexOf(this.op))
                return "number";
              if (-1 < ["||"].indexOf(this.op))
                return "string";
              if ("+" === this.op) {
                if ("string" === this.left.toType(e5) || "string" === this.right.toType(e5))
                  return "string";
                if ("number" === this.left.toType(e5) || "number" === this.right.toType(e5))
                  return "number";
              }
              return -1 < ["AND", "OR", "NOT", "=", "==", "===", "!=", "!==", "!===", ">", ">=", "<", "<=", "IN", "NOT IN", "LIKE", "NOT LIKE", "REGEXP", "GLOB"].indexOf(this.op) || "BETWEEN" === this.op || "NOT BETWEEN" === this.op || "IS NULL" === this.op || "IS NOT NULL" === this.op || this.allsome ? "boolean" : this.op ? "unknown" : this.left.toType();
            }
            toJS(t5, s5, n5) {
              function e5() {
                return l5(u5.left);
              }
              function r5() {
                return l5(u5.right);
              }
              var a5, i5 = [], o5 = this.op, u5 = this, l5 = function(e6) {
                return e6.toJS && (e6 = e6.toJS(t5, s5, n5)), "y[" + (i5.push(e6) - 1) + "]";
              };
              if ("=" === this.op ? o5 = "===" : "<>" === this.op ? o5 = "!=" : "OR" === this.op && (o5 = "||"), "->" === this.op && (h5 = "(" + e5() + "||{})", a5 = "string" == typeof this.right ? h5 + '["' + this.right + '"]' : "number" == typeof this.right ? h5 + "[" + this.right + "]" : this.right instanceof M.FuncValue ? (a5 = [], this.right.args && 0 !== this.right.args.length && (a5 = this.right.args.map(l5)), h5 + "[" + JSON.stringify(this.right.funcid) + "](" + a5.join(",") + ")") : h5 + "[" + r5() + "]"), "!" === this.op && "string" == typeof this.right && (a5 = "alasql.databases[alasql.useid].objects[" + e5() + ']["' + this.right + '"]'), "IS" === this.op && (h5 = e5(), c5 = r5(), a5 = this.right instanceof M.NullValue || "NOT" === this.right.op && this.right.right instanceof M.NullValue ? `((${h5} == null) === (${c5} == null))` : `((${h5} == ${c5}) || (${h5}  < 0 && true == ${c5}))`), "==" === this.op && (a5 = "alasql.utils.deepEqual(" + e5() + "," + r5() + ")"), "===" !== this.op && "!===" !== this.op || (a5 = "(" + ("!===" === this.op ? "!" : "") + "((" + e5() + ").valueOf()===(" + r5() + ").valueOf()))"), "!==" === this.op && (a5 = "(!alasql.utils.deepEqual(" + e5() + "," + r5() + "))"), "||" === this.op && (a5 = "(''+(" + e5() + "||'')+(" + r5() + '||""))'), "LIKE" !== this.op && "NOT LIKE" !== this.op || (a5 = "(" + ("NOT LIKE" === this.op ? "!" : "") + "alasql.utils.like(" + r5() + "," + e5(), this.escape && (a5 += "," + l5(this.escape)), a5 += "))"), "REGEXP" === this.op && (a5 = "alasql.stdfn.REGEXP_LIKE(" + e5() + "," + r5() + ")"), "GLOB" === this.op && (a5 = "alasql.utils.glob(" + e5() + "," + r5() + ")"), "BETWEEN" !== this.op && "NOT BETWEEN" !== this.op || (h5 = e5(), a5 = "(" + ("NOT BETWEEN" === this.op ? "!" : "") + "((" + l5(this.right1) + "<=" + h5 + ") && (" + h5 + "<=" + l5(this.right2) + ")))"), "IN" === this.op && (a5 = this.right instanceof M.Select ? (a5 = (a5 = "(") + "alasql.utils.flatArray(this.queriesfn[" + this.queriesidx + "](params,null," + t5 + ")).indexOf(") + "alasql.utils.getValueOf(" + e5() + "))>-1)" : Array.isArray(this.right) ? "([" + this.right.map(l5).join(",") + "].indexOf(alasql.utils.getValueOf(" + e5() + "))>-1)" : "(" + r5() + ".indexOf(" + e5() + ")>-1)"), "NOT IN" === this.op && (this.right instanceof M.Select ? a5 = (a5 = (a5 = "(") + "alasql.utils.flatArray(this.queriesfn[" + this.queriesidx + "](params,null,p)).indexOf(") + "alasql.utils.getValueOf(" + e5() + "))<0)" : Array.isArray(this.right) ? (a5 = "([" + this.right.map(l5).join(",") + "].indexOf(", a5 += "alasql.utils.getValueOf(" + e5() + "))<0)") : (a5 = "(" + r5() + ".indexOf(", a5 += e5() + ")==-1)")), "ALL" === this.allsome) {
                if (this.right instanceof M.Select)
                  a5 = "alasql.utils.flatArray(this.query.queriesfn[" + this.queriesidx + "](params,null,p))";
                else {
                  if (!Array.isArray(this.right))
                    throw new Error("NOT IN operator without SELECT");
                  a5 = "" + (1 == this.right.length ? l5(this.right[0]) : "[" + this.right.map(l5).join(",") + "]");
                }
                a5 = (a5 += ".every(function(b){return (") + e5() + ")" + o5 + "b})";
              }
              if ("SOME" === this.allsome || "ANY" === this.allsome) {
                if (this.right instanceof M.Select)
                  a5 = "alasql.utils.flatArray(this.query.queriesfn[" + this.queriesidx + "](params,null,p))";
                else {
                  if (!Array.isArray(this.right))
                    throw new Error("SOME/ANY operator without SELECT");
                  a5 = "" + (1 == this.right.length ? l5(this.right[0]) : "[" + this.right.map(l5).join(",") + "]");
                }
                a5 = (a5 += ".some(function(b){return (") + e5() + ")" + o5 + "b})";
              }
              if ("AND" === this.op) {
                if (this.left.reduced) {
                  if (this.right.reduced)
                    return "true";
                  a5 = r5();
                } else
                  this.right.reduced && (a5 = e5());
                o5 = "&&";
              }
              var c5 = a5 || "(" + e5() + o5 + r5() + ")", h5 = "y=[(" + i5.join("), (") + ")]";
              return "&&" === o5 || "||" === o5 || "IS" === o5 || "IS NULL" === o5 || "IS NOT NULL" === o5 ? "(" + h5 + ", " + c5 + ")" : "(" + h5 + ", y.some(function(e){return e == null}) ? void 0 : " + c5 + ")";
            }
          }
          class $n {
            constructor(e5) {
              vn(this, e5);
            }
            toString() {
              return "@" + this.variable;
            }
            toType() {
              return "unknown";
            }
            toJS() {
              return "alasql.vars['" + this.variable + "']";
            }
          }
          class xn {
            constructor(e5) {
              vn(this, e5);
            }
            toString() {
              return this.value.toString();
            }
            toType() {
              return "number";
            }
            toJS() {
              return "" + this.value;
            }
          }
          class kn {
            constructor(e5) {
              vn(this, e5);
            }
            toString() {
              return "'" + this.value.toString() + "'";
            }
            toType() {
              return "string";
            }
            toJS() {
              return "'" + Ss(this.value) + "'";
            }
          }
          class Ln {
            constructor(e5) {
              vn(this, e5);
            }
            toString() {
              return "VALUE";
            }
            toType() {
              return "object";
            }
            toJS(e5, t5, s5) {
              return e5;
            }
          }
          class Dn {
            constructor(e5) {
              vn(this, e5);
            }
            toString() {
              return "ARRAY[]";
            }
            toType() {
              return "object";
            }
            toJS(t5, s5, n5) {
              return "[(" + this.value.map(function(e5) {
                return e5.toJS(t5, s5, n5);
              }).join("), (") + ")]";
            }
          }
          class Mn {
            constructor(e5) {
              vn(this, e5);
            }
            toString() {
              return this.value ? "TRUE" : "FALSE";
            }
            toType() {
              return "boolean";
            }
            toJS() {
              return this.value ? "true" : "false";
            }
          }
          class Un {
            constructor(e5) {
              vn(this, e5);
            }
            toString() {
              return "NULL";
            }
            toJS() {
              return "undefined";
            }
          }
          class Fn {
            constructor(e5) {
              vn(this, e5);
            }
            toString() {
              return "$" + this.param;
            }
            toJS() {
              return "string" == typeof this.param ? "params['" + this.param + "']" : "params[" + this.param + "]";
            }
          }
          class _n {
            constructor(e5) {
              vn(this, e5);
            }
            toString() {
              var e5, { op: t5, right: s5 } = this, s5 = s5.toString();
              return "~" === t5 && (e5 = t5 + s5), "-" === t5 && (e5 = t5 + s5), "+" === t5 && (e5 = t5 + s5), "#" === t5 && (e5 = t5 + s5), "NOT" === t5 && (e5 = t5 + "(" + s5 + ")"), e5 = (e5 = null === t5 ? "(" + s5 + ")" : e5) || "(" + s5 + ")";
            }
            findAggregator(e5) {
              this.right.findAggregator && this.right.findAggregator(e5);
            }
            toType() {
              return "-" === this.op || "+" === this.op ? "number" : "NOT" === this.op ? "boolean" : void 0;
            }
            toJS(e5, t5, s5) {
              return "~" === this.op ? "(~(" + this.right.toJS(e5, t5, s5) + "))" : "-" === this.op ? "(-(" + this.right.toJS(e5, t5, s5) + "))" : "+" === this.op ? "(" + this.right.toJS(e5, t5, s5) + ")" : "NOT" === this.op ? "!(" + this.right.toJS(e5, t5, s5) + ")" : "#" === this.op ? this.right instanceof Pn ? "(alasql.databases[alasql.useid].objects['" + this.right.columnid + "'])" : "(alasql.databases[alasql.useid].objects[" + this.right.toJS(e5, t5, s5) + "])" : null == this.op ? "(" + this.right.toJS(e5, t5, s5) + ")" : void 0;
            }
          }
          class Pn {
            constructor(e5) {
              vn(this, e5);
            }
            toString() {
              var e5 = this.columnid == +this.columnid ? "[" + this.columnid + "]" : this.columnid;
              return e5 = this.tableid && (e5 = +this.columnid === this.columnid ? this.tableid + e5 : this.tableid + "." + e5, this.databaseid) ? this.databaseid + "." + e5 : e5;
            }
            toJS(e5, t5, s5) {
              var n5 = "";
              if (this.tableid || "" !== t5 || s5)
                if ("g" === e5)
                  n5 = "g['" + this.nick + "']";
                else if (this.tableid)
                  n5 = "_" !== this.columnid ? e5 + "['" + this.tableid + "']['" + this.columnid + "']" : "g" === e5 ? "g['_']" : e5 + "['" + this.tableid + "']";
                else if (s5) {
                  s5 = s5[this.columnid];
                  if ("-" === s5)
                    throw new Error('Cannot resolve column "' + this.columnid + '" because it exists in two source tables');
                  n5 = s5 ? "_" !== this.columnid ? e5 + "['" + s5 + "']['" + this.columnid + "']" : e5 + "['" + s5 + "']" : "_" !== this.columnid ? e5 + "['" + (this.tableid || t5) + "']['" + this.columnid + "']" : e5 + "['" + (this.tableid || t5) + "']";
                } else
                  n5 = -1 === t5 ? e5 + "['" + this.columnid + "']" : "_" !== this.columnid ? e5 + "['" + (this.tableid || t5) + "']['" + this.columnid + "']" : e5 + "['" + (this.tableid || t5) + "']";
              else
                n5 = "_" !== this.columnid ? e5 + "['" + this.columnid + "']" : "g" === e5 ? "g['_']" : e5;
              return n5;
            }
          }
          class qn {
            constructor(e5) {
              vn(this, e5);
            }
            toString() {
              var e5 = "";
              return "REDUCE" === this.aggregatorid ? e5 += this.funcid.replace(nn, "") + "(" : e5 += this.aggregatorid + "(", this.distinct && (e5 += "DISTINCT "), this.expression && (e5 += this.expression.toString()), e5 += ")", this.over && (e5 += " " + this.over.toString()), e5;
            }
            findAggregator(e5) {
              var t5 = Ss(this.toString()) + ":" + e5.selectGroup.length;
              if (!(s5 = false)) {
                if (!this.nick) {
                  this.nick = t5;
                  for (var s5 = false, n5 = 0; n5 < e5.removeKeys.length; n5++)
                    if (e5.removeKeys[n5] === t5) {
                      s5 = true;
                      break;
                    }
                  s5 || e5.removeKeys.push(t5);
                }
                e5.selectGroup.push(this);
              }
            }
            toType() {
              return -1 < ["SUM", "COUNT", "AVG", "MIN", "MAX", "AGGR", "VAR", "STDDEV", "TOTAL"].indexOf(this.aggregatorid) ? "number" : -1 < ["ARRAY"].indexOf(this.aggregatorid) ? "array" : (["FIRST", "LAST"].indexOf(this.aggregatorid), this.expression.toType());
            }
            toJS() {
              var e5 = this.nick;
              return "g['" + (e5 = void 0 === e5 ? this.toString() : e5) + "']";
            }
          }
          class Gn {
            constructor(e5) {
              vn(this, e5);
            }
          }
          Gn.prototype.toString = On.prototype.toString;
          class jn {
            constructor(e5) {
              vn(this, e5);
            }
            toString() {
              return this.type + "(" + this.group.toString() + ")";
            }
          }
          vn(M, { AggrValue: qn, ArrayValue: Dn, Column: Pn, DomainValueValue: Ln, Expression: On, ExpressionStatement: Nn, GroupExpression: jn, JavaScript: Cn, Join: In, Literal: Rn, LogicValue: Mn, NullValue: Un, NumValue: xn, Op: wn, OrderExpression: Gn, ParamValue: Fn, StringValue: kn, Table: Vs2, UniOp: _n, VarValue: $n, View: Bs2 });
        }
        M.FromData = function(e5) {
          return M.extend(this, e5);
        }, M.FromData.prototype.toString = function() {
          return this.data ? "DATA(" + (1e16 * Math.random() | 0) + ")" : "?";
        }, M.FromData.prototype.toJS = function() {
        }, M.Select.prototype.exec = function(e5, t5) {
          this.preparams && (e5 = this.preparams.concat(e5));
          var s5 = L.useid, n5 = L.databases[s5], r5 = this.toString(), a5 = Rs(r5), s5 = this.compile(s5);
          if (s5)
            return s5.sql = r5, s5.dbversion = n5.dbversion, n5.sqlCacheSize > L.MAXSQLCACHESIZE && n5.resetSqlCache(), n5.sqlCacheSize++, n5.sqlCache[a5] = s5, L.res = s5(e5, t5);
        }, M.Select.prototype.Select = function() {
          var s5 = this, e5 = [];
          if (1 < arguments.length)
            e5 = Array.prototype.slice.call(arguments);
          else {
            if (1 != arguments.length)
              throw new Error("Wrong number of arguments of Select() function");
            e5 = Array.isArray(arguments[0]) ? arguments[0] : [arguments[0]];
          }
          return s5.columns = [], e5.forEach(function(e6) {
            var t5;
            "string" == typeof e6 ? s5.columns.push(new M.Column({ columnid: e6 })) : "function" == typeof e6 && (t5 = 0, s5.preparams ? t5 = s5.preparams.length : s5.preparams = [], s5.preparams.push(e6), s5.columns.push(new M.Column({ columnid: "*", func: e6, param: t5 })));
          }), s5;
        }, M.Select.prototype.From = function(e5) {
          var t5 = this;
          if (t5.from || (t5.from = []), Array.isArray(e5)) {
            var s5 = 0;
            t5.preparams ? s5 = t5.preparams.length : t5.preparams = [], t5.preparams.push(e5), t5.from.push(new M.ParamValue({ param: s5 }));
          } else {
            if ("string" != typeof e5)
              throw new Error("Unknown arguments in From() function");
            t5.from.push(new M.Table({ tableid: e5 }));
          }
          return t5;
        }, M.Select.prototype.OrderBy = function() {
          var s5 = this, e5 = [];
          if (s5.order = [], 0 == arguments.length)
            e5 = ["_"];
          else if (1 < arguments.length)
            e5 = Array.prototype.slice.call(arguments);
          else {
            if (1 != arguments.length)
              throw new Error("Wrong number of arguments of Select() function");
            e5 = Array.isArray(arguments[0]) ? arguments[0] : [arguments[0]];
          }
          return 0 < e5.length && e5.forEach(function(e6) {
            var t5 = new M.Column({ columnid: e6 });
            s5.order.push(new M.OrderExpression({ expression: t5 = "function" == typeof e6 ? e6 : t5, direction: "ASC" }));
          }), s5;
        }, M.Select.prototype.Top = function(e5) {
          return this.top = new M.NumValue({ value: e5 }), this;
        }, M.Select.prototype.GroupBy = function() {
          var t5 = this, e5 = [];
          if (1 < arguments.length)
            e5 = Array.prototype.slice.call(arguments);
          else {
            if (1 != arguments.length)
              throw new Error("Wrong number of arguments of Select() function");
            e5 = Array.isArray(arguments[0]) ? arguments[0] : [arguments[0]];
          }
          return t5.group = [], e5.forEach(function(e6) {
            e6 = new M.Column({ columnid: e6 });
            t5.group.push(e6);
          }), t5;
        }, M.Select.prototype.Where = function(e5) {
          return "function" == typeof e5 && (this.where = e5), this;
        }, M.FuncValue = function(e5) {
          return Object.assign(this, e5);
        };
        let nn = /[^0-9A-Z_$]+/i;
        M.FuncValue.prototype.toString = function() {
          let e5 = "";
          return L.fn[this.funcid] || L.aggr[this.funcid] ? e5 += this.funcid : (L.stdlib[this.funcid.toUpperCase()] || L.stdfn[this.funcid.toUpperCase()]) && (e5 += this.funcid.toUpperCase().replace(nn, "")), "CURRENT_TIMESTAMP" !== this.funcid && (e5 += "(", this.args && 0 < this.args.length && (e5 += this.args.map(function(e6) {
            return e6.toString();
          }).join(",")), e5 += ")"), e5;
        }, M.FuncValue.prototype.execute = function(e5, t5, s5) {
          let n5 = 1;
          return L.precompile(this, e5, t5), new Function("params,alasql", "var y;return " + this.toJS("", "", null))(t5, L), n5 = s5 ? s5(n5) : n5;
        }, M.FuncValue.prototype.findAggregator = function(t5) {
          this.args && 0 < this.args.length && this.args.forEach(function(e5) {
            e5.findAggregator && e5.findAggregator(t5);
          });
        }, M.FuncValue.prototype.toJS = function(t5, s5, n5) {
          var e5 = "", r5 = this.funcid;
          return !L.fn[r5] && L.stdlib[r5.toUpperCase()] ? this.args && 0 < this.args.length ? e5 += L.stdlib[r5.toUpperCase()].apply(this, this.args.map(function(e6) {
            return e6.toJS(t5, s5);
          })) : e5 += L.stdlib[r5.toUpperCase()]() : (!L.fn[r5] && L.stdfn[r5.toUpperCase()] ? (this.newid && (e5 += "new "), e5 += "alasql.stdfn[" + JSON.stringify(this.funcid.toUpperCase()) + "](", this.args && 0 < this.args.length && (e5 += this.args.map(function(e6) {
            return e6.toJS(t5, s5, n5);
          }).join(","))) : (this.newid && (e5 += "new "), e5 += "alasql.fn[" + JSON.stringify(this.funcid) + "](", this.args && 0 < this.args.length && (e5 += this.args.map(function(e6) {
            return e6.toJS(t5, s5, n5);
          }).join(","))), e5 += ")"), e5;
        };
        for (var rn = L.stdlib = {}, an = L.stdfn = {}, on = (rn.ABS = function(e5) {
          return "Math.abs(" + e5 + ")";
        }, rn.CLONEDEEP = function(e5) {
          return "alasql.utils.cloneDeep(" + e5 + ")";
        }, an.CONCAT = function() {
          return Array.prototype.slice.call(arguments).join("");
        }, rn.EXP = function(e5) {
          return "Math.pow(Math.E," + e5 + ")";
        }, rn.IIF = function(e5, t5, s5) {
          if (3 === arguments.length)
            return "((" + e5 + ")?(" + t5 + "):(" + s5 + "))";
          throw new Error("Number of arguments of IFF is not equals to 3");
        }, rn.IFNULL = function(e5, t5) {
          return "((typeof " + e5 + ' ==="undefined" || null ===  ' + e5 + ")?" + t5 + ":" + e5 + ")";
        }, rn.INSTR = function(e5, t5) {
          return "((" + e5 + ").indexOf(" + t5 + ")+1)";
        }, rn.LEN = rn.LENGTH = function(e5) {
          return gs(e5, "y.length");
        }, rn.LOWER = rn.LCASE = function(e5) {
          return gs(e5, "String(y).toLowerCase()");
        }, rn.LTRIM = function(e5) {
          return gs(e5, 'y.replace(/^[ ]+/,"")');
        }, rn.RTRIM = function(e5) {
          return gs(e5, 'y.replace(/[ ]+$/,"")');
        }, rn.MAX = rn.GREATEST = function() {
          return "[" + Array.prototype.join.call(arguments, ",") + "].reduce(function (a, b) { return a > b ? a : b; })";
        }, rn.MIN = rn.LEAST = function() {
          return "[" + Array.prototype.join.call(arguments, ",") + "].reduce(function (a, b) { return a < b ? a : b; })";
        }, rn.SUBSTRING = rn.SUBSTR = rn.MID = function(e5, t5, s5) {
          return 2 == arguments.length ? gs(e5, "y.substr(" + t5 + "-1)") : 3 == arguments.length ? gs(e5, "y.substr(" + t5 + "-1," + s5 + ")") : void 0;
        }, an.REGEXP_LIKE = function(e5, t5, s5) {
          return -1 < (e5 || "").search(RegExp(t5, s5));
        }, rn.ISNULL = rn.NULLIF = function(e5, t5) {
          return "(" + e5 + "==" + t5 + "?undefined:" + e5 + ")";
        }, rn.POWER = function(e5, t5) {
          return "Math.pow(" + e5 + "," + t5 + ")";
        }, rn.RANDOM = function(e5) {
          return 0 == arguments.length ? "Math.random()" : "(Math.random()*(" + e5 + ")|0)";
        }, rn.ROUND = function(e5, t5) {
          return 2 == arguments.length ? "Math.round((" + e5 + ")*Math.pow(10,(" + t5 + ")))/Math.pow(10,(" + t5 + "))" : "Math.round(" + e5 + ")";
        }, rn.CEIL = rn.CEILING = function(e5) {
          return "Math.ceil(" + e5 + ")";
        }, rn.FLOOR = function(e5) {
          return "Math.floor(" + e5 + ")";
        }, rn.ROWNUM = function() {
          return "1";
        }, rn.ROW_NUMBER = function() {
          return "1";
        }, rn.SQRT = function(e5) {
          return "Math.sqrt(" + e5 + ")";
        }, rn.TRIM = function(e5) {
          return gs(e5, "y.trim()");
        }, rn.UPPER = rn.UCASE = function(e5) {
          return gs(e5, "String(y).toUpperCase()");
        }, an.CONCAT_WS = function() {
          var e5 = Array.prototype.slice.call(arguments);
          return (e5 = e5.filter((e6) => !(null == e6))).slice(1, e5.length).join(e5[0] || "");
        }, L.aggr.GROUP_CONCAT = function(e5, t5, s5) {
          return 1 === s5 ? "" + e5 : 2 === s5 ? t5 + "," + e5 : t5;
        }, L.aggr.median = L.aggr.MEDIAN = function(e5, t5, s5) {
          var n5;
          return 2 === s5 ? (null !== e5 && t5.push(e5), t5) : 1 === s5 ? null === e5 ? [] : [e5] : t5.length ? (n5 = (s5 = t5.sort((e6, t6) => t6 < e6 ? 1 : e6 < t6 ? -1 : 0))[(t5 = 0 | (e5 = (s5.length + 1) / 2)) - 1], e5 != t5 && ("number" == typeof n5 || n5 instanceof Number) ? (n5 + s5[t5]) / 2 : n5) : null;
        }, L.aggr.QUART = function(e5, t5, s5, n5) {
          if (2 === s5)
            return null !== e5 && t5.push(e5), t5;
          if (1 === s5)
            return null === e5 ? [] : [e5];
          if (!t5.length)
            return t5;
          n5 = n5 || 1;
          s5 = t5.sort(function(e6, t6) {
            return e6 === t6 ? 0 : t6 < e6 ? 1 : -1;
          }), e5 = n5 * (s5.length + 1) / 4;
          return Number.isInteger(e5) ? s5[e5 - 1] : s5[Math.floor(e5)];
        }, L.aggr.QUART2 = function(e5, t5, s5) {
          return L.aggr.QUART(e5, t5, s5, 2);
        }, L.aggr.QUART3 = function(e5, t5, s5) {
          return L.aggr.QUART(e5, t5, s5, 3);
        }, L.aggr.VAR = function(e5, t5, s5) {
          if (1 === s5)
            return null === e5 ? { arr: [], sum: 0 } : { arr: [e5], sum: e5 };
          if (2 === s5)
            return null !== e5 && (t5.arr.push(e5), t5.sum += e5), t5;
          for (var n5 = t5.arr.length, r5 = t5.sum / n5, a5 = 0, i5 = 0; i5 < n5; i5++)
            a5 += (t5.arr[i5] - r5) * (t5.arr[i5] - r5);
          return a5 /= n5 - 1;
        }, L.aggr.STDEV = function(e5, t5, s5) {
          return 1 === s5 || 2 === s5 ? L.aggr.VAR(e5, t5, s5) : Math.sqrt(L.aggr.VAR(e5, t5, s5));
        }, L.aggr.VARP = function(e5, t5, s5) {
          if (1 == s5)
            return { arr: [e5], sum: e5 };
          if (2 == s5)
            return t5.arr.push(e5), t5.sum += e5, t5;
          for (var n5 = t5.arr.length, r5 = t5.sum / n5, a5 = 0, i5 = 0; i5 < n5; i5++)
            a5 += (t5.arr[i5] - r5) * (t5.arr[i5] - r5);
          return a5 /= n5;
        }, L.aggr.STD = L.aggr.STDDEV = L.aggr.STDEVP = function(e5, t5, s5) {
          return 1 == s5 || 2 == s5 ? L.aggr.VARP(e5, t5, s5) : Math.sqrt(L.aggr.VARP(e5, t5, s5));
        }, L._aggrOriginal = L.aggr, L.aggr = {}, Object.keys(L._aggrOriginal).forEach(function(n5) {
          L.aggr[n5] = function(e5, t5, s5) {
            if (3 !== s5 || void 0 !== t5)
              return L._aggrOriginal[n5].apply(null, arguments);
          };
        }), an.REPLACE = function(e5, t5, s5) {
          return (e5 || "").split(t5).join(s5);
        }, []), un = 0; un < 256; un++)
          on[un] = (un < 16 ? "0" : "") + un.toString(16);
        an.NEWID = an.UUID = an.GEN_RANDOM_UUID = function() {
          var e5 = 4294967295 * Math.random() | 0, t5 = 4294967295 * Math.random() | 0, s5 = 4294967295 * Math.random() | 0, n5 = 4294967295 * Math.random() | 0;
          return on[255 & e5] + on[e5 >> 8 & 255] + on[e5 >> 16 & 255] + on[e5 >> 24 & 255] + "-" + on[255 & t5] + on[t5 >> 8 & 255] + "-" + on[t5 >> 16 & 15 | 64] + on[t5 >> 24 & 255] + "-" + on[63 & s5 | 128] + on[s5 >> 8 & 255] + "-" + on[s5 >> 16 & 255] + on[s5 >> 24 & 255] + on[255 & n5] + on[n5 >> 8 & 255] + on[n5 >> 16 & 255] + on[n5 >> 24 & 255];
        }, M.CaseValue = function(e5) {
          return Object.assign(this, e5);
        }, M.CaseValue.prototype.toString = function() {
          var e5 = "CASE ";
          return this.expression && (e5 += this.expression.toString()), this.whens && (e5 += this.whens.map(function(e6) {
            return " WHEN " + e6.when.toString() + " THEN " + e6.then.toString();
          }).join()), e5 += " END";
        }, M.CaseValue.prototype.findAggregator = function(t5) {
          this.expression && this.expression.findAggregator && this.expression.findAggregator(t5), this.whens && 0 < this.whens.length && this.whens.forEach(function(e5) {
            e5.when.findAggregator && e5.when.findAggregator(t5), e5.then.findAggregator && e5.then.findAggregator(t5);
          }), this.elses && this.elses.findAggregator && this.elses.findAggregator(t5);
        }, M.CaseValue.prototype.toJS = function(t5, s5, n5) {
          var e5 = "((function(" + t5 + ",params,alasql){var y,r;";
          return this.expression ? e5 = (e5 += "v=" + this.expression.toJS(t5, s5, n5) + ";") + (this.whens || []).map(function(e6) {
            return " if(v==" + e6.when.toJS(t5, s5, n5) + ") {r=" + e6.then.toJS(t5, s5, n5) + "}";
          }).join(" else ") : e5 += (this.whens || []).map(function(e6) {
            return " if(" + e6.when.toJS(t5, s5, n5) + ") {r=" + e6.then.toJS(t5, s5, n5) + "}";
          }).join(" else "), this.elses && (e5 += " else {r=" + this.elses.toJS(t5, s5, n5) + "}"), e5 += ";return r;}).bind(this))(" + t5 + ",params,alasql)";
        }, M.Json = function(e5) {
          return Object.assign(this, e5);
        }, M.Json.prototype.toString = function() {
          var e5 = "";
          return e5 + ln(this.value) + "";
        };
        var ln = L.utils.JSONtoString = function(e5) {
          var t5 = "";
          if ("string" == typeof e5)
            t5 = '"' + e5 + '"';
          else if ("number" == typeof e5)
            t5 = e5;
          else if ("boolean" == typeof e5)
            t5 = e5;
          else {
            if ("object" != typeof e5)
              throw new Error("2Can not show JSON object " + JSON.stringify(e5));
            if (Array.isArray(e5))
              t5 += "[" + e5.map(function(e6) {
                return ln(e6);
              }).join(",") + "]";
            else if (!e5.toJS || e5 instanceof M.Json) {
              var s5, t5 = "{", n5 = [];
              for (s5 in e5) {
                var r5 = "";
                if ("string" == typeof s5)
                  r5 += '"' + s5 + '"';
                else {
                  if ("number" != typeof s5 && "boolean" != typeof s5)
                    throw new Error("THis is not ES6... no expressions on left side yet");
                  r5 += s5;
                }
                r5 += ":" + ln(e5[s5]), n5.push(r5);
              }
              t5 += n5.join(",") + "}";
            } else {
              if (!e5.toString)
                throw new Error("1Can not show JSON object " + JSON.stringify(e5));
              t5 = e5.toString();
            }
          }
          return t5;
        };
        function cn(e5, t5, s5, n5) {
          var r5 = "";
          if ("string" == typeof e5)
            r5 = '"' + e5 + '"';
          else if ("number" == typeof e5)
            r5 = "(" + e5 + ")";
          else if ("boolean" == typeof e5)
            r5 = e5;
          else {
            if ("object" != typeof e5)
              throw new Error("2Can not parse JSON object " + JSON.stringify(e5));
            if (Array.isArray(e5))
              r5 += "[" + e5.map(function(e6) {
                return cn(e6, t5, s5, n5);
              }).join(",") + "]";
            else if (!e5.toJS || e5 instanceof M.Json) {
              var a5, r5 = "{", i5 = [];
              for (a5 in e5) {
                var o5 = "";
                if ("string" == typeof a5)
                  o5 += '"' + a5 + '"';
                else {
                  if ("number" != typeof a5 && "boolean" != typeof a5)
                    throw new Error("THis is not ES6... no expressions on left side yet");
                  o5 += a5;
                }
                o5 += ":" + cn(e5[a5], t5, s5, n5), i5.push(o5);
              }
              r5 += i5.join(",") + "}";
            } else {
              if (!e5.toJS)
                throw new Error("1Can not parse JSON object " + JSON.stringify(e5));
              r5 = e5.toJS(t5, s5, n5);
            }
          }
          return r5;
        }
        M.Json.prototype.toJS = function(e5, t5, s5) {
          return cn(this.value, e5, t5, s5);
        }, M.Convert = function(e5) {
          return Object.assign(this, e5);
        }, M.Convert.prototype.toString = function() {
          var e5 = "CONVERT(";
          return e5 += this.dbtypeid, void 0 !== this.dbsize && (e5 += "(" + this.dbsize, this.dbprecision && (e5 += "," + this.dbprecision), e5 += ")"), e5 += "," + this.expression.toString(), this.style && (e5 += "," + this.style), e5 += ")";
        }, M.Convert.prototype.toJS = function(e5, t5, s5) {
          return "alasql.stdfn.CONVERT(" + this.expression.toJS(e5, t5, s5) + ',{dbtypeid:"' + this.dbtypeid + '",dbsize:' + this.dbsize + ",dbprecision:" + this.dbprecision + ",style:" + this.style + "})";
        }, L.stdfn.CONVERT = function(e5, t5) {
          var s5 = e5;
          if (t5.style) {
            var n5 = /\d{8}/.test(s5) ? new Date(+s5.substr(0, 4), +s5.substr(4, 2) - 1, +s5.substr(6, 2)) : fn(s5);
            switch (t5.style) {
              case 1:
                s5 = ("0" + (n5.getMonth() + 1)).substr(-2) + "/" + ("0" + n5.getDate()).substr(-2) + "/" + ("0" + n5.getYear()).substr(-2);
                break;
              case 2:
                s5 = ("0" + n5.getYear()).substr(-2) + "." + ("0" + (n5.getMonth() + 1)).substr(-2) + "." + ("0" + n5.getDate()).substr(-2);
                break;
              case 3:
                s5 = ("0" + n5.getDate()).substr(-2) + "/" + ("0" + (n5.getMonth() + 1)).substr(-2) + "/" + ("0" + n5.getYear()).substr(-2);
                break;
              case 4:
                s5 = ("0" + n5.getDate()).substr(-2) + "." + ("0" + (n5.getMonth() + 1)).substr(-2) + "." + ("0" + n5.getYear()).substr(-2);
                break;
              case 5:
                s5 = ("0" + n5.getDate()).substr(-2) + "-" + ("0" + (n5.getMonth() + 1)).substr(-2) + "-" + ("0" + n5.getYear()).substr(-2);
                break;
              case 6:
                s5 = ("0" + n5.getDate()).substr(-2) + " " + n5.toString().substr(4, 3).toLowerCase() + " " + ("0" + n5.getYear()).substr(-2);
                break;
              case 7:
                s5 = n5.toString().substr(4, 3) + " " + ("0" + n5.getDate()).substr(-2) + "," + ("0" + n5.getYear()).substr(-2);
                break;
              case 8:
              case 108:
                s5 = ("0" + n5.getHours()).substr(-2) + ":" + ("0" + n5.getMinutes()).substr(-2) + ":" + ("0" + n5.getSeconds()).substr(-2);
                break;
              case 10:
                s5 = ("0" + (n5.getMonth() + 1)).substr(-2) + "-" + ("0" + n5.getDate()).substr(-2) + "-" + ("0" + n5.getYear()).substr(-2);
                break;
              case 11:
                s5 = ("0" + n5.getYear()).substr(-2) + "/" + ("0" + (n5.getMonth() + 1)).substr(-2) + "/" + ("0" + n5.getDate()).substr(-2);
                break;
              case 12:
                s5 = ("0" + n5.getYear()).substr(-2) + ("0" + (n5.getMonth() + 1)).substr(-2) + ("0" + n5.getDate()).substr(-2);
                break;
              case 101:
                s5 = ("0" + (n5.getMonth() + 1)).substr(-2) + "/" + ("0" + n5.getDate()).substr(-2) + "/" + n5.getFullYear();
                break;
              case 102:
                s5 = n5.getFullYear() + "." + ("0" + (n5.getMonth() + 1)).substr(-2) + "." + ("0" + n5.getDate()).substr(-2);
                break;
              case 103:
                s5 = ("0" + n5.getDate()).substr(-2) + "/" + ("0" + (n5.getMonth() + 1)).substr(-2) + "/" + n5.getFullYear();
                break;
              case 104:
                s5 = ("0" + n5.getDate()).substr(-2) + "." + ("0" + (n5.getMonth() + 1)).substr(-2) + "." + n5.getFullYear();
                break;
              case 105:
                s5 = ("0" + n5.getDate()).substr(-2) + "-" + ("0" + (n5.getMonth() + 1)).substr(-2) + "-" + n5.getFullYear();
                break;
              case 106:
                s5 = ("0" + n5.getDate()).substr(-2) + " " + n5.toString().substr(4, 3).toLowerCase() + " " + n5.getFullYear();
                break;
              case 107:
                s5 = n5.toString().substr(4, 3) + " " + ("0" + n5.getDate()).substr(-2) + "," + n5.getFullYear();
                break;
              case 110:
                s5 = ("0" + (n5.getMonth() + 1)).substr(-2) + "-" + ("0" + n5.getDate()).substr(-2) + "-" + n5.getFullYear();
                break;
              case 111:
                s5 = n5.getFullYear() + "/" + ("0" + (n5.getMonth() + 1)).substr(-2) + "/" + ("0" + n5.getDate()).substr(-2);
                break;
              case 112:
                s5 = n5.getFullYear() + ("0" + (n5.getMonth() + 1)).substr(-2) + ("0" + n5.getDate()).substr(-2);
                break;
              default:
                throw new Error("The CONVERT style " + t5.style + " is not realized yet.");
            }
          }
          var r5, a5, i5, e5 = t5.dbtypeid.toUpperCase();
          if ("Date" == t5.dbtypeid)
            return fn(s5);
          if ("DATE" == e5)
            return a5 = (r5 = fn(s5)).getFullYear() + "." + ("0" + (r5.getMonth() + 1)).substr(-2) + "." + ("0" + r5.getDate()).substr(-2);
          if ("DATETIME" == e5 || "DATETIME2" == e5)
            return a5 = (r5 = fn(s5)).getFullYear() + "." + ("0" + (r5.getMonth() + 1)).substr(-2) + "." + ("0" + r5.getDate()).substr(-2), (a5 += " " + ("0" + r5.getHours()).substr(-2) + ":" + ("0" + r5.getMinutes()).substr(-2) + ":" + ("0" + r5.getSeconds()).substr(-2)) + "." + ("00" + r5.getMilliseconds()).substr(-3);
          if (-1 < ["MONEY"].indexOf(e5))
            return (0 | (i5 = +s5)) + 100 * i5 % 100 / 100;
          if (-1 < ["BOOLEAN"].indexOf(e5))
            return !!s5;
          if (-1 < ["INT", "INTEGER", "SMALLINT", "BIGINT", "SERIAL", "SMALLSERIAL", "BIGSERIAL"].indexOf(t5.dbtypeid.toUpperCase()))
            return 0 | s5;
          if (-1 < ["STRING", "VARCHAR", "NVARCHAR", "CHARACTER VARIABLE"].indexOf(t5.dbtypeid.toUpperCase()))
            return t5.dbsize ? ("" + s5).substr(0, t5.dbsize) : "" + s5;
          if (-1 < ["CHAR", "CHARACTER", "NCHAR"].indexOf(e5))
            return (s5 + new Array(t5.dbsize + 1).join(" ")).substr(0, t5.dbsize);
          if (-1 < ["NUMBER", "FLOAT", "DECIMAL", "NUMERIC"].indexOf(e5))
            return i5 = +s5, i5 = void 0 !== t5.dbsize ? parseFloat(i5.toPrecision(t5.dbsize)) : i5, void 0 !== t5.dbprecision ? parseFloat(i5.toFixed(t5.dbprecision)) : i5;
          if (-1 < ["JSON"].indexOf(e5)) {
            if ("object" == typeof s5)
              return s5;
            try {
              return JSON.parse(s5);
            } catch (e6) {
              throw new Error("Cannot convert string to JSON");
            }
          }
          return s5;
        }, M.ColumnDef = function(e5) {
          return Object.assign(this, e5);
        }, M.ColumnDef.prototype.toString = function() {
          var e5 = this.columnid;
          return this.dbtypeid && (e5 += " " + this.dbtypeid), this.dbsize && (e5 += "(" + this.dbsize, this.dbprecision && (e5 += "," + this.dbprecision), e5 += ")"), this.primarykey && (e5 += " PRIMARY KEY"), this.notnull && (e5 += " NOT NULL"), e5;
        }, M.CreateTable = function(e5) {
          return Object.assign(this, e5);
        }, M.CreateTable.prototype.toString = function() {
          var e5 = "CREATE";
          return this.temporary && (e5 += " TEMPORARY"), this.view ? e5 += " VIEW" : e5 += " " + (this.class ? "CLASS" : "TABLE"), this.ifnotexists && (e5 += " IF  NOT EXISTS"), e5 += " " + this.table.toString(), this.viewcolumns && (e5 += "(" + this.viewcolumns.map(function(e6) {
            return e6.toString();
          }).join(",") + ")"), this.as ? e5 += " AS " + this.as : e5 += " (" + this.columns.map(function(e6) {
            return e6.toString();
          }).join(",") + ")", this.view && this.select && (e5 += " AS " + this.select.toString()), e5;
        }, M.CreateTable.prototype.execute = function(f5, p5, e5) {
          var t5 = L.databases[this.table.databaseid || f5], s5 = this.table.tableid;
          if (!s5)
            throw new Error("Table name is not defined");
          var n5 = this.columns, r5 = this.constraints || [];
          if (this.ifnotexists && t5.tables[s5])
            return e5 ? e5(0) : 0;
          if (t5.tables[s5])
            throw new Error("Can not create table '" + s5 + "', because it already exists in the database '" + t5.databaseid + "'");
          var a5, i5, l5 = t5.tables[s5] = new L.Table(), o5 = (this.class && (l5.isclass = true), []), u5 = [];
          return n5 && n5.forEach(function(s6) {
            var e6, t6 = s6.dbtypeid, t6 = (L.fn[t6] || (t6 = t6.toUpperCase()), -1 < ["SERIAL", "SMALLSERIAL", "BIGSERIAL"].indexOf(t6) && (s6.identity = { value: 1, step: 1 }), { columnid: s6.columnid, dbtypeid: t6, dbsize: s6.dbsize, dbprecision: s6.dbprecision, notnull: s6.notnull, identity: s6.identity });
            if (s6.identity && (l5.identities[s6.columnid] = { value: +s6.identity.value, step: +s6.identity.step }), s6.check && l5.checks.push({ id: s6.check.constrantid, fn: new Function("r", "var y;return " + s6.check.expression.toJS("r", "")) }), s6.default && o5.push("'" + s6.columnid + "':" + s6.default.toJS("r", "")), s6.primarykey && ((e6 = l5.pk = {}).columns = [s6.columnid], e6.onrightfns = "r['" + s6.columnid + "']", e6.onrightfn = new Function("r", "var y;return " + e6.onrightfns), e6.hh = Rs(e6.onrightfns), l5.uniqs[e6.hh] = {}), s6.unique && (e6 = {}, l5.uk = l5.uk || [], l5.uk.push(e6), e6.columns = [s6.columnid], e6.onrightfns = "r['" + s6.columnid + "']", e6.onrightfn = new Function("r", "var y;return " + e6.onrightfns), e6.hh = Rs(e6.onrightfns), l5.uniqs[e6.hh] = {}), s6.foreignkey) {
              var n6 = s6.foreignkey.table, r6 = L.databases[n6.databaseid || f5].tables[n6.tableid];
              if (void 0 === n6.columnid) {
                if (!(r6.pk.columns && 0 < r6.pk.columns.length))
                  throw new Error("FOREIGN KEY allowed only to tables with PRIMARY KEYs");
                n6.columnid = r6.pk.columns[0];
              }
              l5.checks.push({ fn: function(e7) {
                var t7 = {};
                if (void 0 === e7[s6.columnid])
                  return true;
                t7[n6.columnid] = e7[s6.columnid];
                e7 = r6.pk.onrightfn(t7);
                if (r6.uniqs[r6.pk.hh][e7])
                  return true;
                throw new Error("Foreign key violation");
              } });
            }
            s6.onupdate && u5.push("r['" + s6.columnid + "']=" + s6.onupdate.toJS("r", "")), l5.columns.push(t6), l5.xcolumns[t6.columnid] = t6;
          }), l5.defaultfns = o5.join(","), l5.onupdatefns = u5.join(";"), r5.forEach(function(e6) {
            var t6;
            if ("PRIMARY KEY" === e6.type) {
              if (l5.pk)
                throw new Error("Primary key already exists");
              var s6 = l5.pk = {};
              s6.columns = e6.columns, s6.onrightfns = s6.columns.map(function(e7) {
                return "r['" + e7 + "']";
              }).join("+'`'+"), s6.onrightfn = new Function("r", "var y;return " + s6.onrightfns), s6.hh = Rs(s6.onrightfns), l5.uniqs[s6.hh] = {};
            } else if ("CHECK" === e6.type)
              t6 = new Function("r", "var y;return " + e6.expression.toJS("r", ""));
            else if ("UNIQUE" === e6.type) {
              s6 = {};
              l5.uk = l5.uk || [], l5.uk.push(s6), s6.columns = e6.columns, s6.onrightfns = s6.columns.map(function(e7) {
                return "r['" + e7 + "']";
              }).join("+'`'+"), s6.onrightfn = new Function("r", "var y;return " + s6.onrightfns), s6.hh = Rs(s6.onrightfns), l5.uniqs[s6.hh] = {};
            } else if ("FOREIGN KEY" === e6.type) {
              var r6 = e6.fktable, s6 = (e6.fkcolumns && 0 < e6.fkcolumns.length && (r6.fkcolumns = e6.fkcolumns), L.databases[r6.databaseid || f5].tables[r6.tableid]);
              if (void 0 === r6.fkcolumns && (r6.fkcolumns = s6.pk.columns), r6.columns = e6.columns, r6.fkcolumns.length > r6.columns.length)
                throw new Error("Invalid foreign key on table " + l5.tableid);
              t6 = function(s7) {
                var n6 = {};
                if (r6.fkcolumns.forEach(function(e8, t8) {
                  null != s7[r6.columns[t8]] && (n6[e8] = s7[r6.columns[t8]]);
                }), 0 === Object.keys(n6).length)
                  return true;
                if (Object.keys(n6).length !== r6.columns.length)
                  throw new Error("Invalid foreign key on table " + l5.tableid);
                var e7 = L.databases[r6.databaseid || f5].tables[r6.tableid], t7 = e7.pk.onrightfn(n6);
                if (e7.uniqs[e7.pk.hh][t7])
                  return true;
                throw new Error("Foreign key violation");
              };
            }
            t6 && l5.checks.push({ fn: t6, id: e6.constraintid, fk: "FOREIGN KEY" === e6.type });
          }), this.view && this.viewcolumns && (a5 = this).viewcolumns.forEach(function(e6, t6) {
            a5.select.columns[t6].as = e6.columnid;
          }), this.view && this.select && (l5.view = true, l5.select = this.select.compile(this.table.databaseid || f5)), t5.engineid ? L.engines[t5.engineid].createTable(this.table.databaseid || f5, s5, this.ifnotexists, e5) : (l5.insert = function(s6, n6) {
            var e6 = L.inserted, r6 = (L.inserted = [s6], this), a6 = false, t6 = false;
            for (d5 in r6.beforeinsert)
              (i6 = r6.beforeinsert[d5]) && (i6.funcid ? false === L.fn[i6.funcid](s6) && (t6 = t6 || true) : i6.statement && false === i6.statement.execute(f5) && (t6 = t6 || true));
            if (!t6) {
              var i6, o6 = false;
              for (d5 in r6.insteadofinsert)
                o6 = true, (i6 = r6.insteadofinsert[d5]) && (i6.funcid ? L.fn[i6.funcid](s6) : i6.statement && i6.statement.execute(f5));
              if (!o6) {
                for (var u6 in r6.identities) {
                  var l6 = r6.identities[u6];
                  s6[u6] = l6.value;
                }
                if (r6.checks && 0 < r6.checks.length && r6.checks.forEach(function(e7) {
                  if (!e7.fn(s6))
                    throw new Error("Violation of CHECK constraint " + (e7.id || ""));
                }), r6.columns.forEach(function(e7) {
                  if (e7.notnull && void 0 === s6[e7.columnid])
                    throw new Error("Wrong NULL value in NOT NULL column " + e7.columnid);
                }), r6.pk) {
                  var c5, h5 = (c5 = r6.pk).onrightfn(s6);
                  if (void 0 !== r6.uniqs[c5.hh][h5]) {
                    if (!n6)
                      throw new Error("Cannot insert record, because it already exists in primary key index");
                    a6 = r6.uniqs[c5.hh][h5];
                  }
                }
                if (r6.uk && r6.uk.length && r6.uk.forEach(function(e7) {
                  var t7 = e7.onrightfn(s6);
                  if (void 0 !== r6.uniqs[e7.hh][t7]) {
                    if (!n6)
                      throw new Error("Cannot insert record, because it already exists in unique index");
                    a6 = r6.uniqs[e7.hh][t7];
                  }
                }), a6)
                  r6.update(function(e7) {
                    for (var t7 in s6)
                      e7[t7] = s6[t7];
                  }, r6.data.indexOf(a6), p5);
                else {
                  for (var u6 in r6.data.push(s6), r6.identities)
                    (l6 = r6.identities[u6]).value += l6.step;
                  r6.pk && (h5 = (c5 = r6.pk).onrightfn(s6), r6.uniqs[c5.hh][h5] = s6), r6.uk && r6.uk.length && r6.uk.forEach(function(e7) {
                    var t7 = e7.onrightfn(s6);
                    r6.uniqs[e7.hh][t7] = s6;
                  });
                }
                for (var d5 in r6.afterinsert)
                  (i6 = r6.afterinsert[d5]) && (i6.funcid ? L.fn[i6.funcid](s6) : i6.statement && i6.statement.execute(f5));
                L.inserted = e6;
              }
            }
          }, l5.delete = function(e6) {
            var s6 = this, n6 = s6.data[e6], t6 = false;
            for (r6 in s6.beforedelete)
              (i6 = s6.beforedelete[r6]) && (i6.funcid ? false === L.fn[i6.funcid](n6) && (t6 = t6 || true) : i6.statement && false === i6.statement.execute(f5) && (t6 = t6 || true));
            if (t6)
              return false;
            var r6, a6 = false;
            for (r6 in s6.insteadofdelete) {
              var i6, a6 = true;
              (i6 = s6.insteadofdelete[r6]) && (i6.funcid ? L.fn[i6.funcid](n6) : i6.statement && i6.statement.execute(f5));
            }
            if (!a6) {
              if (this.pk) {
                var e6 = this.pk, o6 = e6.onrightfn(n6);
                if (void 0 === this.uniqs[e6.hh][o6])
                  throw new Error("Something wrong with primary key index on table");
                this.uniqs[e6.hh][o6] = void 0;
              }
              s6.uk && s6.uk.length && s6.uk.forEach(function(e7) {
                var t7 = e7.onrightfn(n6);
                if (void 0 === s6.uniqs[e7.hh][t7])
                  throw new Error("Something wrong with unique index on table");
                s6.uniqs[e7.hh][t7] = void 0;
              });
            }
          }, l5.deleteall = function() {
            this.data.length = 0, this.pk && (this.uniqs[this.pk.hh] = {}), l5.uk && l5.uk.length && l5.uk.forEach(function(e6) {
              l5.uniqs[e6.hh] = {};
            });
          }, l5.update = function(e6, t6, s6) {
            var n6, r6 = Ds(this.data[t6]);
            if (this.pk && ((n6 = this.pk).pkaddr = n6.onrightfn(r6, s6), void 0 === this.uniqs[n6.hh][n6.pkaddr]))
              throw new Error("Something wrong with index on table");
            l5.uk && l5.uk.length && l5.uk.forEach(function(e7) {
              if (e7.ukaddr = e7.onrightfn(r6), void 0 === l5.uniqs[e7.hh][e7.ukaddr])
                throw new Error("Something wrong with unique index on table");
            }), e6(r6, s6, L);
            var a6 = false;
            for (u6 in l5.beforeupdate)
              (o6 = l5.beforeupdate[u6]) && (o6.funcid ? false === L.fn[o6.funcid](this.data[t6], r6) && (a6 = a6 || true) : o6.statement && false === o6.statement.execute(f5) && (a6 = a6 || true));
            if (a6)
              return false;
            var i6 = false;
            for (u6 in l5.insteadofupdate) {
              var o6, i6 = true;
              (o6 = l5.insteadofupdate[u6]) && (o6.funcid ? L.fn[o6.funcid](this.data[t6], r6) : o6.statement && o6.statement.execute(f5));
            }
            if (!i6) {
              if (l5.checks && 0 < l5.checks.length && l5.checks.forEach(function(e7) {
                if (!e7.fn(r6))
                  throw new Error("Violation of CHECK constraint " + (e7.id || ""));
              }), l5.columns.forEach(function(e7) {
                if (e7.notnull && void 0 === r6[e7.columnid])
                  throw new Error("Wrong NULL value in NOT NULL column " + e7.columnid);
              }), this.pk && (n6.newpkaddr = n6.onrightfn(r6), void 0 !== this.uniqs[n6.hh][n6.newpkaddr]) && n6.newpkaddr !== n6.pkaddr)
                throw new Error("Record already exists");
              for (var u6 in l5.uk && l5.uk.length && l5.uk.forEach(function(e7) {
                if (e7.newukaddr = e7.onrightfn(r6), void 0 !== l5.uniqs[e7.hh][e7.newukaddr] && e7.newukaddr !== e7.ukaddr)
                  throw new Error("Record already exists");
              }), this.pk && (this.uniqs[n6.hh][n6.pkaddr] = void 0, this.uniqs[n6.hh][n6.newpkaddr] = r6), l5.uk && l5.uk.length && l5.uk.forEach(function(e7) {
                l5.uniqs[e7.hh][e7.ukaddr] = void 0, l5.uniqs[e7.hh][e7.newukaddr] = r6;
              }), this.data[t6] = r6, l5.afterupdate)
                (o6 = l5.afterupdate[u6]) && (o6.funcid ? L.fn[o6.funcid](this.data[t6], r6) : o6.statement && o6.statement.execute(f5));
            }
          }, L.options.nocount || (i5 = 1), e5 ? e5(i5) : i5);
        }, L.fn.Date = Object, L.fn.Date = Date, L.fn.Number = Number, L.fn.String = String, L.fn.Boolean = Boolean, an.EXTEND = L.utils.extend, an.CHAR = String.fromCharCode.bind(String), an.ASCII = function(e5) {
          return e5.charCodeAt(0);
        }, an.COALESCE = function() {
          for (var e5 = 0; e5 < arguments.length; e5++)
            if (null != arguments[e5] && ("number" != typeof arguments[e5] || !isNaN(arguments[e5])))
              return arguments[e5];
        }, an.USER = function() {
          return "alasql";
        }, an.OBJECT_ID = function(e5) {
          return !!L.tables[e5];
        }, an.DATE = function(e5) {
          return /\d{8}/.test(e5) ? new Date(+e5.substr(0, 4), +e5.substr(4, 2) - 1, +e5.substr(6, 2)) : fn(e5);
        }, an.NOW = function() {
          var e5 = /* @__PURE__ */ new Date(), t5 = e5.getFullYear() + "-" + ("0" + (e5.getMonth() + 1)).substr(-2) + "-" + ("0" + e5.getDate()).substr(-2);
          return (t5 += " " + ("0" + e5.getHours()).substr(-2) + ":" + ("0" + e5.getMinutes()).substr(-2) + ":" + ("0" + e5.getSeconds()).substr(-2)) + ("." + ("00" + e5.getMilliseconds()).substr(-3));
        }, an.GETDATE = an.NOW, an.CURRENT_TIMESTAMP = an.NOW, an.SECOND = function(e5) {
          return (e5 = fn(e5)).getSeconds();
        }, an.MINUTE = function(e5) {
          return (e5 = fn(e5)).getMinutes();
        }, an.HOUR = function(e5) {
          return (e5 = fn(e5)).getHours();
        }, an.DAYOFWEEK = an.WEEKDAY = function(e5) {
          return (e5 = fn(e5)).getDay();
        }, an.DAY = an.DAYOFMONTH = function(e5) {
          return (e5 = fn(e5)).getDate();
        }, an.MONTH = function(e5) {
          return (e5 = fn(e5)).getMonth() + 1;
        }, an.YEAR = function(e5) {
          return (e5 = fn(e5)).getFullYear();
        };
        var hn = { year: 31536e6, quarter: 7884e6, month: 2592e6, week: 6048e5, day: 864e5, dayofyear: 864e5, weekday: 864e5, hour: 36e5, minute: 6e4, second: 1e3, millisecond: 1, microsecond: 1e-3 }, dn = (L.stdfn.DATEDIFF = function(e5, t5, s5) {
          return (fn(s5).getTime() - fn(t5).getTime()) / hn[e5.toLowerCase()];
        }, L.stdfn.DATEADD = function(e5, t5, s5) {
          var n5 = fn(s5);
          switch (e5 = e5.toLowerCase()) {
            case "year":
              n5.setFullYear(n5.getFullYear() + t5);
              break;
            case "quarter":
              n5.setMonth(n5.getMonth() + 3 * t5);
              break;
            case "month":
              n5.setMonth(n5.getMonth() + t5);
              break;
            default:
              n5 = new Date(n5.getTime() + t5 * hn[e5]);
          }
          return n5;
        }, L.stdfn.INTERVAL = function(e5, t5) {
          return e5 * hn[t5.toLowerCase()];
        }, L.stdfn.DATE_ADD = L.stdfn.ADDDATE = function(e5, t5) {
          e5 = fn(e5).getTime() + t5;
          return new Date(e5);
        }, L.stdfn.DATE_SUB = L.stdfn.SUBDATE = function(e5, t5) {
          e5 = fn(e5).getTime() - t5;
          return new Date(e5);
        }, /^\d{4}\.\d{2}\.\d{2} \d{2}:\d{2}:\d{2}/);
        function fn(e5) {
          return "string" == typeof e5 && dn.test(e5) && (e5 = e5.replace(".", "-").replace(".", "-")), new Date(e5);
        }
        function pn(t5) {
          var s5 = "";
          if (void 0 === t5)
            s5 += "undefined";
          else if (Array.isArray(t5)) {
            var e5, s5 = (s5 = (s5 = s5 + "<style>table {border:1px black solid; border-collapse: collapse; border-spacing: 0px;}") + "td,th {border:1px black solid; padding-left:5px; padding-right:5px}th {background-color: #EEE}") + "</style><table>", n5 = [];
            for (e5 in t5[0])
              n5.push(e5);
            s5 += "<tr><th>#", n5.forEach(function(e6) {
              s5 += "<th>" + e6;
            });
            for (var r5 = 0, a5 = t5.length; r5 < a5; r5++)
              s5 += "<tr><th>" + (r5 + 1), n5.forEach(function(e6) {
                s5 += "<td> ", t5[r5][e6] == +t5[r5][e6] ? (s5 += '<div style="text-align:right">', void 0 === t5[r5][e6] ? s5 += "NULL" : s5 += t5[r5][e6], s5 += "</div>") : void 0 === t5[r5][e6] ? s5 += "NULL" : "string" == typeof t5[r5][e6] ? s5 += t5[r5][e6] : s5 += ln(t5[r5][e6]);
              });
            s5 += "</table>";
          } else
            s5 += "<p>" + ln(t5) + "</p>";
          return s5;
        }
        function bn(e5, t5, s5) {
          var n5;
          s5 <= 0 || (n5 = (t5 - e5.scrollTop) / s5 * 10, setTimeout(function() {
            e5.scrollTop !== t5 && (e5.scrollTop = e5.scrollTop + n5, bn(e5, t5, s5 - 10));
          }, 10));
        }
        function En(b5, e5, E5, g5, m5, T5) {
          var S5 = {};
          function A5(e6) {
            return e6 && false === L.options.casesensitive ? e6.toLowerCase() : e6;
          }
          E5 = E5 || {}, L.utils.extend(S5, E5), void 0 === S5.headers && (S5.headers = true), e5 = L.utils.autoExtFilename(e5, "xls", E5), L.utils.loadBinaryFile(e5, !!g5, function(e6) {
            t5 = e6 instanceof ArrayBuffer ? (r5 = function(e7) {
              for (var t6 = "", s6 = 0, n6 = 10240; s6 < e7.byteLength / n6; ++s6)
                t6 += String.fromCharCode.apply(null, new Uint8Array(e7.slice(s6 * n6, s6 * n6 + n6)));
              return t6 += String.fromCharCode.apply(null, new Uint8Array(e7.slice(s6 * n6)));
            }(e6), b5.read(btoa(r5), { type: "base64", ...L.options.excel, ...E5 })) : b5.read(e6, { type: "binary", ...L.options.excel, ...E5 }), s5 = void 0 === S5.sheetid ? t5.SheetNames[0] : "number" == typeof S5.sheetid ? t5.SheetNames[S5.sheetid] : S5.sheetid;
            var t5, s5, n5 = [];
            if (void 0 === S5.range ? i5 = t5.Sheets[s5]["!ref"] : (i5 = S5.range, t5.Sheets[s5][i5] && (i5 = t5.Sheets[s5][i5])), i5) {
              for (var r5 = i5.split(":"), e6 = r5[0].match(/[A-Z]+/)[0], a5 = +r5[0].match(/[0-9]+/)[0], i5 = r5[1].match(/[A-Z]+/)[0], o5 = +r5[1].match(/[0-9]+/)[0], u5 = {}, l5 = L.utils.xlscn(e6), c5 = L.utils.xlscn(i5), h5 = l5; h5 <= c5; h5++) {
                var d5 = L.utils.xlsnc(h5);
                S5.headers ? t5.Sheets[s5][d5 + "" + a5] ? u5[d5] = A5(t5.Sheets[s5][d5 + "" + a5].v) : u5[d5] = A5(d5) : u5[d5] = d5;
              }
              S5.headers && a5++;
              for (var f5 = a5; f5 <= o5; f5++) {
                for (var p5 = {}, h5 = l5; h5 <= c5; h5++) {
                  d5 = L.utils.xlsnc(h5);
                  t5.Sheets[s5][d5 + "" + f5] && (p5[u5[d5]] = t5.Sheets[s5][d5 + "" + f5].v);
                }
                n5.push(p5);
              }
            } else
              n5.push([]);
            0 < n5.length && n5[n5.length - 1] && 0 == Object.keys(n5[n5.length - 1]).length && n5.pop(), g5 && g5(n5, m5, T5);
          }, function(e6) {
            throw e6;
          });
        }
        M.DropTable = function(e5) {
          return Object.assign(this, e5);
        }, M.DropTable.prototype.toString = function() {
          var e5 = "DROP ";
          return this.view ? e5 += "VIEW" : e5 += "TABLE", this.ifexists && (e5 += " IF EXISTS"), e5 += " " + this.tables.toString();
        }, M.DropTable.prototype.execute = function(n5, e5, r5) {
          var a5 = this.ifexists, i5 = 0, o5 = 0, u5 = this.tables.length;
          return this.tables.forEach(function(e6) {
            var t5 = L.databases[e6.databaseid || n5], s5 = e6.tableid;
            if (!a5 || t5.tables[s5]) {
              if (t5.tables[s5])
                t5.engineid ? L.engines[t5.engineid].dropTable(e6.databaseid || n5, s5, a5, function(e7) {
                  delete t5.tables[s5], i5 += e7, ++o5 == u5 && r5 && r5(i5);
                }) : (delete t5.tables[s5], i5++, ++o5 == u5 && r5 && r5(i5));
              else if (!L.options.dropifnotexists)
                throw new Error("Can not drop table '" + e6.tableid + "', because it does not exist in the database.");
            } else
              ++o5 == u5 && r5 && r5(i5);
          }), i5;
        }, M.TruncateTable = function(e5) {
          return Object.assign(this, e5);
        }, M.TruncateTable.prototype.toString = function() {
          var e5 = "TRUNCATE TABLE";
          return e5 += " " + this.table.toString();
        }, M.TruncateTable.prototype.execute = function(e5, t5, s5) {
          var n5 = L.databases[this.table.databaseid || e5], r5 = this.table.tableid;
          if (n5.engineid)
            return L.engines[n5.engineid].truncateTable(this.table.databaseid || e5, r5, this.ifexists, s5);
          if (n5.tables[r5])
            return n5.tables[r5].data = [], s5 ? s5(0) : 0;
          throw new Error("Cannot truncate table becaues it does not exist");
        }, M.CreateVertex = function(e5) {
          return Object.assign(this, e5);
        }, M.CreateVertex.prototype.toString = function() {
          var e5 = "CREATE VERTEX ";
          return this.class && (e5 += this.class + " "), this.sharp && (e5 += "#" + this.sharp + " "), this.sets ? e5 += this.sets.toString() : this.content ? e5 += this.content.toString() : this.select && (e5 += this.select.toString()), e5;
        }, M.CreateVertex.prototype.toJS = function(e5) {
          return "this.queriesfn[" + (this.queriesidx - 1) + "](this.params,null," + e5 + ")";
        }, M.CreateVertex.prototype.compile = function(e5) {
          var r5, t5, a5, i5 = e5, o5 = this.sharp;
          void 0 !== this.name && (t5 = "x.name=" + this.name.toJS(), r5 = new Function("x", t5)), this.sets && 0 < this.sets.length && (t5 = this.sets.map(function(e6) {
            return "x['" + e6.column.columnid + "']=" + e6.expression.toJS("x", "");
          }).join(";"), a5 = new Function("x,params,alasql", t5));
          return function(e6, t6) {
            var s5 = L.databases[i5], n5 = void 0 !== o5 ? o5 : s5.counter++, n5 = { $id: n5, $node: "VERTEX" }, s5 = s5.objects[n5.$id] = n5;
            return r5 && r5(n5), a5 && a5(n5, e6, L), s5 = t6 ? t6(s5) : s5;
          };
        }, M.CreateEdge = function(e5) {
          return Object.assign(this, e5);
        }, M.CreateEdge.prototype.toString = function() {
          var e5 = "CREATE EDGE ";
          return this.class && (e5 += this.class + " "), e5;
        }, M.CreateEdge.prototype.toJS = function(e5) {
          return "this.queriesfn[" + (this.queriesidx - 1) + "](this.params,null," + e5 + ")";
        }, M.CreateEdge.prototype.compile = function(e5) {
          var o5, t5, u5, l5 = e5, c5 = new Function("params,alasql", "var y;return " + this.from.toJS()), h5 = new Function("params,alasql", "var y;return " + this.to.toJS());
          void 0 !== this.name && (t5 = "x.name=" + this.name.toJS(), o5 = new Function("x", t5)), this.sets && 0 < this.sets.length && (t5 = this.sets.map(function(e6) {
            return "x['" + e6.column.columnid + "']=" + e6.expression.toJS("x", "");
          }).join(";"), u5 = new Function("x,params,alasql", "var y;" + t5));
          return function(e6, t6) {
            var s5 = 0, n5 = L.databases[l5], r5 = { $id: n5.counter++, $node: "EDGE" }, a5 = c5(e6, L), i5 = h5(e6, L);
            return r5.$in = [a5.$id], r5.$out = [i5.$id], void 0 === a5.$out && (a5.$out = []), a5.$out.push(r5.$id), i5.$in, i5.$in.push(r5.$id), s5 = n5.objects[r5.$id] = r5, o5 && o5(r5), u5 && u5(r5, e6, L), s5 = t6 ? t6(s5) : s5;
          };
        }, M.CreateGraph = function(e5) {
          return Object.assign(this, e5);
        }, M.CreateGraph.prototype.toString = function() {
          var e5 = "CREATE GRAPH ";
          return this.class && (e5 += this.class + " "), e5;
        }, M.CreateGraph.prototype.execute = function(o5, u5, e5) {
          var l5 = [];
          return this.from && L.from[this.from.funcid] && (this.graph = L.from[this.from.funcid.toUpperCase()]), this.graph.forEach(function(e6) {
            if (e6.source) {
              var t5, s5, n5, r5, a5 = {}, i5 = (void 0 !== e6.as && (L.vars[e6.as] = a5), void 0 !== e6.prop && (a5.name = e6.prop), void 0 !== e6.sharp && (a5.$id = e6.sharp), void 0 !== e6.name && (a5.name = e6.name), void 0 !== e6.class && (a5.$class = e6.class), L.databases[o5]);
              if (void 0 === a5.$id && (a5.$id = i5.counter++), a5.$node = "EDGE", void 0 !== e6.json && Fs(a5, new Function("params,alasql", "var y;return " + e6.json.toJS())(u5, L)), e6.source.vars ? t5 = "object" == typeof (s5 = L.vars[e6.source.vars]) ? s5 : i5.objects[s5] : (void 0 === (r5 = e6.source.sharp) && (r5 = e6.source.prop), void 0 !== (t5 = L.databases[o5].objects[r5]) || !L.options.autovertex || void 0 === e6.source.prop && void 0 === e6.source.name || void 0 === (t5 = c5(e6.source.prop || e6.source.name)) && (t5 = h5(e6.source))), e6.source.vars ? n5 = "object" == typeof (s5 = L.vars[e6.target.vars]) ? s5 : i5.objects[s5] : (void 0 === (r5 = e6.target.sharp) && (r5 = e6.target.prop), void 0 !== (n5 = L.databases[o5].objects[r5]) || !L.options.autovertex || void 0 === e6.target.prop && void 0 === e6.target.name || void 0 === (n5 = c5(e6.target.prop || e6.target.name)) && (n5 = h5(e6.target))), a5.$in = [t5.$id], a5.$out = [n5.$id], void 0 === t5.$out && (t5.$out = []), t5.$out.push(a5.$id), void 0 === n5.$in && (n5.$in = []), n5.$in.push(a5.$id), void 0 !== (i5.objects[a5.$id] = a5).$class) {
                if (void 0 === L.databases[o5].tables[a5.$class])
                  throw new Error("No such class. Pleace use CREATE CLASS");
                L.databases[o5].tables[a5.$class].data.push(a5);
              }
              l5.push(a5.$id);
            } else
              h5(e6);
          }), l5 = e5 ? e5(l5) : l5;
          function c5(e6) {
            var t5, s5 = L.databases[L.useid].objects;
            for (t5 in s5)
              if (s5[t5].name === e6)
                return s5[t5];
          }
          function h5(e6) {
            var t5 = {}, s5 = (void 0 !== e6.as && (L.vars[e6.as] = t5), void 0 !== e6.prop && (t5.$id = e6.prop, t5.name = e6.prop), void 0 !== e6.sharp && (t5.$id = e6.sharp), void 0 !== e6.name && (t5.name = e6.name), void 0 !== e6.class && (t5.$class = e6.class), L.databases[o5]);
            if (void 0 === t5.$id && (t5.$id = s5.counter++), t5.$node = "VERTEX", void 0 !== e6.json && Fs(t5, new Function("params,alasql", "var y;return " + e6.json.toJS())(u5, L)), void 0 !== (s5.objects[t5.$id] = t5).$class) {
              if (void 0 === L.databases[o5].tables[t5.$class])
                throw new Error("No such class. Pleace use CREATE CLASS");
              L.databases[o5].tables[t5.$class].data.push(t5);
            }
            return l5.push(t5.$id), t5;
          }
        }, M.CreateGraph.prototype.compile1 = function(e5) {
          var o5, t5, u5, l5 = e5, c5 = new Function("params,alasql", "var y;return " + this.from.toJS()), h5 = new Function("params,alasql", "var y;return " + this.to.toJS());
          void 0 !== this.name && (t5 = "x.name=" + this.name.toJS(), o5 = new Function("x", t5)), this.sets && 0 < this.sets.length && (t5 = this.sets.map(function(e6) {
            return "x['" + e6.column.columnid + "']=" + e6.expression.toJS("x", "");
          }).join(";"), u5 = new Function("x,params,alasql", "var y;" + t5));
          return function(e6, t6) {
            var s5 = 0, n5 = L.databases[l5], r5 = { $id: n5.counter++, $node: "EDGE" }, a5 = c5(e6, L), i5 = h5(e6, L);
            return r5.$in = [a5.$id], r5.$out = [i5.$id], void 0 === a5.$out && (a5.$out = []), a5.$out.push(r5.$id), void 0 === i5.$in && (i5.$in = []), i5.$in.push(r5.$id), s5 = n5.objects[r5.$id] = r5, o5 && o5(r5), u5 && u5(r5, e6, L), s5 = t6 ? t6(s5) : s5;
          };
        }, M.AlterTable = function(e5) {
          return Object.assign(this, e5);
        }, M.AlterTable.prototype.toString = function() {
          var e5 = "ALTER TABLE " + this.table.toString();
          return this.renameto && (e5 += " RENAME TO " + this.renameto), e5;
        }, M.AlterTable.prototype.execute = function(e5, t5, s5) {
          if ((p5 = L.databases[e5]).dbversion = Date.now(), this.renameto) {
            var n5 = this.table.tableid, r5 = this.renameto, a5 = 1;
            if (p5.tables[r5])
              throw new Error("Can not rename a table '" + n5 + "' to '" + r5 + "', because the table with this name already exists");
            if (r5 === n5)
              throw new Error("Can not rename a table '" + n5 + "' to itself");
            return p5.tables[r5] = p5.tables[n5], delete p5.tables[n5], a5 = 1, s5 && s5(a5), a5;
          }
          if (this.addcolumn) {
            (p5 = L.databases[this.table.databaseid || e5]).dbversion++;
            var i5 = this.table.tableid, o5 = p5.tables[i5], u5 = this.addcolumn.columnid;
            if (o5.xcolumns[u5])
              throw new Error('Cannot add column "' + u5 + '", because it already exists in the table "' + i5 + '"');
            var l5 = { columnid: u5, dbtypeid: this.addcolumn.dbtypeid, dbsize: this.dbsize, dbprecision: this.dbprecision, dbenum: this.dbenum, defaultfns: null };
            o5.columns.push(l5), o5.xcolumns[u5] = l5;
            for (var c5 = 0, h5 = o5.data.length; c5 < h5; c5++)
              o5.data[c5][u5] = void 0;
            return s5 ? s5(1) : 1;
          }
          if (this.modifycolumn) {
            i5 = ((p5 = L.databases[this.table.databaseid || e5]).dbversion++, this.table.tableid), o5 = p5.tables[i5], u5 = this.modifycolumn.columnid;
            if (o5.xcolumns[u5])
              return (l5 = o5.xcolumns[u5]).dbtypeid = this.dbtypeid, l5.dbsize = this.dbsize, l5.dbprecision = this.dbprecision, l5.dbenum = this.dbenum, s5 ? s5(1) : 1;
            throw new Error('Cannot modify column "' + u5 + '", because it was not found in the table "' + i5 + '"');
          }
          if (this.renamecolumn) {
            (p5 = L.databases[this.table.databaseid || e5]).dbversion++;
            var i5 = this.table.tableid, o5 = p5.tables[i5], u5 = this.renamecolumn, d5 = this.to;
            if (!o5.xcolumns[u5])
              throw new Error('Column "' + u5 + '" is not found in the table "' + i5 + '"');
            if (o5.xcolumns[d5])
              throw new Error('Column "' + d5 + '" already exists in the table "' + i5 + '"');
            if (u5 == d5)
              return s5 ? s5(0) : 0;
            for (var f5 = 0; f5 < o5.columns.length; f5++)
              o5.columns[f5].columnid == u5 && (o5.columns[f5].columnid = d5);
            o5.xcolumns[d5] = o5.xcolumns[u5], delete o5.xcolumns[u5];
            for (c5 = 0, h5 = o5.data.length; c5 < h5; c5++)
              o5.data[c5][d5] = o5.data[c5][u5], delete o5.data[c5][u5];
            return o5.data.length;
          }
          if (this.dropcolumn) {
            (p5 = L.databases[this.table.databaseid || e5]).dbversion++;
            for (var p5, i5 = this.table.tableid, o5 = p5.tables[i5], u5 = this.dropcolumn, b5 = false, f5 = 0; f5 < o5.columns.length; f5++)
              if (o5.columns[f5].columnid == u5) {
                b5 = true, o5.columns.splice(f5, 1);
                break;
              }
            if (!b5)
              throw new Error('Cannot drop column "' + u5 + '", because it was not found in the table "' + i5 + '"');
            for (delete o5.xcolumns[u5], c5 = 0, h5 = o5.data.length; c5 < h5; c5++)
              delete o5.data[c5][u5];
            return s5 ? s5(o5.data.length) : o5.data.length;
          }
          throw Error("Unknown ALTER TABLE method");
        }, M.CreateIndex = function(e5) {
          return Object.assign(this, e5);
        }, M.CreateIndex.prototype.toString = function() {
          var e5 = "CREATE";
          return this.unique && (e5 += " UNIQUE"), e5 = (e5 += " INDEX " + this.indexid + " ON " + this.table.toString()) + ("(" + this.columns.toString() + ")");
        }, M.CreateIndex.prototype.execute = function(e5, t5, s5) {
          var e5 = L.databases[e5], n5 = this.table.tableid, r5 = e5.tables[n5], a5 = this.indexid, i5 = (e5.indices[a5] = n5, this.columns.map(function(e6) {
            return e6.expression.toJS("r", "");
          }).join("+'`'+")), o5 = new Function("r,params,alasql", "return " + i5);
          if (this.unique) {
            r5.uniqdefs[a5] = { rightfns: i5 };
            var u5 = r5.uniqs[a5] = {};
            if (0 < r5.data.length)
              for (var l5 = 0, c5 = r5.data.length; l5 < c5; l5++)
                u5[d5 = i5(r5.data[l5])] || (u5[d5] = { num: 0 }), u5[d5].num++;
          } else {
            var e5 = Rs(i5), h5 = (r5.inddefs[a5] = { rightfns: i5, hh: e5 }, r5.indices[e5] = {}, r5.indices[e5] = {});
            if (0 < r5.data.length)
              for (var d5, l5 = 0, c5 = r5.data.length; l5 < c5; l5++)
                h5[d5 = o5(r5.data[l5], t5, L)] || (h5[d5] = []), h5[d5].push(r5.data[l5]);
          }
          n5 = 1;
          return n5 = s5 ? s5(n5) : n5;
        }, M.Reindex = function(e5) {
          return Object.assign(this, e5);
        }, M.Reindex.prototype.toString = function() {
          return "REINDEX " + this.indexid;
        }, M.Reindex.prototype.execute = function(e5, t5, s5) {
          var e5 = L.databases[e5], n5 = this.indexid, n5 = e5.indices[n5], e5 = (e5.tables[n5].indexColumns(), 1);
          return e5 = s5 ? s5(e5) : e5;
        }, M.DropIndex = function(e5) {
          return Object.assign(this, e5);
        }, M.DropIndex.prototype.toString = function() {
          return "DROP INDEX" + this.indexid;
        }, M.DropIndex.prototype.compile = function(e5) {
          this.indexid;
          return function() {
            return 1;
          };
        }, M.WithSelect = function(e5) {
          return Object.assign(this, e5);
        }, M.WithSelect.prototype.toString = function() {
          var e5 = "WITH ";
          return (e5 += this.withs.map(function(e6) {
            return e6.name + " AS (" + e6.select.toString() + ")";
          }).join(",") + " ") + this.select.toString();
        }, M.WithSelect.prototype.execute = function(s5, t5, n5) {
          var r5 = this, a5 = [];
          r5.withs.forEach(function(e5) {
            a5.push(L.databases[s5].tables[e5.name]), (L.databases[s5].tables[e5.name] = new Vs({ tableid: e5.name })).data = e5.select.execute(s5, t5);
          });
          return this.select.execute(s5, t5, function(e5) {
            return r5.withs.forEach(function(e6, t6) {
              a5[t6] ? L.databases[s5].tables[e6.name] = a5[t6] : delete L.databases[s5].tables[e6.name];
            }), e5 = n5 ? n5(e5) : e5;
          });
        }, M.If = function(e5) {
          return Object.assign(this, e5);
        }, M.If.prototype.toString = function() {
          var e5 = "IF ", e5 = (e5 += this.expression.toString()) + (" " + this.thenstat.toString());
          return this.elsestat && (e5 += " ELSE " + this.thenstat.toString()), e5;
        }, M.If.prototype.execute = function(e5, t5, s5) {
          var n5;
          return new Function("params,alasql,p", "var y;return " + this.expression.toJS("({})", "", null)).bind(this)(t5, L) ? n5 = this.thenstat.execute(e5, t5, s5) : this.elsestat ? n5 = this.elsestat.execute(e5, t5, s5) : s5 && (n5 = s5(n5)), n5;
        }, M.While = function(e5) {
          return Object.assign(this, e5);
        }, M.While.prototype.toString = function() {
          var e5 = "WHILE ";
          return (e5 += this.expression.toString()) + (" " + this.loopstat.toString());
        }, M.While.prototype.execute = function(t5, s5, n5) {
          var r5 = this, a5 = [], i5 = new Function("params,alasql,p", "var y;return " + this.expression.toJS());
          if (n5) {
            var o5 = false, u5 = function(e6) {
              o5 ? a5.push(e6) : o5 = true, setTimeout(function() {
                i5(s5, L) ? r5.loopstat.execute(t5, s5, u5) : a5 = n5(a5);
              }, 0);
            };
            u5();
          } else
            for (; i5(s5, L); ) {
              var e5 = r5.loopstat.execute(t5, s5);
              a5.push(e5);
            }
          return a5;
        }, M.Break = function(e5) {
          return Object.assign(this, e5);
        }, M.Break.prototype.toString = function() {
          return "BREAK";
        }, M.Break.prototype.execute = function(e5, t5, s5, n5) {
          var r5 = 1;
          return r5 = s5 ? s5(r5) : r5;
        }, M.Continue = function(e5) {
          return Object.assign(this, e5);
        }, M.Continue.prototype.toString = function() {
          return "CONTINUE";
        }, M.Continue.prototype.execute = function(e5, t5, s5, n5) {
          var r5 = 1;
          return r5 = s5 ? s5(r5) : r5;
        }, M.BeginEnd = function(e5) {
          return Object.assign(this, e5);
        }, M.BeginEnd.prototype.toString = function() {
          return "BEGIN " + this.statements.toString() + " END";
        }, M.BeginEnd.prototype.execute = function(e5, s5, n5, t5) {
          var r5 = this, a5 = [], i5 = 0;
          return function t6() {
            r5.statements[i5].execute(e5, s5, function(e6) {
              if (a5.push(e6), ++i5 < r5.statements.length)
                return t6();
              n5 && (a5 = n5(a5));
            });
          }(), a5;
        }, M.Insert = function(e5) {
          return Object.assign(this, e5);
        }, M.Insert.prototype.toString = function() {
          var e5 = "INSERT ";
          return this.orreplace && (e5 += "OR REPLACE "), this.replaceonly && (e5 = "REPLACE "), e5 += "INTO " + this.into.toString(), this.columns && (e5 += "(" + this.columns.toString() + ")"), this.values && (e5 += " VALUES " + this.values.map(function(e6) {
            return "(" + e6.toString() + ")";
          }).join(",")), this.select && (e5 += " " + this.select.toString()), e5;
        }, M.Insert.prototype.toJS = function(e5, t5, s5) {
          return "this.queriesfn[" + (this.queriesidx - 1) + "](this.params,null," + e5 + ")";
        }, M.Insert.prototype.compile = function(a5) {
          var o5 = this, s5 = (a5 = o5.into.databaseid || a5, L.databases[a5]), u5 = o5.into.tableid, i5 = s5.tables[u5];
          if (!i5)
            throw "Table '" + u5 + "' could not be found";
          var n5, e5 = "", t5 = "", e5 = "db.tables['" + u5 + "'].dirty=true;", r5 = "var a,aa=[],x;";
          if (this.values) {
            this.exists && (this.existsfn = this.exists.map(function(e6) {
              e6 = e6.compile(a5);
              return e6.query.modifier = "RECORDSET", e6;
            })), this.queries && (this.queriesfn = this.queries.map(function(e6) {
              e6 = e6.compile(a5);
              return e6.query.modifier = "RECORDSET", e6;
            })), o5.values.forEach(function(n6) {
              var r6 = [];
              o5.columns ? o5.columns.forEach(function(e6, t6) {
                var s6 = "'" + e6.columnid + "':";
                i5.xcolumns && i5.xcolumns[e6.columnid] ? 0 <= ["INT", "FLOAT", "NUMBER", "MONEY"].indexOf(i5.xcolumns[e6.columnid].dbtypeid) ? s6 += "(x=" + n6[t6].toJS() + ",x==undefined?undefined:+x)" : L.fn[i5.xcolumns[e6.columnid].dbtypeid] ? s6 = (s6 += "(new " + i5.xcolumns[e6.columnid].dbtypeid + "(") + n6[t6].toJS() + "))" : s6 += n6[t6].toJS() : s6 += n6[t6].toJS(), r6.push(s6);
              }) : Array.isArray(n6) && i5.columns && 0 < i5.columns.length ? i5.columns.forEach(function(e6, t6) {
                var s6 = "'" + e6.columnid + "':";
                0 <= ["INT", "FLOAT", "NUMBER", "MONEY"].indexOf(e6.dbtypeid) ? s6 += "+" + n6[t6].toJS() : L.fn[e6.dbtypeid] ? s6 = (s6 += "(new " + e6.dbtypeid + "(") + n6[t6].toJS() + "))" : s6 += n6[t6].toJS(), r6.push(s6);
              }) : t5 = cn(n6), s5.tables[u5].defaultfns && r6.unshift(s5.tables[u5].defaultfns), e5 += t5 ? "a=" + t5 + ";" : "a={" + r6.join(",") + "};", s5.tables[u5].isclass && (e5 = e5 + "var db=alasql.databases['" + a5 + `'];a.$class="` + u5 + '";a.$id=db.counter++;db.objects[a.$id]=a;'), s5.tables[u5].insert ? e5 = (e5 += "var db=alasql.databases['" + a5 + "'];") + "db.tables['" + u5 + "'].insert(a," + (o5.orreplace ? "true" : "false") + ");" : e5 += "aa.push(a);";
            }), n5 = r5 + e5, s5.tables[u5].insert || (e5 += "alasql.databases['" + a5 + "'].tables['" + u5 + "'].data=alasql.databases['" + a5 + "'].tables['" + u5 + "'].data.concat(aa);"), s5.tables[u5].insert && s5.tables[u5].isclass ? e5 += "return a.$id;" : e5 += "return " + o5.values.length;
            var l5 = new Function("db, params, alasql", "var y;" + r5 + e5).bind(this);
          } else if (this.select) {
            this.select.modifier = "RECORDSET", this.queries && (this.select.queries = this.queries);
            var c5, h5 = this.select.compile(a5);
            if (s5.engineid && L.engines[s5.engineid].intoTable)
              return function(e6, t6) {
                e6 = h5(e6);
                return L.engines[s5.engineid].intoTable(s5.databaseid, u5, e6.data, null, t6);
              };
            r5 = "return alasql.utils.extend(r,{" + i5.defaultfns + "})", c5 = new Function("r,db,params,alasql", r5), l5 = function(e6, t6, s6) {
              var n6 = h5(t6).data;
              if (e6.tables[u5].insert)
                for (var r6 = 0, a6 = n6.length; r6 < a6; r6++) {
                  var i6 = Ds(n6[r6]);
                  c5(i6, e6, t6, s6), e6.tables[u5].insert(i6, o5.orreplace);
                }
              else
                e6.tables[u5].data = e6.tables[u5].data.concat(n6);
              return s6.options.nocount ? void 0 : n6.length;
            };
          } else {
            if (!this.default)
              throw new Error("Wrong INSERT parameters");
            r5 = "db.tables['" + u5 + "'].data.push({" + i5.defaultfns + "});return 1;", l5 = new Function("db,params,alasql", r5);
          }
          return s5.engineid && L.engines[s5.engineid].intoTable && L.options.autocommit ? function(e6, t6) {
            e6 = new Function("db,params", "var y;" + n5 + "return aa;")(s5, e6);
            return L.engines[s5.engineid].intoTable(s5.databaseid, u5, e6, null, t6);
          } : function(e6, t6) {
            var s6 = L.databases[a5], e6 = (L.options.autocommit && s6.engineid && L.engines[s6.engineid].loadTableData(a5, u5), l5(s6, e6, L));
            return L.options.autocommit && s6.engineid && L.engines[s6.engineid].saveTableData(a5, u5), L.options.nocount && (e6 = void 0), t6 && t6(e6), e6;
          };
        }, M.Insert.prototype.execute = function(e5, t5, s5) {
          return this.compile(e5)(t5, s5);
        }, M.CreateTrigger = function(e5) {
          return Object.assign(this, e5);
        }, M.CreateTrigger.prototype.toString = function() {
          var e5 = "CREATE TRIGGER " + this.trigger + " ";
          return this.when && (e5 += this.when + " "), e5 += this.action + " ON ", this.table.databaseid && (e5 += this.table.databaseid + "."), e5 = (e5 += this.table.tableid + " ") + this.statement.toString();
        }, M.CreateTrigger.prototype.execute = function(e5, t5, s5) {
          var n5 = 1, r5 = this.trigger, e5 = (e5 = this.table.databaseid || e5, L.databases[e5]), a5 = this.table.tableid, i5 = { action: this.action, when: this.when, statement: this.statement, funcid: this.funcid, tableid: this.table.tableid };
          return "INSERT" == (e5.triggers[r5] = i5).action && "BEFORE" == i5.when ? e5.tables[a5].beforeinsert[r5] = i5 : "INSERT" == i5.action && "AFTER" == i5.when ? e5.tables[a5].afterinsert[r5] = i5 : "INSERT" == i5.action && "INSTEADOF" == i5.when ? e5.tables[a5].insteadofinsert[r5] = i5 : "DELETE" == i5.action && "BEFORE" == i5.when ? e5.tables[a5].beforedelete[r5] = i5 : "DELETE" == i5.action && "AFTER" == i5.when ? e5.tables[a5].afterdelete[r5] = i5 : "DELETE" == i5.action && "INSTEADOF" == i5.when ? e5.tables[a5].insteadofdelete[r5] = i5 : "UPDATE" == i5.action && "BEFORE" == i5.when ? e5.tables[a5].beforeupdate[r5] = i5 : "UPDATE" == i5.action && "AFTER" == i5.when ? e5.tables[a5].afterupdate[r5] = i5 : "UPDATE" == i5.action && "INSTEADOF" == i5.when && (e5.tables[a5].insteadofupdate[r5] = i5), n5 = s5 ? s5(n5) : n5;
        }, M.DropTrigger = function(e5) {
          return Object.assign(this, e5);
        }, M.DropTrigger.prototype.toString = function() {
          return "DROP TRIGGER " + this.trigger;
        }, M.DropTrigger.prototype.execute = function(e5, t5, s5) {
          var n5 = 0, e5 = L.databases[e5], r5 = this.trigger;
          if (!e5.triggers[r5])
            throw new Error("Trigger not found");
          var a5 = e5.triggers[r5].tableid;
          if (a5)
            return n5 = 1, delete e5.tables[a5].beforeinsert[r5], delete e5.tables[a5].afterinsert[r5], delete e5.tables[a5].insteadofinsert[r5], delete e5.tables[a5].beforedelete[r5], delete e5.tables[a5].afterdelete[r5], delete e5.tables[a5].insteadofdelete[r5], delete e5.tables[a5].beforeupdate[r5], delete e5.tables[a5].afterupdate[r5], delete e5.tables[a5].insteadofupdate[r5], delete e5.triggers[r5], n5 = s5 ? s5(n5) : n5;
          throw new Error("Trigger Table not found");
        }, M.Delete = function(e5) {
          return Object.assign(this, e5);
        }, M.Delete.prototype.toString = function() {
          var e5 = "DELETE FROM " + this.table.toString();
          return this.where && (e5 += " WHERE " + this.where.toString()), e5;
        }, M.Delete.prototype.compile = function(l5) {
          l5 = this.table.databaseid || l5;
          var c5, h5 = this.table.tableid, d5 = L.databases[l5];
          return this.where ? (this.exists && (this.existsfn = this.exists.map(function(e5) {
            e5 = e5.compile(l5);
            return e5.query.modifier = "RECORDSET", e5;
          })), this.queries && (this.queriesfn = this.queries.map(function(e5) {
            e5 = e5.compile(l5);
            return e5.query.modifier = "RECORDSET", e5;
          })), c5 = new Function("r,params,alasql", "var y;return (" + this.where.toJS("r", "") + ")").bind(this), function(e5, t5) {
            if (d5.engineid && L.engines[d5.engineid].deleteFromTable)
              return L.engines[d5.engineid].deleteFromTable(l5, h5, c5, e5, t5);
            L.options.autocommit && d5.engineid && ("LOCALSTORAGE" == d5.engineid || "FILESTORAGE" == d5.engineid) && L.engines[d5.engineid].loadTableData(l5, h5);
            for (var s5, n5 = d5.tables[h5], r5 = n5.data.length, a5 = [], i5 = 0, o5 = n5.data.length; i5 < o5; i5++)
              c5(n5.data[i5], e5, L) ? n5.delete && n5.delete(i5, e5, L) : a5.push(n5.data[i5]);
            for (s5 in n5.data = a5, n5.afterdelete) {
              var u5 = n5.afterdelete[s5];
              u5 && (u5.funcid ? L.fn[u5.funcid]() : u5.statement && u5.statement.execute(l5));
            }
            r5 -= n5.data.length;
            return L.options.autocommit && d5.engineid && ("LOCALSTORAGE" == d5.engineid || "FILESTORAGE" == d5.engineid) && L.engines[d5.engineid].saveTableData(l5, h5), t5 && t5(r5), r5;
          }) : function(e5, t5) {
            L.options.autocommit && d5.engineid && L.engines[d5.engineid].loadTableData(l5, h5);
            d5.tables[h5].dirty = true;
            var s5, n5 = d5.tables[h5].data.length;
            for (s5 in d5.tables[h5].data.length = 0, d5.tables[h5].uniqs)
              d5.tables[h5].uniqs[s5] = {};
            for (s5 in d5.tables[h5].indices)
              d5.tables[h5].indices[s5] = {};
            return L.options.autocommit && d5.engineid && L.engines[d5.engineid].saveTableData(l5, h5), t5 && t5(n5), n5;
          };
        }, M.Delete.prototype.execute = function(e5, t5, s5) {
          return this.compile(e5)(t5, s5);
        }, M.Update = function(e5) {
          return Object.assign(this, e5);
        }, M.Update.prototype.toString = function() {
          var e5 = "UPDATE " + this.table.toString();
          return this.columns && (e5 += " SET " + this.columns.toString()), this.where && (e5 += " WHERE " + this.where.toString()), e5;
        }, M.SetColumn = function(e5) {
          return Object.assign(this, e5);
        }, M.SetColumn.prototype.toString = function() {
          return this.column.toString() + "=" + this.expression.toString();
        }, M.Update.prototype.compile = function(o5) {
          o5 = this.table.databaseid || o5;
          var u5, l5 = this.table.tableid, t5 = (this.where && (this.exists && (this.existsfn = this.exists.map(function(e5) {
            e5 = e5.compile(o5);
            return e5.query.modifier = "RECORDSET", e5;
          })), this.queries && (this.queriesfn = this.queries.map(function(e5) {
            e5 = e5.compile(o5);
            return e5.query.modifier = "RECORDSET", e5;
          })), u5 = new Function("r,params,alasql", "var y;return " + this.where.toJS("r", "")).bind(this)), L.databases[o5].tables[l5].onupdatefns || ""), c5 = (t5 += ";", this.columns.forEach(function(e5) {
            t5 += "r['" + e5.column.columnid + "']=" + e5.expression.toJS("r", "") + ";";
          }), new Function("r,params,alasql", "var y;" + t5));
          return function(e5, t6) {
            var s5 = L.databases[o5];
            if (s5.engineid && L.engines[s5.engineid].updateTable)
              return L.engines[s5.engineid].updateTable(o5, l5, c5, u5, e5, t6);
            L.options.autocommit && s5.engineid && L.engines[s5.engineid].loadTableData(o5, l5);
            var n5 = s5.tables[l5];
            if (!n5)
              throw new Error("Table '" + l5 + "' not exists");
            for (var r5 = 0, a5 = 0, i5 = n5.data.length; a5 < i5; a5++)
              u5 && !u5(n5.data[a5], e5, L) || (n5.update ? n5.update(c5, a5, e5) : c5(n5.data[a5], e5, L), r5++);
            return L.options.autocommit && s5.engineid && L.engines[s5.engineid].saveTableData(o5, l5), t6 && t6(r5), r5;
          };
        }, M.Update.prototype.execute = function(e5, t5, s5) {
          return this.compile(e5)(t5, s5);
        }, M.Merge = function(e5) {
          return Object.assign(this, e5);
        }, M.Merge.prototype.toString = function() {
          var t5 = "MERGE ";
          return t5 += this.into.tableid + " ", this.into.as && (t5 += "AS " + this.into.as + " "), t5 += "USING " + this.using.tableid + " ", this.using.as && (t5 += "AS " + this.using.as + " "), t5 += "ON " + this.on.toString() + " ", this.matches.forEach(function(e5) {
            t5 += "WHEN ", e5.matched || (t5 += "NOT "), t5 += "MATCHED ", e5.bytarget && (t5 += "BY TARGET "), e5.bysource && (t5 += "BY SOURCE "), e5.expr && (t5 += "AND " + e5.expr.toString() + " "), t5 += "THEN ", e5.action.delete && (t5 += "DELETE "), e5.action.insert && (t5 += "INSERT ", e5.action.columns && (t5 += "(" + e5.action.columns.toString() + ") "), e5.action.values && (t5 += "VALUES (" + e5.action.values.toString() + ") "), e5.action.defaultvalues) && (t5 += "DEFAULT VALUES "), e5.action.update && (t5 = (t5 += "UPDATE ") + e5.action.update.map(function(e6) {
              return e6.toString();
            }).join(",") + " ");
          }), t5;
        }, M.Merge.prototype.execute = function(e5, t5, s5) {
          var n5 = 1;
          return n5 = s5 ? s5(n5) : n5;
        }, M.CreateDatabase = function(e5) {
          return Object.assign(this, e5);
        }, M.CreateDatabase.prototype.toString = function() {
          var e5 = "CREATE";
          return this.engineid && (e5 += " " + this.engineid), e5 += " DATABASE", this.ifnotexists && (e5 += " IF NOT EXISTS"), e5 += " " + this.databaseid, this.args && 0 < this.args.length && (e5 += "(" + this.args.map(function(e6) {
            return e6.toString();
          }).join(", ") + ")"), this.as && (e5 += " AS " + this.as), e5;
        }, M.CreateDatabase.prototype.execute = function(e5, t5, s5) {
          if (this.args && 0 < this.args.length && this.args.map(function(e6) {
            return new Function("params,alasql", "var y;return " + e6.toJS())(t5, L);
          }), this.engineid)
            return r5 = L.engines[this.engineid].createDatabase(this.databaseid, this.args, this.ifnotexists, this.as, s5);
          var n5 = this.databaseid;
          if (L.databases[n5])
            throw new Error("Database '" + n5 + "' already exists");
          new L.Database(n5);
          var r5 = 1;
          return s5 ? s5(r5) : r5;
        }, M.AttachDatabase = function(e5) {
          return Object.assign(this, e5);
        }, M.AttachDatabase.prototype.toString = function(e5) {
          var t5 = "ATTACH";
          return this.engineid && (t5 += " " + this.engineid), t5 += " DATABASE " + this.databaseid, e5 && (t5 += "(", 0 < e5.length && (t5 += e5.map(function(e6) {
            return e6.toString();
          }).join(", ")), t5 += ")"), this.as && (t5 += " AS " + this.as), t5;
        }, M.AttachDatabase.prototype.execute = function(e5, t5, s5) {
          if (L.engines[this.engineid])
            return L.engines[this.engineid].attachDatabase(this.databaseid, this.as, this.args, t5, s5);
          throw new Error('Engine "' + this.engineid + '" is not defined.');
        }, M.DetachDatabase = function(e5) {
          return Object.assign(this, e5);
        }, M.DetachDatabase.prototype.toString = function() {
          var e5 = "DETACH";
          return e5 += " DATABASE " + this.databaseid;
        }, M.DetachDatabase.prototype.execute = function(e5, t5, s5) {
          if (!L.databases[this.databaseid].engineid)
            throw new Error('Cannot detach database "' + this.engineid + '", because it was not attached.');
          var n5 = this.databaseid;
          if (n5 === L.DEFAULTDATABASEID)
            throw new Error("Drop of default database is prohibited");
          if (L.databases[n5]) {
            var r5 = L.databases[n5].engineid && "FILESTORAGE" == L.databases[n5].engineid, a5 = L.databases[n5].filename || "";
            delete L.databases[n5], r5 && (L.databases[n5] = {}, L.databases[n5].isDetached = true, L.databases[n5].filename = a5), n5 === L.useid && L.use(), r5 = 1;
          } else {
            if (!this.ifexists)
              throw new Error("Database '" + n5 + "' does not exist");
            r5 = 0;
          }
          return s5 && s5(r5), r5;
        }, M.UseDatabase = function(e5) {
          return Object.assign(this, e5);
        }, M.UseDatabase.prototype.toString = function() {
          return "USE DATABASE " + this.databaseid;
        }, M.UseDatabase.prototype.execute = function(e5, t5, s5) {
          var n5 = this.databaseid;
          if (!L.databases[n5])
            throw new Error("Database '" + n5 + "' does not exist");
          L.use(n5);
          return s5 && s5(1), 1;
        }, M.DropDatabase = function(e5) {
          return Object.assign(this, e5);
        }, M.DropDatabase.prototype.toString = function() {
          var e5 = "DROP";
          return this.ifexists && (e5 += " IF EXISTS"), e5 += " DATABASE " + this.databaseid;
        }, M.DropDatabase.prototype.execute = function(e5, t5, s5) {
          if (this.engineid)
            return L.engines[this.engineid].dropDatabase(this.databaseid, this.ifexists, s5);
          var n5, r5 = this.databaseid;
          if (r5 === L.DEFAULTDATABASEID)
            throw new Error("Drop of default database is prohibited");
          if (L.databases[r5]) {
            if (L.databases[r5].engineid)
              throw new Error("Cannot drop database '" + r5 + "', because it is attached. Detach it.");
            delete L.databases[r5], r5 === L.useid && L.use(), n5 = 1;
          } else {
            if (!this.ifexists)
              throw new Error("Database '" + r5 + "' does not exist");
            n5 = 0;
          }
          return s5 && s5(n5), n5;
        }, M.Declare = function(e5) {
          return Object.assign(this, e5);
        }, M.Declare.prototype.toString = function() {
          var e5 = "DECLARE ";
          return e5 = this.declares && 0 < this.declares.length ? this.declares.map(function(e6) {
            var t5 = "", t5 = (t5 += "@" + e6.variable + " ") + e6.dbtypeid;
            return this.dbsize && (t5 += "(" + this.dbsize, this.dbprecision && (t5 += "," + this.dbprecision), t5 += ")"), e6.expression && (t5 += " = " + e6.expression.toString()), t5;
          }).join(",") : e5;
        }, M.Declare.prototype.execute = function(e5, s5, t5) {
          var n5 = 1;
          return this.declares && 0 < this.declares.length && this.declares.map(function(e6) {
            var t6 = e6.dbtypeid;
            L.fn[t6] || (t6 = t6.toUpperCase()), L.declares[e6.variable] = { dbtypeid: t6, dbsize: e6.dbsize, dbprecision: e6.dbprecision }, e6.expression && (L.vars[e6.variable] = new Function("params,alasql", "return " + e6.expression.toJS("({})", "", null))(s5, L), L.declares[e6.variable]) && (L.vars[e6.variable] = L.stdfn.CONVERT(L.vars[e6.variable], L.declares[e6.variable]));
          }), n5 = t5 ? t5(n5) : n5;
        }, M.ShowDatabases = function(e5) {
          return Object.assign(this, e5);
        }, M.ShowDatabases.prototype.toString = function() {
          var e5 = "SHOW DATABASES";
          return this.like && (e5 += "LIKE " + this.like.toString()), e5;
        }, M.ShowDatabases.prototype.execute = function(e5, t5, s5) {
          if (this.engineid)
            return L.engines[this.engineid].showDatabases(this.like, s5);
          var n5, r5 = this, a5 = [];
          for (n5 in L.databases)
            a5.push({ databaseid: n5 });
          return r5.like && a5 && 0 < a5.length && (a5 = a5.filter(function(e6) {
            return L.utils.like(r5.like.value, e6.databaseid);
          })), s5 && s5(a5), a5;
        }, M.ShowTables = function(e5) {
          return Object.assign(this, e5);
        }, M.ShowTables.prototype.toString = function() {
          var e5 = "SHOW TABLES";
          return this.databaseid && (e5 += " FROM " + this.databaseid), this.like && (e5 += " LIKE " + this.like.toString()), e5;
        }, M.ShowTables.prototype.execute = function(e5, t5, s5) {
          var n5, e5 = L.databases[this.databaseid || e5], r5 = this, a5 = [];
          for (n5 in e5.tables)
            a5.push({ tableid: n5 });
          return r5.like && a5 && 0 < a5.length && (a5 = a5.filter(function(e6) {
            return L.utils.like(r5.like.value, e6.tableid);
          })), s5 && s5(a5), a5;
        }, M.ShowColumns = function(e5) {
          return Object.assign(this, e5);
        }, M.ShowColumns.prototype.toString = function() {
          var e5 = "SHOW COLUMNS";
          return this.table.tableid && (e5 += " FROM " + this.table.tableid), this.databaseid && (e5 += " FROM " + this.databaseid), e5;
        }, M.ShowColumns.prototype.execute = function(e5, t5, s5) {
          var e5 = L.databases[this.databaseid || e5].tables[this.table.tableid];
          return e5 && e5.columns ? (e5 = e5.columns.map(function(e6) {
            return { columnid: e6.columnid, dbtypeid: e6.dbtypeid, dbsize: e6.dbsize };
          }), s5 && s5(e5), e5) : (s5 && s5([]), []);
        }, M.ShowIndex = function(e5) {
          return Object.assign(this, e5);
        }, M.ShowIndex.prototype.toString = function() {
          var e5 = "SHOW INDEX";
          return this.table.tableid && (e5 += " FROM " + this.table.tableid), this.databaseid && (e5 += " FROM " + this.databaseid), e5;
        }, M.ShowIndex.prototype.execute = function(e5, t5, s5) {
          var n5 = L.databases[this.databaseid || e5].tables[this.table.tableid], r5 = [];
          if (n5 && n5.indices)
            for (var a5 in n5.indices)
              r5.push({ hh: a5, len: Object.keys(n5.indices[a5]).length });
          return s5 && s5(r5), r5;
        }, M.ShowCreateTable = function(e5) {
          return Object.assign(this, e5);
        }, M.ShowCreateTable.prototype.toString = function() {
          var e5 = "SHOW CREATE TABLE " + this.table.tableid;
          return this.databaseid && (e5 += " FROM " + this.databaseid), e5;
        }, M.ShowCreateTable.prototype.execute = function(e5) {
          var t5, s5, e5 = L.databases[this.databaseid || e5].tables[this.table.tableid];
          if (e5)
            return t5 = "CREATE TABLE " + this.table.tableid + " (", s5 = [], e5.columns && (e5.columns.forEach(function(e6) {
              var t6 = e6.columnid + " " + e6.dbtypeid;
              e6.dbsize && (t6 += "(" + e6.dbsize + ")"), e6.primarykey && (t6 += " PRIMARY KEY"), s5.push(t6);
            }), t5 += s5.join(", ")), t5 + ")";
          throw new Error('There is no such table "' + this.table.tableid + '"');
        }, M.SetVariable = function(e5) {
          return Object.assign(this, e5);
        }, M.SetVariable.prototype.toString = function() {
          var e5 = "SET ";
          return void 0 !== this.value && (e5 += this.variable.toUpperCase() + " " + (this.value ? "ON" : "OFF")), this.expression && (e5 += this.method + this.variable + " = " + this.expression.toString()), e5;
        }, M.SetVariable.prototype.execute = function(t5, e5, s5) {
          void 0 !== this.value ? ("ON" == (n5 = this.value) ? n5 = true : "OFF" == n5 && (n5 = false), L.options[this.variable] = n5) : this.expression && (this.exists && (this.existsfn = this.exists.map(function(e6) {
            e6 = e6.compile(t5);
            return e6.query && !e6.query.modifier && (e6.query.modifier = "RECORDSET"), e6;
          })), this.queries && (this.queriesfn = this.queries.map(function(e6) {
            e6 = e6.compile(t5);
            return e6.query && !e6.query.modifier && (e6.query.modifier = "RECORDSET"), e6;
          })), r5 = new Function("params,alasql", "return " + this.expression.toJS("({})", "", null)).bind(this)(e5, L), L.declares[this.variable] && (r5 = L.stdfn.CONVERT(r5, L.declares[this.variable])), this.props && 0 < this.props.length ? (n5 = "@" == this.method ? "alasql.vars['" + this.variable + "']" : "params['" + this.variable + "']", n5 += this.props.map(function(e6) {
            return "string" == typeof e6 ? "['" + e6 + "']" : "number" == typeof e6 ? "[" + e6 + "]" : "[" + e6.toJS() + "]";
          }).join(), new Function("value,params,alasql", "var y;" + n5 + "=value")(r5, e5, L)) : "@" == this.method ? L.vars[this.variable] = r5 : e5[this.variable] = r5);
          var n5, r5 = 1;
          return r5 = s5 ? s5(r5) : r5;
        }, L.test = function(e5, t5, s5) {
          if (0 === arguments.length)
            L.log(L.con.results);
          else {
            var n5 = Date.now();
            if (1 === arguments.length)
              s5(), L.con.log(Date.now() - n5);
            else {
              2 === arguments.length && (s5 = t5, t5 = 1);
              for (var r5 = 0; r5 < t5; r5++)
                s5();
              L.con.results[e5] = Date.now() - n5;
            }
          }
        }, L.log = function(e5, t5) {
          var s5, n5 = L.useid, r5 = L.options.logtarget;
          if (bs.isNode && (r5 = "console"), s5 = "string" == typeof e5 ? L(e5, t5) : e5, "console" === r5 || bs.isNode)
            "string" == typeof e5 && L.options.logprompt && console.log(n5 + ">", e5), Array.isArray(s5) && console.table ? console.table(s5) : console.log(ln(s5));
          else {
            var t5 = "output" === r5 ? document.getElementsByTagName("output")[0] : "string" == typeof r5 ? document.getElementById(r5) : r5, a5 = "";
            if ("string" == typeof e5 && L.options.logprompt && (a5 += "<pre><code>" + L.pretty(e5) + "</code></pre>"), Array.isArray(s5))
              if (0 === s5.length)
                a5 += "<p>[ ]</p>";
              else if ("object" != typeof s5[0] || Array.isArray(s5[0]))
                for (var i5 = 0, o5 = s5.length; i5 < o5; i5++)
                  a5 += "<p>" + pn(s5[i5]) + "</p>";
              else
                a5 += pn(s5);
            else
              a5 += pn(s5);
            t5.innerHTML += a5;
          }
        }, L.clear = function() {
          var e5 = L.options.logtarget;
          bs.isNode || bs.isMeteorServer ? console.clear && console.clear() : ("output" === e5 ? document.getElementsByTagName("output")[0] : "string" == typeof e5 ? document.getElementById(e5) : e5).innerHTML = "";
        }, L.write = function(e5) {
          var t5 = L.options.logtarget;
          bs.isNode || bs.isMeteorServer ? console.log && console.log(e5) : ("output" === t5 ? document.getElementsByTagName("output")[0] : "string" == typeof t5 ? document.getElementById(t5) : t5).innerHTML += e5;
        }, L.prompt = function(r5, a5, t5) {
          if (bs.isNode)
            throw new Error("The prompt not realized for Node.js");
          var i5 = 0;
          if ("string" == typeof r5 && (r5 = document.getElementById(r5)), (a5 = "string" == typeof a5 ? document.getElementById(a5) : a5).textContent = L.useid, t5) {
            L.prompthistory.push(t5), i5 = L.prompthistory.length;
            try {
              var e5 = Date.now();
              L.log(t5), L.write('<p style="color:blue">' + (Date.now() - e5) + " ms</p>");
            } catch (e6) {
              L.write("<p>" + L.useid + "&gt;&nbsp;<b>" + t5 + "</b></p>"), L.write('<p style="color:red">' + e6 + "<p>");
            }
          }
          e5 = r5.getBoundingClientRect().top + document.getElementsByTagName("body")[0].scrollTop;
          bn(document.getElementsByTagName("body")[0], e5, 500), r5.onkeydown = function(e6) {
            if (13 === e6.which) {
              var t6 = r5.value, s5 = L.useid;
              r5.value = "", L.prompthistory.push(t6), i5 = L.prompthistory.length;
              try {
                var n5 = Date.now();
                L.log(t6), L.write('<p style="color:blue">' + (Date.now() - n5) + " ms</p>");
              } catch (e7) {
                L.write("<p>" + s5 + "&gt;&nbsp;" + L.pretty(t6, false) + "</p>"), L.write('<p style="color:red">' + e7 + "<p>");
              }
              r5.focus(), a5.textContent = L.useid;
              n5 = r5.getBoundingClientRect().top + document.getElementsByTagName("body")[0].scrollTop;
              bn(document.getElementsByTagName("body")[0], n5, 500);
            } else
              38 === e6.which ? (--i5 < 0 && (i5 = 0), L.prompthistory[i5] && (r5.value = L.prompthistory[i5], e6.preventDefault())) : 40 === e6.which && (++i5 >= L.prompthistory.length ? (i5 = L.prompthistory.length, r5.value = "") : L.prompthistory[i5] && (r5.value = L.prompthistory[i5], e6.preventDefault()));
          };
        }, M.BeginTransaction = function(e5) {
          return Object.assign(this, e5);
        }, M.BeginTransaction.prototype.toString = function() {
          return "BEGIN TRANSACTION";
        }, M.BeginTransaction.prototype.execute = function(e5, t5, s5) {
          return L.databases[e5].engineid ? L.engines[L.databases[L.useid].engineid].begin(e5, s5) : (s5 && s5(1), 1);
        }, M.CommitTransaction = function(e5) {
          return Object.assign(this, e5);
        }, M.CommitTransaction.prototype.toString = function() {
          return "COMMIT TRANSACTION";
        }, M.CommitTransaction.prototype.execute = function(e5, t5, s5) {
          return L.databases[e5].engineid ? L.engines[L.databases[L.useid].engineid].commit(e5, s5) : (s5 && s5(1), 1);
        }, M.RollbackTransaction = function(e5) {
          return Object.assign(this, e5);
        }, M.RollbackTransaction.prototype.toString = function() {
          return "ROLLBACK TRANSACTION";
        }, M.RollbackTransaction.prototype.execute = function(e5, t5, s5) {
          return L.databases[e5].engineid ? L.engines[L.databases[e5].engineid].rollback(e5, s5) : (s5 && s5(1), 1);
        }, L.options.tsql && (L.stdfn.OBJECT_ID = function(e5, t5) {
          t5 = (t5 = void 0 === t5 ? "T" : t5).toUpperCase();
          var s5, e5 = e5.split("."), n5 = L.useid, r5 = e5[0], a5 = (2 == e5.length && (n5 = e5[0], r5 = e5[1]), L.databases[n5].tables), n5 = L.databases[n5].databaseid;
          for (s5 in a5)
            if (s5 == r5)
              return (!a5[s5].view || "V" != t5) && (a5[s5].view || "T" != t5) ? void 0 : n5 + "." + s5;
        }), L.options.mysql && (L.fn.TIMESTAMPDIFF = function(e5, t5, s5) {
          return L.stdfn.DATEDIFF(e5, t5, s5);
        }), (L.options.mysql || L.options.sqlite) && (L.from.INFORMATION_SCHEMA = function(e5, t5, s5, n5, r5) {
          if ("VIEWS" != e5 && "TABLES" != e5)
            throw new Error("Unknown INFORMATION_SCHEMA table");
          var a5, i5 = [];
          for (a5 in L.databases) {
            var o5, u5 = L.databases[a5].tables;
            for (o5 in u5)
              (u5[o5].view && "VIEWS" == e5 || !u5[o5].view && "TABLES" == e5) && i5.push({ TABLE_CATALOG: a5, TABLE_NAME: o5 });
          }
          return i5 = s5 ? s5(i5, n5, r5) : i5;
        }), L.options.postgres, L.options.oracle, L.options.sqlite, L.into.SQL = function(e5, t5, s5, n5, r5) {
          "object" == typeof e5 && (t5 = e5, e5 = void 0);
          var a5 = {};
          if (L.utils.extend(a5, t5), void 0 === a5.tableid)
            throw new Error("Table for INSERT TO is not defined.");
          var i5 = "";
          0 === n5.length && "object" == typeof s5[0] && (n5 = Object.keys(s5[0]).map(function(e6) {
            return { columnid: e6 };
          }));
          for (var o5 = 0, u5 = s5.length; o5 < u5; o5++)
            i5 = (i5 = (i5 += "INSERT INTO " + t5.tableid + "(") + n5.map(function(e6) {
              return e6.columnid;
            }).join(",") + ") VALUES (") + n5.map(function(e6) {
              var t6 = s5[o5][e6.columnid];
              return e6.typeid ? "STRING" !== e6.typeid && "VARCHAR" !== e6.typeid && "NVARCHAR" !== e6.typeid && "CHAR" !== e6.typeid && "NCHAR" !== e6.typeid || (t6 = "'" + As(t6) + "'") : "string" == typeof t6 && (t6 = "'" + As(t6) + "'"), t6;
            }) + ");\n";
          return e5 = L.utils.autoExtFilename(e5, "sql", t5), a5 = L.utils.saveFile(e5, i5), a5 = r5 ? r5(a5) : a5;
        }, L.into.HTML = function(e5, t5, s5, n5, r5) {
          var a5 = 1;
          if ("object" != typeof document) {
            var i5 = { headers: true }, t5 = (L.utils.extend(i5, t5), document.querySelector(e5));
            if (!t5)
              throw new Error("Selected HTML element is not found");
            0 === n5.length && "object" == typeof s5[0] && (n5 = Object.keys(s5[0]).map(function(e6) {
              return { columnid: e6 };
            }));
            var e5 = document.createElement("table"), o5 = document.createElement("thead");
            if (e5.appendChild(o5), i5.headers) {
              for (var u5 = document.createElement("tr"), l5 = 0; l5 < n5.length; l5++)
                (d5 = document.createElement("th")).textContent = n5[l5].columnid, u5.appendChild(d5);
              o5.appendChild(u5);
            }
            var c5 = document.createElement("tbody");
            e5.appendChild(c5);
            for (var h5 = 0; h5 < s5.length; h5++) {
              for (var d5, u5 = document.createElement("tr"), l5 = 0; l5 < n5.length; l5++)
                (d5 = document.createElement("td")).textContent = s5[h5][n5[l5].columnid], u5.appendChild(d5);
              c5.appendChild(u5);
            }
            L.utils.domEmptyChildren(t5), t5.appendChild(e5);
          }
          return a5 = r5 ? r5(a5) : a5;
        }, L.into.JSON = function(e5, t5, s5, n5, r5) {
          var a5 = 1, s5 = ("object" == typeof e5 && (t5 = e5, e5 = void 0), JSON.stringify(s5));
          return e5 = L.utils.autoExtFilename(e5, "json", t5), a5 = L.utils.saveFile(e5, s5), a5 = r5 ? r5(a5) : a5;
        }, L.into.TXT = function(e5, t5, s5, n5, r5) {
          0 === n5.length && 0 < s5.length && (n5 = Object.keys(s5[0]).map(function(e6) {
            return { columnid: e6 };
          })), "object" == typeof e5 && (t5 = e5, e5 = void 0);
          var a5, i5 = s5.length, o5 = "";
          return 0 < s5.length && (a5 = n5[0].columnid, o5 += s5.map(function(e6) {
            return e6[a5];
          }).join("\n")), e5 = L.utils.autoExtFilename(e5, "txt", t5), i5 = L.utils.saveFile(e5, o5), i5 = r5 ? r5(i5) : i5;
        }, L.into.TAB = L.into.TSV = function(e5, t5, s5, n5, r5) {
          var a5 = {};
          return L.utils.extend(a5, t5), a5.separator = "	", e5 = L.utils.autoExtFilename(e5, "tab", t5), a5.autoExt = false, L.into.CSV(e5, a5, s5, n5, r5);
        }, L.into.CSV = function(e5, t5, s5, n5, r5) {
          0 === n5.length && 0 < s5.length && (n5 = Object.keys(s5[0]).map(function(e6) {
            return { columnid: e6 };
          })), "object" == typeof e5 && (t5 = e5, e5 = void 0);
          var a5 = { headers: true, separator: ";", quote: '"', utf8Bom: true }, i5 = (t5 && !t5.headers && void 0 !== t5.headers && (a5.utf8Bom = false), L.utils.extend(a5, t5), s5.length), o5 = a5.utf8Bom ? "\uFEFF" : "";
          return a5.headers && (o5 += a5.quote + n5.map(function(e6) {
            return e6.columnid.trim();
          }).join(a5.quote + a5.separator + a5.quote) + a5.quote + "\r\n"), s5.forEach(function(t6) {
            o5 += n5.map(function(e6) {
              e6 = t6[e6.columnid];
              return e6 = +(e6 = "" !== a5.quote ? (e6 + "").replace(new RegExp("\\" + a5.quote, "g"), a5.quote + a5.quote) : e6) != e6 ? a5.quote + e6 + a5.quote : e6;
            }).join(a5.separator) + "\r\n";
          }), e5 = L.utils.autoExtFilename(e5, "csv", t5), i5 = L.utils.saveFile(e5, o5, null, { disableAutoBom: true }), i5 = r5 ? r5(i5) : i5;
        }, L.into.XLS = function(e5, c5, t5, s5, n5) {
          "object" == typeof e5 && (c5 = e5, e5 = void 0);
          var r5 = {}, h5 = (c5 && c5.sheets && (r5 = c5.sheets), { headers: true }), r5 = (void 0 !== r5.Sheet1 ? h5 = r5[0] : void 0 !== c5 && (h5 = c5), void 0 === h5.sheetid && (h5.sheetid = "Sheet1"), function() {
            var l5 = '<html xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:x="urn:schemas-microsoft-com:office:excel" 		xmlns="http://www.w3.org/TR/REC-html40"><head> 		<meta charset="utf-8" /> 		<!--[if gte mso 9]><xml><x:ExcelWorkbook><x:ExcelWorksheets> ';
            l5 = (l5 += " <x:ExcelWorksheet><x:Name>" + h5.sheetid + "</x:Name><x:WorksheetOptions><x:DisplayGridlines/>     </x:WorksheetOptions> 		</x:ExcelWorksheet>") + "</x:ExcelWorksheets></x:ExcelWorkbook></xml><![endif]--></head><body", void 0 !== h5.style && (l5 += ' style="', "function" == typeof h5.style ? l5 += h5.style(h5) : l5 += h5.style, l5 += '"');
            {
              var e6;
              l5 += "><table>", void 0 !== h5.caption && (e6 = h5.caption, l5 += "<caption", void 0 !== (e6 = "string" == typeof e6 ? { title: e6 } : e6).style && (l5 += ' style="', "function" == typeof e6.style ? l5 += e6.style(h5, e6) : l5 += e6.style, l5 += '" '), l5 = (l5 += ">") + e6.title + "</caption>");
            }
            void 0 !== h5.columns ? s5 = h5.columns : 0 == s5.length && 0 < t5.length && "object" == typeof t5[0] && (s5 = Array.isArray(t5[0]) ? t5[0].map(function(e7, t6) {
              return { columnid: t6 };
            }) : Object.keys(t5[0]).map(function(e7) {
              return { columnid: e7 };
            }));
            s5.forEach(function(e7, t6) {
              void 0 !== h5.column && Fs(e7, h5.column), void 0 === e7.width && (h5.column && "undefined" != h5.column.width ? e7.width = h5.column.width : e7.width = "120px"), "number" == typeof e7.width && (e7.width = e7.width + "px"), void 0 === e7.columnid && (e7.columnid = t6), void 0 === e7.title && (e7.title = "" + e7.columnid.trim()), h5.headers && Array.isArray(h5.headers) && (e7.title = h5.headers[t6]);
            }), l5 += "<colgroups>", s5.forEach(function(e7) {
              l5 += '<col style="width: ' + e7.width + '"></col>';
            }), l5 += "</colgroups>", h5.headers && (l5 += "<thead><tr>", s5.forEach(function(e7, t6) {
              l5 += "<th ", void 0 !== e7.style && (l5 += ' style="', "function" == typeof e7.style ? l5 += e7.style(h5, e7, t6) : l5 += e7.style, l5 += '" '), l5 += ">", void 0 !== e7.title && ("function" == typeof e7.title ? l5 += e7.title(h5, e7, t6) : l5 += e7.title), l5 += "</th>";
            }), l5 += "</tr></thead>");
            l5 += "<tbody>", t5 && 0 < t5.length && t5.forEach(function(i5, o5) {
              var u5;
              o5 > h5.limit || (l5 += "<tr", Fs(u5 = {}, h5.row), h5.rows && h5.rows[o5] && Fs(u5, h5.rows[o5]), void 0 !== u5 && void 0 !== u5.style && (l5 += ' style="', "function" == typeof u5.style ? l5 += u5.style(h5, i5, o5) : l5 += u5.style, l5 += '" '), l5 += ">", s5.forEach(function(e7, t6) {
                var s6 = {}, n6 = (Fs(s6, h5.cell), Fs(s6, u5.cell), void 0 !== h5.column && Fs(s6, h5.column.cell), Fs(s6, e7.cell), h5.cells && h5.cells[o5] && h5.cells[o5][t6] && Fs(s6, h5.cells[o5][t6]), i5[e7.columnid]), r6 = ("function" == typeof s6.value && (n6 = s6.value(n6, h5, i5, e7, s6, o5, t6)), s6.typeid), a5 = (void 0 === (r6 = "function" == typeof r6 ? r6(n6, h5, i5, e7, s6, o5, t6) : r6) && ("number" == typeof n6 ? r6 = "number" : "string" == typeof n6 ? r6 = "string" : "boolean" == typeof n6 ? r6 = "boolean" : "object" == typeof n6 && n6 instanceof Date && (r6 = "date")), ""), a5 = ("money" == r6 ? a5 = 'mso-number-format:"\\#\\,\\#\\#0\\\\ _\u0440_\\.";white-space:normal;' : "number" == r6 ? a5 = " " : "date" == r6 ? a5 = 'mso-number-format:"Short Date";' : c5.types && c5.types[r6] && c5.types[r6].typestyle && (a5 = c5.types[r6].typestyle), l5 += "<td style='" + (a5 = a5 || 'mso-number-format:"\\@";') + "' ", void 0 !== s6.style && (l5 += ' style="', "function" == typeof s6.style ? l5 += s6.style(n6, h5, i5, e7, o5, t6) : l5 += s6.style, l5 += '" '), l5 += ">", s6.format);
                if (void 0 === n6)
                  l5 += "";
                else if (void 0 !== a5)
                  if ("function" == typeof a5)
                    l5 += a5(n6);
                  else {
                    if ("string" != typeof a5)
                      throw new Error("Unknown format type. Should be function or string");
                    l5 += n6;
                  }
                else
                  l5 += "number" == r6 || "date" == r6 ? n6.toString() : "money" == r6 ? (+n6).toFixed(2) : n6;
                l5 += "</td>";
              }), l5 += "</tr>");
            });
            return l5 = (l5 += "</tbody></table>") + "</body></html>";
          }()), e5 = (e5 = L.utils.autoExtFilename(e5, "xls", c5), L.utils.saveFile(e5, r5));
          return e5 = n5 ? n5(e5) : e5;
        }, L.into.XLSXML = function(e5, f5, t5, s5, n5) {
          f5 = f5 || {}, "object" == typeof e5 && (f5 = e5, e5 = void 0);
          var u5, l5 = {}, p5 = f5 && f5.sheets ? (l5 = f5.sheets, u5 = t5, s5) : (l5.Sheet1 = f5, u5 = [t5], [s5]), t5 = (e5 = L.utils.autoExtFilename(e5, "xls", f5), L.utils.saveFile(e5, function() {
            var a5 = "", c5 = " </Styles>", i5 = {}, o5 = 62;
            function h5(e7) {
              var t7, s7 = "";
              for (t7 in e7) {
                for (var n7 in s7 += "<" + t7, e7[t7])
                  s7 += " ", "x:" == n7.substr(0, 2) ? s7 += n7 : s7 += "ss:", s7 += n7 + '="' + e7[t7][n7] + '"';
                s7 += "/>";
              }
              var r6 = Rs(s7);
              return i5[r6] || (i5[r6] = { styleid: o5 }, a5 = (a5 += '<Style ss:ID="s' + o5 + '">') + s7 + "</Style>", o5++), "s" + i5[r6].styleid;
            }
            var e6, t6 = 0;
            for (e6 in l5) {
              var d5 = l5[e6], s6 = void 0 !== d5.dataidx ? d5.dataidx : t6++, n6 = function(t7) {
                try {
                  return Object.values(t7);
                } catch (e7) {
                  return Object.keys(t7).map(function(e8) {
                    return t7[e8];
                  });
                }
              }(u5[s6]), r5 = void 0;
              void 0 !== d5.columns ? r5 = d5.columns : (void 0 === (r5 = p5[s6]) || 0 == r5.length && 0 < n6.length) && "object" == typeof n6[0] && (r5 = Array.isArray(n6[0]) ? n6[0].map(function(e7, t7) {
                return { columnid: t7 };
              }) : Object.keys(n6[0]).map(function(e7) {
                return { columnid: e7 };
              })), r5.forEach(function(e7, t7) {
                void 0 !== d5.column && Fs(e7, d5.column), void 0 === e7.width && (d5.column && void 0 !== d5.column.width ? e7.width = d5.column.width : e7.width = 120), "number" == typeof e7.width && (e7.width = e7.width), void 0 === e7.columnid && (e7.columnid = t7), void 0 === e7.title && (e7.title = "" + e7.columnid.trim()), d5.headers && Array.isArray(d5.headers) && (e7.title = d5.headers[t7]);
              }), c5 += '<Worksheet ss:Name="' + e6 + '"> 	  			<Table ss:ExpandedColumnCount="' + r5.length + '" ss:ExpandedRowCount="' + ((d5.headers ? 1 : 0) + Math.min(n6.length, d5.limit || n6.length)) + '" x:FullColumns="1" 	   			x:FullRows="1" ss:DefaultColumnWidth="65" ss:DefaultRowHeight="15">', r5.forEach(function(e7, t7) {
                c5 += '<Column ss:Index="' + (t7 + 1) + '" ss:AutoFitWidth="0" ss:Width="' + e7.width + '"/>';
              }), d5.headers && (c5 += '<Row ss:AutoFitHeight="0">', r5.forEach(function(e7, t7) {
                var s7;
                c5 += "<Cell ", void 0 !== e7.style && (s7 = {}, "function" == typeof e7.style ? Fs(s7, e7.style(d5, e7, t7)) : Fs(s7, e7.style), c5 += 'ss:StyleID="' + h5(s7) + '"'), c5 += '><Data ss:Type="String">', void 0 !== e7.title && ("function" == typeof e7.title ? c5 += e7.title(d5, e7, t7) : c5 += e7.title), c5 += "</Data></Cell>";
              }), c5 += "</Row>"), n6 && 0 < n6.length && n6.forEach(function(o6, u6) {
                var l6, e7;
                u6 > d5.limit || (Fs(l6 = {}, d5.row), d5.rows && d5.rows[u6] && Fs(l6, d5.rows[u6]), c5 += "<Row ", void 0 !== l6 && (e7 = {}, void 0 !== l6.style) && ("function" == typeof l6.style ? Fs(e7, l6.style(d5, o6, u6)) : Fs(e7, l6.style), c5 += 'ss:StyleID="' + h5(e7) + '"'), c5 += ">", r5.forEach(function(e8, t7) {
                  var s7 = {}, n7 = (Fs(s7, d5.cell), Fs(s7, l6.cell), void 0 !== d5.column && Fs(s7, d5.column.cell), Fs(s7, e8.cell), d5.cells && d5.cells[u6] && d5.cells[u6][t7] && Fs(s7, d5.cells[u6][t7]), o6[e8.columnid]), r6 = ("function" == typeof s7.value && (n7 = s7.value(n7, d5, o6, e8, s7, u6, t7)), s7.typeid), a6 = (void 0 === (r6 = "function" == typeof r6 ? r6(n7, d5, o6, e8, s7, u6, t7) : r6) && ("number" == typeof n7 ? r6 = "number" : "string" == typeof n7 ? r6 = "string" : "boolean" == typeof n7 ? r6 = "boolean" : "object" == typeof n7 && n7 instanceof Date && (r6 = "date")), "String"), i6 = ("number" == r6 ? a6 = "Number" : "date" == r6 && (a6 = "Date"), "money" == r6 ? 0 : "number" == r6 ? 0 : "date" == r6 ? 0 : f5.types && f5.types[r6] && f5.types[r6].typestyle && f5.types[r6].typestyle, c5 += "<Cell ", {}), e8 = (void 0 !== s7.style && ("function" == typeof s7.style ? Fs(i6, s7.style(n7, d5, o6, e8, u6, t7)) : Fs(i6, s7.style), c5 += 'ss:StyleID="' + h5(i6) + '"'), c5 = c5 + ">" + ('<Data ss:Type="' + a6 + '">'), s7.format);
                  if (void 0 === n7)
                    c5 += "";
                  else if (void 0 !== e8)
                    if ("function" == typeof e8)
                      c5 += e8(n7);
                    else {
                      if ("string" != typeof e8)
                        throw new Error("Unknown format type. Should be function or string");
                      c5 += n7;
                    }
                  else
                    c5 += "number" == r6 || "date" == r6 ? n7.toString() : "money" == r6 ? (+n7).toFixed(2) : n7;
                  c5 += "</Data></Cell>";
                }), c5 += "</Row>");
              }), c5 += "</Table></Worksheet>";
            }
            return '<?xml version="1.0"?> 		<Workbook xmlns="urn:schemas-microsoft-com:office:spreadsheet" 		 xmlns:o="urn:schemas-microsoft-com:office:office" 		 xmlns:x="urn:schemas-microsoft-com:office:excel" 		 xmlns:ss="urn:schemas-microsoft-com:office:spreadsheet" 		 xmlns:html="http://www.w3.org/TR/REC-html40"> 		 <DocumentProperties xmlns="urn:schemas-microsoft-com:office:office"> 		 </DocumentProperties> 		 <OfficeDocumentSettings xmlns="urn:schemas-microsoft-com:office:office"> 		  <AllowPNG/> 		 </OfficeDocumentSettings> 		 <ExcelWorkbook xmlns="urn:schemas-microsoft-com:office:excel"> 		  <ActiveSheet>0</ActiveSheet> 		 </ExcelWorkbook> 		 <Styles> 		  <Style ss:ID="Default" ss:Name="Normal"> 		   <Alignment ss:Vertical="Bottom"/> 		   <Borders/> 		   <Font ss:FontName="Calibri" x:Family="Swiss" ss:Size="12" ss:Color="#000000"/> 		   <Interior/> 		   <NumberFormat/> 		   <Protection/> 		  </Style>' + a5 + (c5 += "</Workbook>");
          }()));
          return t5 = n5 ? n5(t5) : t5;
        }, L.into.XLSX = function(t5, s5, n5, r5, e5) {
          var a5 = 1, i5 = (s5 = s5 || {}, Ms(r5, [{ columnid: "_" }]) && (n5 = n5.map(function(e6) {
            return e6._;
          }), r5 = void 0), t5 = L.utils.autoExtFilename(t5, "xlsx", s5), Cs()), d5 = ("object" == typeof t5 && (s5 = t5, t5 = void 0), { SheetNames: [], Sheets: {} });
          return s5.sourcefilename ? L.utils.loadBinaryFile(s5.sourcefilename, !!e5, function(e6) {
            d5 = i5.read(e6, { type: "binary", ...L.options.excel, ...s5 }), o5();
          }) : o5(), a5 = e5 ? e5(a5) : a5;
          function o5() {
            var e6;
            "object" == typeof s5 && Array.isArray(s5) ? n5 && 0 < n5.length && n5.forEach(function(e7, t6) {
              u5(s5[t6], e7, void 0, t6 + 1);
            }) : u5(s5, n5, r5, 1), void 0 === t5 ? a5 = d5 : (e6 = Cs(), bs.isNode || bs.isMeteorServer ? e6.writeFile(d5, t5) : (e6 = e6.write(d5, { bookType: "xlsx", bookSST: false, type: "binary" }), yn(new Blob([function(e7) {
              for (var t6 = new ArrayBuffer(e7.length), s6 = new Uint8Array(t6), n6 = 0; n6 != e7.length; ++n6)
                s6[n6] = 255 & e7.charCodeAt(n6);
              return t6;
            }(e6)], { type: "application/octet-stream" }), t5)));
          }
          function u5(e6, n6, t6, s6) {
            var r6, s6 = { sheetid: "Sheet " + s6, headers: true }, a6 = (L.utils.extend(s6, e6), Object.keys(n6).length), i6 = ((!t6 || 0 == t6.length) && 0 < a6 && (t6 = Object.keys(n6[0]).map(function(e7) {
              return { columnid: e7 };
            })), {}), i6 = (-1 < d5.SheetNames.indexOf(s6.sheetid) || (d5.SheetNames.push(s6.sheetid), d5.Sheets[s6.sheetid] = {}), d5.Sheets[s6.sheetid]), e6 = "A1", o6 = L.utils.xlscn((e6 = s6.range ? s6.range : e6).match(/[A-Z]+/)[0]), e6 = +e6.match(/[0-9]+/)[0] - 1, u6 = (r6 = d5.Sheets[s6.sheetid]["!ref"] ? (r6 = d5.Sheets[s6.sheetid]["!ref"], l5 = L.utils.xlscn(r6.match(/[A-Z]+/)[0]), +r6.match(/[0-9]+/)[0] - 1) : l5 = 1, t6.length ? 0 : 1), u6 = Math.max(o6 + t6.length - 1 + u6, l5), l5 = Math.max(e6 + a6 + 2, r6), c5 = 1 + e6;
            d5.Sheets[s6.sheetid]["!ref"] = "A1:" + L.utils.xlsnc(u6) + l5, s6.headers && (t6.forEach(function(e7, t7) {
              i6[L.utils.xlsnc(o6 + t7) + "" + c5] = { v: e7.columnid.trim() };
            }), c5++);
            for (var h5 = 0; h5 < a6; h5++)
              t6.forEach(function(e7, t7) {
                var s7 = { v: n6[h5][e7.columnid] };
                "number" == typeof n6[h5][e7.columnid] ? s7.t = "n" : "string" == typeof n6[h5][e7.columnid] ? s7.t = "s" : "boolean" == typeof n6[h5][e7.columnid] ? s7.t = "b" : "object" == typeof n6[h5][e7.columnid] && n6[h5][e7.columnid] instanceof Date && (s7.t = "d"), i6[L.utils.xlsnc(o6 + t7) + "" + c5] = s7;
              }), c5++;
          }
        }, L.from.METEOR = function(e5, t5, s5, n5, r5) {
          e5 = e5.find(t5).fetch();
          return e5 = s5 ? s5(e5, n5, r5) : e5;
        }, L.from.TABLETOP = function(e5, t5, s5, n5, r5) {
          var a5 = [], e5 = { headers: true, simpleSheet: true, key: e5 };
          return L.utils.extend(e5, t5), e5.callback = function(e6) {
            a5 = e6, s5 && (a5 = s5(a5, n5, r5));
          }, Tabletop.init(e5), null;
        }, L.from.HTML = function(e5, t5, s5, n5, r5) {
          var a5 = {}, t5 = (L.utils.extend(a5, t5), document.querySelector(e5));
          if (!t5 && "TABLE" !== t5.tagName)
            throw new Error("Selected HTML element is not a TABLE");
          var i5 = [];
          if ((o5 = a5.headers) && !Array.isArray(o5))
            for (var o5 = [], u5 = t5.querySelector("thead tr").children, l5 = 0; l5 < u5.length; l5++)
              u5.item(l5).style && "none" === u5.item(l5).style.display && a5.skipdisplaynone ? o5.push(void 0) : o5.push(u5.item(l5).textContent);
          for (var c5 = t5.querySelectorAll("tbody tr"), h5 = 0; h5 < c5.length; h5++) {
            for (var d5 = c5.item(h5).children, f5 = {}, l5 = 0; l5 < d5.length; l5++)
              d5.item(l5).style && "none" === d5.item(l5).style.display && a5.skipdisplaynone || (o5 ? f5[o5[l5]] = d5.item(l5).textContent : f5[l5] = d5.item(l5).textContent);
            i5.push(f5);
          }
          return i5 = s5 ? s5(i5, n5, r5) : i5;
        }, L.from.RANGE = function(e5, t5, s5, n5, r5) {
          for (var a5 = [], i5 = e5; i5 <= t5; i5++)
            a5.push(i5);
          return a5 = s5 ? s5(a5, n5, r5) : a5;
        }, L.from.FILE = function(e5, t5, s5, n5, r5) {
          if ("string" == typeof e5)
            a5 = e5;
          else {
            if (!(e5 instanceof Event))
              throw new Error("Wrong usage of FILE() function");
            a5 = e5.target.files[0].name;
          }
          var a5 = a5.split("."), a5 = a5[a5.length - 1].toUpperCase();
          if (L.from[a5])
            return L.from[a5](e5, t5, s5, n5, r5);
          throw new Error("Cannot recognize file type for loading");
        }, L.from.JSON = function(e5, t5, s5, n5, r5) {
          var a5;
          return e5 = L.utils.autoExtFilename(e5, "json", t5), L.utils.loadFile(e5, !!s5, function(e6) {
            a5 = JSON.parse(e6), s5 && (a5 = s5(a5, n5, r5));
          }), a5;
        }, L.from.TXT = function(e5, t5, n5, r5, a5) {
          var i5;
          return e5 = L.utils.autoExtFilename(e5, "txt", t5), L.utils.loadFile(e5, !!n5, function(e6) {
            "" === (i5 = e6.split(/\r?\n/))[i5.length - 1] && i5.pop();
            for (var t6 = 0, s5 = i5.length; t6 < s5; t6++)
              i5[t6] == +i5[t6] && (i5[t6] = +i5[t6]), i5[t6] = [i5[t6]];
            n5 && (i5 = n5(i5, r5, a5));
          }), i5;
        }, L.from.TAB = L.from.TSV = function(e5, t5, s5, n5, r5) {
          return (t5 = t5 || {}).separator = "	", e5 = L.utils.autoExtFilename(e5, "tab", t5), t5.autoext = false, L.from.CSV(e5, t5, s5, n5, r5);
        }, L.from.CSV = function(e5, t5, b5, E5, g5) {
          e5 = "" + e5;
          var m5, T5 = { separator: ",", quote: '"', headers: true }, S5 = (L.utils.extend(T5, t5), []);
          function s5(r5) {
            var e6, a5, t6, i5 = T5.separator.charCodeAt(0), o5 = T5.quote.charCodeAt(0), u5 = {}, l5 = {}, s6 = [], c5 = r5.length, h5 = 0, n5 = 0;
            function d5() {
              if (c5 <= h5)
                return l5;
              if (a5)
                return a5 = false, u5;
              var e7 = h5;
              if (r5.charCodeAt(e7) === o5) {
                for (var t7 = e7; t7++ < c5; )
                  if (r5.charCodeAt(t7) === o5) {
                    if (r5.charCodeAt(t7 + 1) !== o5)
                      break;
                    ++t7;
                  }
                return h5 = t7 + 2, 13 === (s7 = r5.charCodeAt(t7 + 1)) ? (a5 = true, 10 === r5.charCodeAt(t7 + 2) && ++h5) : 10 === s7 && (a5 = true), r5.substring(e7 + 1, t7).replace(/""/g, '"');
              }
              for (; h5 < c5; ) {
                var s7, n6 = 1;
                if (10 === (s7 = r5.charCodeAt(h5++)))
                  a5 = true;
                else if (13 === s7)
                  a5 = true, 10 === r5.charCodeAt(h5) && (++h5, ++n6);
                else if (s7 !== i5)
                  continue;
                return r5.substring(e7, h5 - n6);
              }
              return r5.substring(e7);
            }
            for (; (e6 = d5()) !== l5; ) {
              for (var f5, p5 = []; e6 !== u5 && e6 !== l5; )
                p5.push(e6.trim()), e6 = d5();
              T5.headers ? (0 === n5 ? "boolean" == typeof T5.headers ? S5 = p5 : Array.isArray(T5.headers) && (S5 = T5.headers, f5 = {}, S5.forEach(function(e7, t7) {
                f5[e7] = p5[t7], void 0 !== f5[e7] && 0 !== f5[e7].length && f5[e7].trim() == +f5[e7] && (f5[e7] = +f5[e7]);
              }), s6.push(f5)) : (f5 = {}, S5.forEach(function(e7, t7) {
                f5[e7] = p5[t7], void 0 !== f5[e7] && 0 !== f5[e7].length && f5[e7].trim() == +f5[e7] && (f5[e7] = +f5[e7]);
              }), s6.push(f5)), n5++) : s6.push(p5);
            }
            m5 = s6, T5.headers && g5 && g5.sources && g5.sources[E5] && (t6 = g5.sources[E5].columns = [], S5.forEach(function(e7) {
              t6.push({ columnid: e7 });
            })), b5 && (m5 = b5(m5, E5, g5));
          }
          return new RegExp("\n").test(e5) ? s5(e5) : (e5 = L.utils.autoExtFilename(e5, "csv", t5), L.utils.loadFile(e5, !!b5, s5, g5.cb)), m5;
        }, L.from.XLS = function(e5, t5, s5, n5, r5) {
          return e5 = L.utils.autoExtFilename(e5, "xls", t5 = t5 || {}), t5.autoExt = false, En(Cs(), e5, t5, s5, n5, r5);
        }, L.from.XLSX = function(e5, t5, s5, n5, r5) {
          return e5 = L.utils.autoExtFilename(e5, "xlsx", t5 = t5 || {}), t5.autoExt = false, En(Cs(), e5, t5, s5, n5, r5);
        }, L.from.ODS = function(e5, t5, s5, n5, r5) {
          return e5 = L.utils.autoExtFilename(e5, "ods", t5 = t5 || {}), t5.autoExt = false, En(Cs(), e5, t5, s5, n5, r5);
        }, L.from.XML = function(e5, t5, s5, n5, r5) {
          var c5;
          return L.utils.loadFile(e5, !!s5, function(e6) {
            function a5() {
              var e7 = o5(/^([^<]*)/);
              return e7 ? e7[1] : "";
            }
            function i5() {
              var e7 = o5(/([\w:-]+)\s*=\s*("[^"]*"|'[^']*'|\w+)\s*/);
              if (e7)
                return { name: e7[1], value: e7[2].replace(/^['"]|['"]$/g, "") };
            }
            function o5(e7) {
              e7 = t6.match(e7);
              if (e7)
                return t6 = t6.slice(e7[0].length), e7;
            }
            function u5() {
              return 0 == t6.length;
            }
            function l5(e7) {
              return 0 == t6.indexOf(e7);
            }
            var t6;
            t6 = (t6 = (t6 = e6).trim()).replace(/<!--[\s\S]*?-->/g, ""), function() {
              if (o5(/^<\?xml\s*/)) {
                for (var e7 = { attributes: {} }; !u5() && !l5("?>"); ) {
                  var t7 = i5();
                  if (!t7)
                    return;
                  e7.attributes[t7.name] = t7.value;
                }
                o5(/\?>\s*/);
              }
            }(), c5 = function e7() {
              var t7 = o5(/^<([\w-:.]+)\s*/);
              if (!t7)
                return;
              var s6 = { name: t7[1], attributes: {}, children: [] };
              for (; !(u5() || l5(">") || l5("?>") || l5("/>")); ) {
                var n6 = i5();
                if (!n6)
                  return s6;
                s6.attributes[n6.name] = n6.value;
              }
              if (o5(/^\s*\/>\s*/))
                return s6;
              o5(/\??>\s*/);
              s6.content = a5();
              var r6;
              for (; r6 = e7(); )
                s6.children.push(r6);
              o5(/^<\/[\w-:.]+>\s*/);
              return s6;
            }(), s5 && (c5 = s5(c5, n5, r5));
          }), c5;
        }, L.from.GEXF = function(e5, t5, s5, n5, r5) {
          var a5;
          return L("SEARCH FROM XML(" + e5 + ")", [], function(e6) {
            a5 = e6, s5 && (a5 = s5(a5));
          }), a5;
        }, M.Print = function(e5) {
          return Object.assign(this, e5);
        }, M.Print.prototype.toString = function() {
          var e5 = "PRINT";
          return this.statement && (e5 += " " + this.statement.toString()), e5;
        }, M.Print.prototype.execute = function(e5, t5, s5) {
          var n5, r5 = this, a5 = 1;
          return L.precompile(this, e5, t5), this.exprs && 0 < this.exprs.length ? (n5 = this.exprs.map(function(e6) {
            e6 = new Function("params,alasql,p", "var y;return " + e6.toJS("({})", "", null)).bind(r5)(t5, L);
            return ln(e6);
          }), console.log.apply(console, n5)) : this.select ? (n5 = this.select.execute(e5, t5), console.log(ln(n5))) : console.log(), a5 = s5 ? s5(a5) : a5;
        }, M.Source = function(e5) {
          return Object.assign(this, e5);
        }, M.Source.prototype.toString = function() {
          var e5 = "SOURCE";
          return this.url && (e5 += " '" + this.url + " '"), e5;
        }, M.Source.prototype.execute = function(e5, t5, s5) {
          var n5;
          return vs(this.url, !!s5, function(e6) {
            return n5 = L(e6), n5 = s5 ? s5(n5) : n5;
          }, function(e6) {
            throw e6;
          }), n5;
        }, M.Require = function(e5) {
          return Object.assign(this, e5);
        }, M.Require.prototype.toString = function() {
          var e5 = "REQUIRE";
          return this.paths && 0 < this.paths.length && (e5 += this.paths.map(function(e6) {
            return e6.toString();
          }).join(",")), this.plugins && 0 < this.plugins.length && (e5 += this.plugins.map(function(e6) {
            return e6.toUpperCase();
          }).join(",")), e5;
        }, M.Require.prototype.execute = function(e5, s5, n5) {
          var r5 = this, a5 = 0, i5 = "";
          return this.paths && 0 < this.paths.length ? this.paths.forEach(function(e6) {
            vs(e6.value, !!n5, function(e7) {
              i5 += e7, ++a5 < r5.paths.length || (new Function("params,alasql", i5)(s5, L), n5 && (a5 = n5(a5)));
            });
          }) : this.plugins && 0 < this.plugins.length ? this.plugins.forEach(function(t5) {
            L.plugins[t5] || vs(L.path + "/alasql-" + t5.toLowerCase() + ".js", !!n5, function(e6) {
              i5 += e6, ++a5 < r5.plugins.length || (new Function("params,alasql", i5)(s5, L), L.plugins[t5] = true, n5 && (a5 = n5(a5)));
            });
          }) : n5 && (a5 = n5(a5)), a5;
        }, M.Assert = function(e5) {
          return Object.assign(this, e5);
        }, M.Source.prototype.toString = function() {
          var e5 = "ASSERT";
          return this.value && (e5 += " " + JSON.stringify(this.value)), e5;
        }, M.Assert.prototype.execute = function(e5) {
          if (Ms(L.res, this.value))
            return 1;
          throw new Error((this.message || "Assert wrong") + ": " + JSON.stringify(L.res) + " == " + JSON.stringify(this.value));
        };
        var gn = L.engines.INDEXEDDB = function() {
        };
        async function mn(s5) {
          var e5 = globalThis.indexedDB;
          if (!e5)
            throw new Error("IndexedDB is not supported in this browser");
          if (e5.databases)
            return (await e5.databases()).find((e6) => e6.name === s5) || 0;
          const n5 = e5.open(s5);
          return new Promise(function(t5, e6) {
            n5.onsuccess = () => {
              n5.result.close(), t5({ name: s5, version: n5.result.version });
            }, n5.onupgradeneeded = (e7) => {
              e7.target.transaction.abort(), t5(0);
            }, n5.onerror = () => {
              e6(new Error("IndexedDB error"));
            }, n5.onblocked = () => {
              t5({ name: s5, version: n5.result.version });
            };
          });
        }
        gn.showDatabases = function(r5, a5) {
          indexedDB.databases ? indexedDB.databases().then((e5) => {
            for (var t5 = [], s5 = r5 && new RegExp(r5.value.replace(/\%/g, ".*"), "g"), n5 = 0; n5 < e5.length; n5++)
              r5 && !e5[n5].name.match(s5) || t5.push({ databaseid: e5[n5].name });
            a5(t5);
          }) : a5(null, new Error("SHOW DATABASE is not supported in this browser"));
        }, gn.createDatabase = async function(e5, t5, s5, n5, r5) {
          if (await mn(e5).catch((e6) => {
            throw r5 && r5(null, e6), e6;
          }))
            s5 ? r5 && r5(0) : (s5 = new Error(`IndexedDB: Cannot create new database "${e5}" because it already exists`), r5 && r5(null, s5));
          else {
            const a5 = indexedDB.open(e5, 1);
            a5.onsuccess = () => {
              a5.result.close(), r5(1);
            };
          }
        }, gn.dropDatabase = async function(e5, t5, s5) {
          await mn(e5).catch((e6) => {
            throw s5 && s5(null, e6), e6;
          }) ? indexedDB.deleteDatabase(e5).onsuccess = () => {
            s5 && s5(1);
          } : t5 ? s5 && s5(0) : s5 && s5(null, new Error(`IndexedDB: Cannot drop new database "${e5}" because it does not exist'`));
        }, gn.attachDatabase = async function(n5, e5, t5, s5, r5) {
          var a5;
          if (!await mn(n5).catch((e6) => {
            throw r5 && r5(null, e6), e6;
          }))
            throw a5 = new Error(`IndexedDB: Cannot attach database "${n5}" because it does not exist`), r5 && r5(null, a5), a5;
          var i5 = await new Promise((e6, t6) => {
            const s6 = indexedDB.open(n5);
            s6.onsuccess = () => {
              e6(s6.result.objectStoreNames), s6.result.close();
            };
          }), o5 = new L.Database(e5 || n5);
          o5.engineid = "INDEXEDDB", o5.ixdbid = n5, o5.tables = [];
          for (var u5 = 0; u5 < i5.length; u5++)
            o5.tables[i5[u5]] = {};
          r5 && r5(1);
        }, gn.createTable = async function(t5, s5, e5, n5) {
          var r5, a5 = L.databases[t5].ixdbid, i5 = await mn(a5).catch((e6) => {
            throw n5 && n5(null, e6), e6;
          });
          if (!i5)
            throw r5 = new Error('IndexedDB: Cannot create table in database "' + a5 + '" because it does not exist'), n5 && n5(null, r5), r5;
          const o5 = indexedDB.open(a5, i5.version + 1);
          o5.onupgradeneeded = function(e6) {
            o5.result.createObjectStore(s5, { autoIncrement: true });
          }, o5.onsuccess = function(e6) {
            o5.result.close(), n5 && n5(1);
          }, o5.onerror = (e6) => {
            n5(null, e6);
          }, o5.onblocked = function(e6) {
            n5(null, new Error(`Cannot create table "${s5}" because database "${t5}"  is blocked`));
          };
        }, gn.dropTable = async function(s5, n5, r5, t5) {
          var e5 = L.databases[s5].ixdbid, a5 = await mn(e5).catch((e6) => {
            throw t5 && t5(null, e6), e6;
          });
          if (!a5) {
            const o6 = new Error('IndexedDB: Cannot drop table in database "' + e5 + '" because it does not exist');
            throw t5 && t5(null, o6), o6;
          }
          const i5 = indexedDB.open(e5, a5.version + 1);
          let o5;
          i5.onupgradeneeded = function(e6) {
            var t6 = i5.result;
            t6.objectStoreNames.contains(n5) ? (t6.deleteObjectStore(n5), delete L.databases[s5].tables[n5]) : r5 || (o5 = new Error(`IndexedDB: Cannot drop table "${n5}" because it does not exist`), e6.target.transaction.abort());
          }, i5.onsuccess = function(e6) {
            i5.result.close(), t5 && t5(1);
          }, i5.onerror = function(e6) {
            t5 && t5(null, o5 || e6);
          }, i5.onblocked = function(e6) {
            t5(null, new Error(`Cannot drop table "${n5}" because database "${s5}" is blocked`));
          };
        }, gn.intoTable = function(t5, a5, i5, e5, o5) {
          var s5 = L.databases[t5].ixdbid;
          const u5 = indexedDB.open(s5);
          u5.onupgradeneeded = (e6) => {
            e6.target.transaction.abort();
            e6 = new Error(`Cannot insert into table "${a5}" because database "${t5}" does not exist`);
            o5 && o5(null, e6);
          }, u5.onsuccess = () => {
            for (var e6 = u5.result, t6 = e6.transaction([a5], "readwrite"), s6 = t6.objectStore(a5), n5 = 0, r5 = i5.length; n5 < r5; n5++)
              s6.add(i5[n5]);
            t6.oncomplete = function() {
              e6.close(), o5 && o5(r5);
            };
          };
        }, gn.fromTable = function(t5, r5, a5, i5, o5) {
          var e5 = L.databases[t5].ixdbid;
          const u5 = indexedDB.open(e5);
          u5.onupgradeneeded = (e6) => {
            e6.target.transaction.abort();
            e6 = new Error(`Cannot select from table "${r5}" because database "${t5}" does not exist`);
            a5 && a5(null, e6);
          }, u5.onsuccess = () => {
            const t6 = [], s5 = u5.result, n5 = s5.transaction([r5]).objectStore(r5).openCursor();
            n5.onsuccess = () => {
              var e6 = n5.result;
              e6 ? (t6.push(e6.value), e6.continue()) : (s5.close(), a5 && a5(t6, i5, o5));
            };
          };
        }, gn.deleteFromTable = function(e5, r5, a5, i5, o5) {
          e5 = L.databases[e5].ixdbid;
          const u5 = indexedDB.open(e5);
          u5.onsuccess = () => {
            const t5 = u5.result, s5 = t5.transaction([r5], "readwrite").objectStore(r5).openCursor();
            let n5 = 0;
            s5.onsuccess = () => {
              var e6 = s5.result;
              e6 ? (a5 && !a5(e6.value, i5, L) || (e6.delete(), n5++), e6.continue()) : (t5.close(), o5 && o5(n5));
            };
          };
        }, gn.updateTable = function(e5, t5, a5, i5, o5, u5) {
          e5 = L.databases[e5].ixdbid;
          const l5 = indexedDB.open(e5);
          l5.onsuccess = function() {
            const s5 = l5.result, n5 = s5.transaction([t5], "readwrite").objectStore(t5).openCursor();
            let r5 = 0;
            n5.onsuccess = () => {
              var e6, t6 = n5.result;
              t6 ? (i5 && !i5(t6.value, o5) || (e6 = t6.value, a5(e6, o5), t6.update(e6), r5++), t6.continue()) : (s5.close(), u5 && u5(r5));
            };
          };
        };
        var Tn = L.engines.LOCALSTORAGE = function() {
        }, Sn = (Tn.get = function(t5) {
          var e5, t5 = localStorage.getItem(t5);
          if (void 0 !== t5) {
            try {
              e5 = JSON.parse(t5);
            } catch (e6) {
              throw new Error("Cannot parse JSON object from localStorage" + t5);
            }
            return e5;
          }
        }, Tn.set = function(e5, t5) {
          void 0 === t5 ? localStorage.removeItem(e5) : localStorage.setItem(e5, JSON.stringify(t5));
        }, Tn.storeTable = function(e5, t5) {
          var e5 = L.databases[e5], s5 = e5.tables[t5], n5 = {};
          n5.columns = s5.columns, n5.data = s5.data, n5.identities = s5.identities, Tn.set(e5.lsdbid + "." + t5, n5);
        }, Tn.restoreTable = function(e5, t5) {
          var s5, e5 = L.databases[e5], n5 = Tn.get(e5.lsdbid + "." + t5), r5 = new L.Table();
          for (s5 in n5)
            r5[s5] = n5[s5];
          return (e5.tables[t5] = r5).indexColumns(), r5;
        }, Tn.removeTable = function(e5, t5) {
          e5 = L.databases[e5];
          localStorage.removeItem(e5.lsdbid + "." + t5);
        }, Tn.createDatabase = function(e5, t5, s5, n5, r5) {
          var a5 = 1, i5 = Tn.get("alasql");
          if (s5 && i5 && i5.databases && i5.databases[e5])
            a5 = 0;
          else {
            if ((i5 = i5 || { databases: {} }).databases && i5.databases[e5])
              throw new Error('localStorage: Cannot create new database "' + e5 + '" because it already exists');
            i5.databases[e5] = true, Tn.set("alasql", i5), Tn.set(e5, { databaseid: e5, tables: {} });
          }
          return a5 = r5 ? r5(a5) : a5;
        }, Tn.dropDatabase = function(e5, t5, s5) {
          var n5, r5 = 1, a5 = Tn.get("alasql");
          if (t5 && a5 && a5.databases && !a5.databases[e5])
            r5 = 0;
          else {
            if (!a5) {
              if (t5)
                return s5 ? s5(0) : 0;
              throw new Error("There is no any AlaSQL databases in localStorage");
            }
            if (a5.databases && !a5.databases[e5])
              throw new Error('localStorage: Cannot drop database "' + e5 + '" because there is no such database');
            for (n5 in delete a5.databases[e5], Tn.set("alasql", a5), Tn.get(e5).tables)
              localStorage.removeItem(e5 + "." + n5);
            localStorage.removeItem(e5);
          }
          return r5 = s5 ? s5(r5) : r5;
        }, Tn.attachDatabase = function(e5, t5, s5, n5, r5) {
          var a5 = 1;
          if (L.databases[t5])
            throw new Error('Unable to attach database as "' + t5 + '" because it already exists');
          var i5 = new L.Database(t5 = t5 || e5);
          if (i5.engineid = "LOCALSTORAGE", i5.lsdbid = e5, i5.tables = Tn.get(e5).tables, !L.options.autocommit && i5.tables)
            for (var o5 in i5.tables)
              Tn.restoreTable(t5, o5);
          return a5 = r5 ? r5(a5) : a5;
        }, Tn.showDatabases = function(e5, t5) {
          var s5, n5 = [], r5 = Tn.get("alasql");
          if (e5 && (s5 = new RegExp(e5.value.replace(/%/g, ".*"), "g")), r5 && r5.databases) {
            for (var a5 in r5.databases)
              n5.push({ databaseid: a5 });
            e5 && n5 && 0 < n5.length && (n5 = n5.filter(function(e6) {
              return e6.databaseid.match(s5);
            }));
          }
          return n5 = t5 ? t5(n5) : n5;
        }, Tn.createTable = function(e5, t5, s5, n5) {
          var r5 = 1, a5 = L.databases[e5].lsdbid;
          if (Tn.get(a5 + "." + t5) && !s5)
            throw new Error('Table "' + t5 + '" alsready exists in localStorage database "' + a5 + '"');
          s5 = Tn.get(a5);
          L.databases[e5].tables[t5];
          return s5.tables[t5] = true, Tn.set(a5, s5), Tn.storeTable(e5, t5), r5 = n5 ? n5(r5) : r5;
        }, Tn.truncateTable = function(e5, t5, s5, n5) {
          var r5 = 1, a5 = L.databases[e5].lsdbid, a5 = L.options.autocommit ? Tn.get(a5) : L.databases[e5];
          if (s5 || a5.tables[t5])
            return Tn.restoreTable(e5, t5).data = [], Tn.storeTable(e5, t5), r5 = n5 ? n5(r5) : r5;
          throw new Error('Cannot truncate table "' + t5 + '" in localStorage, because it does not exist');
        }, Tn.dropTable = function(e5, t5, s5, n5) {
          var r5 = 1, a5 = L.databases[e5].lsdbid, i5 = L.options.autocommit ? Tn.get(a5) : L.databases[e5];
          if (s5 || i5.tables[t5])
            return delete i5.tables[t5], Tn.set(a5, i5), Tn.removeTable(e5, t5), r5 = n5 ? n5(r5) : r5;
          throw new Error('Cannot drop table "' + t5 + '" in localStorage, because it does not exist');
        }, Tn.fromTable = function(e5, t5, s5, n5, r5) {
          L.databases[e5].lsdbid;
          e5 = Tn.restoreTable(e5, t5).data;
          return e5 = s5 ? s5(e5, n5, r5) : e5;
        }, Tn.intoTable = function(e5, t5, s5, n5, r5) {
          L.databases[e5].lsdbid;
          var a5, i5 = s5.length, o5 = Tn.restoreTable(e5, t5);
          for (a5 in o5.identities) {
            var u5, l5 = o5.identities[a5];
            for (u5 in s5)
              s5[u5][a5] = l5.value, l5.value += l5.step;
          }
          return o5.data || (o5.data = []), o5.data = o5.data.concat(s5), Tn.storeTable(e5, t5), i5 = r5 ? r5(i5) : i5;
        }, Tn.loadTableData = function(e5, t5) {
          L.databases[e5], L.databases[e5].lsdbid;
          Tn.restoreTable(e5, t5);
        }, Tn.saveTableData = function(e5, t5) {
          var s5 = L.databases[e5], e5 = L.databases[e5].lsdbid;
          Tn.storeTable(e5, t5), s5.tables[t5].data = void 0;
        }, Tn.begin = Tn.commit = function(e5, t5) {
          var s5 = L.databases[e5], n5 = L.databases[e5].lsdbid, r5 = { databaseid: n5, tables: {} };
          if (s5.tables)
            for (var a5 in s5.tables)
              r5.tables[a5] = true, Tn.storeTable(e5, a5);
          return Tn.set(n5, r5), t5 ? t5(1) : 1;
        }, Tn.rollback = function(e5, t5) {
        }, L.engines.SQLITE = function() {
        }), An = (Sn.createDatabase = function(e5, t5, s5, n5, r5) {
          throw new Error("Connot create SQLITE database in memory. Attach it.");
        }, Sn.dropDatabase = function(e5) {
          throw new Error("This is impossible to drop SQLite database. Detach it.");
        }, Sn.attachDatabase = function(t5, n5, s5, e5, r5) {
          var a5;
          if (L.databases[n5])
            throw new Error('Unable to attach database as "' + n5 + '" because it already exists');
          if (s5[0] && s5[0] instanceof M.StringValue || s5[0] instanceof M.ParamValue)
            return s5[0] instanceof M.StringValue ? a5 = s5[0].value : s5[0] instanceof M.ParamValue && (a5 = e5[s5[0].param]), L.utils.loadBinaryFile(a5, true, function(e6) {
              var s6 = new L.Database(n5 || t5), e6 = (s6.engineid = "SQLITE", s6.sqldbid = t5, s6.sqldb = new SQL.Database(e6));
              s6.tables = [], e6.exec("SELECT * FROM sqlite_master WHERE type='table'")[0].values.forEach(function(e7) {
                s6.tables[e7[1]] = {};
                var t6 = s6.tables[e7[1]].columns = [], e7 = L.parse(e7[4]).statements[0].columns;
                e7 && 0 < e7.length && e7.forEach(function(e8) {
                  t6.push(e8);
                });
              }), r5(1);
            }, function(e6) {
              throw new Error('Cannot open SQLite database file "' + s5[0].value + '"');
            }), 1;
          throw new Error("Cannot attach SQLite database without a file");
        }, Sn.fromTable = function(e5, t5, s5, n5, r5) {
          var e5 = L.databases[e5].sqldb.exec("SELECT * FROM " + t5), a5 = r5.sources[n5].columns = [], i5 = (0 < e5[0].columns.length && e5[0].columns.forEach(function(e6) {
            a5.push({ columnid: e6 });
          }), []);
          0 < e5[0].values.length && e5[0].values.forEach(function(s6) {
            var n6 = {};
            a5.forEach(function(e6, t6) {
              n6[e6.columnid] = s6[t6];
            }), i5.push(n6);
          }), s5 && s5(i5, n5, r5);
        }, Sn.intoTable = function(e5, t5, s5, n5, r5) {
          for (var a5 = L.databases[e5].sqldb, i5 = 0, o5 = s5.length; i5 < o5; i5++) {
            var u5 = "INSERT INTO " + t5 + " (", l5 = s5[i5], c5 = Object.keys(l5), u5 = (u5 = u5 + c5.join(",") + ") VALUES (") + c5.map(function(e6) {
              e6 = l5[e6];
              return e6 = "string" == typeof e6 ? "'" + e6 + "'" : e6;
            }).join(",") + ")";
            a5.exec(u5);
          }
          e5 = o5;
          return r5 && r5(e5), e5;
        }, L.engines.FILESTORAGE = L.engines.FILE = function() {
        });
        if (An.createDatabase = function(e5, t5, s5, n5, r5) {
          var a5 = 1, i5 = t5[0].value;
          return L.utils.fileExists(i5, function(e6) {
            if (e6) {
              if (s5)
                return a5 = 0, a5 = r5 ? r5(a5) : a5;
              throw new Error("Cannot create new database file, because it already exists");
            }
            L.utils.saveFile(i5, JSON.stringify({ tables: {} }), function(e7) {
              r5 && (a5 = r5(a5));
            });
          }), a5;
        }, An.dropDatabase = function(e5, t5, s5) {
          var n5, r5 = "";
          return "object" == typeof e5 && e5.value ? r5 = e5.value : (r5 = (L.databases[e5] || {}).filename || "", delete L.databases[e5]), L.utils.fileExists(r5, function(e6) {
            if (e6)
              n5 = 1, L.utils.deleteFile(r5, function() {
                n5 = 1, s5 && (n5 = s5(n5));
              });
            else {
              if (!t5)
                throw new Error("Cannot drop database file, because it does not exist");
              n5 = 0, s5 && (n5 = s5(n5));
            }
          }), n5;
        }, An.attachDatabase = function(e5, t5, s5, n5, r5) {
          var a5 = 1;
          if (L.databases[t5])
            throw new Error('Unable to attach database as "' + t5 + '" because it already exists');
          var i5 = new L.Database(t5 || e5);
          return i5.engineid = "FILESTORAGE", i5.filename = s5[0].value, vs(i5.filename, !!r5, function(e6) {
            try {
              i5.data = JSON.parse(e6);
            } catch (e7) {
              throw new Error("Data in FileStorage database are corrupted");
            }
            if (i5.tables = i5.data.tables, !L.options.autocommit && i5.tables)
              for (var t6 in i5.tables)
                i5.tables[t6].data = i5.data[t6];
            r5 && (a5 = r5(a5));
          }), a5;
        }, An.createTable = function(e5, t5, s5, n5) {
          var r5 = L.databases[e5];
          if (r5.data[t5] && !s5)
            throw new Error('Table "' + t5 + '" alsready exists in the database "' + fsdbid + '"');
          s5 = L.databases[e5].tables[t5];
          return r5.data.tables[t5] = { columns: s5.columns }, r5.data[t5] = [], An.updateFile(e5), n5 && n5(1), 1;
        }, An.updateFile = function(e5) {
          var t5 = L.databases[e5];
          t5.issaving ? t5.postsave = true : (t5.issaving = true, t5.postsave = false, L.utils.saveFile(t5.filename, JSON.stringify(t5.data), function() {
            t5.issaving = false, t5.postsave && setTimeout(function() {
              An.updateFile(e5);
            }, 50);
          }));
        }, An.dropTable = function(e5, t5, s5, n5) {
          var r5 = L.databases[e5];
          if (s5 || r5.tables[t5])
            return delete r5.tables[t5], delete r5.data.tables[t5], delete r5.data[t5], An.updateFile(e5), n5 && n5(1), 1;
          throw new Error('Cannot drop table "' + t5 + '" in fileStorage, because it does not exist');
        }, An.fromTable = function(e5, t5, s5, n5, r5) {
          e5 = L.databases[e5].data[t5];
          return e5 = s5 ? s5(e5, n5, r5) : e5;
        }, An.intoTable = function(e5, t5, s5, n5, r5) {
          var a5 = L.databases[e5], i5 = s5.length, o5 = (o5 = a5.data[t5]) || [];
          return a5.data[t5] = o5.concat(s5), An.updateFile(e5), r5 && r5(i5), i5;
        }, An.loadTableData = function(e5, t5) {
          e5 = L.databases[e5];
          e5.tables[t5].data = e5.data[t5];
        }, An.saveTableData = function(e5, t5) {
          var s5 = L.databases[e5];
          s5.data[t5] = s5.tables[t5].data, s5.tables[t5].data = null, An.updateFile(e5);
        }, An.begin = An.commit = function(e5, t5) {
          var s5 = L.databases[e5];
          if (s5.tables)
            for (var n5 in s5.tables)
              s5.data.tables[n5] = { columns: s5.tables[n5].columns }, s5.data[n5] = s5.tables[n5].data;
          return An.updateFile(e5), t5 ? t5(1) : 1;
        }, An.rollback = function(n5, r5) {
          var a5 = 1, i5 = L.databases[n5];
          i5.dbversion++, function e5() {
            setTimeout(function() {
              if (i5.issaving)
                return e5();
              L.loadFile(i5.filename, !!r5, function(e6) {
                for (var t5 in i5.data = e6, i5.tables = {}, i5.data.tables) {
                  var s5 = new L.Table({ columns: i5.data.tables[t5].columns });
                  Fs(s5, i5.data.tables[t5]), i5.tables[t5] = s5, L.options.autocommit || (i5.tables[t5].data = i5.data[t5]), i5.tables[t5].indexColumns();
                }
                delete L.databases[n5], L.databases[n5] = new L.Database(n5), Fs(L.databases[n5], i5), L.databases[n5].engineid = "FILESTORAGE", L.databases[n5].filename = i5.filename, r5 && (a5 = r5(a5));
              });
            }, 100);
          }();
        }, bs.isBrowser && !bs.isWebWorker) {
          if (!(L = L || false))
            throw new Error("alasql was not found");
          L.worker = function() {
            throw new Error("Can find webworker in this enviroment");
          }, "undefined" != typeof Worker && (L.worker = function(e5, t5, s5) {
            if (void 0 === (e5 = true === e5 ? void 0 : e5))
              for (var n5 = document.getElementsByTagName("script"), r5 = 0; r5 < n5.length; r5++) {
                if ("alasql-worker.js" === n5[r5].src.substr(-16).toLowerCase()) {
                  e5 = n5[r5].src.substr(0, n5[r5].src.length - 16) + "alasql.js";
                  break;
                }
                if ("alasql-worker.min.js" === n5[r5].src.substr(-20).toLowerCase()) {
                  e5 = n5[r5].src.substr(0, n5[r5].src.length - 20) + "alasql.min.js";
                  break;
                }
                if ("alasql.js" === n5[r5].src.substr(-9).toLowerCase()) {
                  e5 = n5[r5].src;
                  break;
                }
                if ("alasql.min.js" === n5[r5].src.substr(-13).toLowerCase()) {
                  e5 = n5[r5].src.substr(0, n5[r5].src.length - 13) + "alasql.min.js";
                  break;
                }
              }
            if (void 0 === e5)
              throw new Error("Path to alasql.js is not specified");
            var a5;
            false !== e5 ? (a5 = (a5 = "importScripts('") + e5 + "');self.onmessage = function(event) {alasql(event.data.sql,event.data.params, function(data){postMessage({id:event.data.id, data:data});});}", a5 = new Blob([a5], { type: "text/plain" }), L.webworker = new Worker(URL.createObjectURL(a5)), L.webworker.onmessage = function(e6) {
              var t6 = e6.data.id;
              L.buffer[t6](e6.data.data), delete L.buffer[t6];
            }, L.webworker.onerror = function(e6) {
              throw e6;
            }, 1 < arguments.length && (a5 = "REQUIRE " + t5.map(function(e6) {
              return '"' + e6 + '"';
            }).join(","), L(a5, [], s5))) : false === e5 && delete L.webworker;
          });
          var yn = yn || function(o5) {
            var u5, l5, c5, h5, d5, f5, t5, p5, b5, n5, e5;
            if (!(void 0 === o5 || "undefined" != typeof navigator && /MSIE [1-9]\./.test(navigator.userAgent)))
              return e5 = o5.document, u5 = function() {
                return o5.URL || o5.webkitURL || o5;
              }, l5 = e5.createElementNS("http://www.w3.org/1999/xhtml", "a"), c5 = "download" in l5, h5 = /constructor/i.test(o5.HTMLElement) || o5.safari, d5 = /CriOS\/[\d]+/.test(navigator.userAgent), f5 = function(e6) {
                (o5.setImmediate || o5.setTimeout)(function() {
                  throw e6;
                }, 0);
              }, t5 = 4e4, p5 = function(e6) {
                setTimeout(function() {
                  "string" == typeof e6 ? u5().revokeObjectURL(e6) : e6.remove();
                }, t5);
              }, b5 = function(e6) {
                return /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(e6.type) ? new Blob([String.fromCharCode(65279), e6], { type: e6.type }) : e6;
              }, e5 = (n5 = function(e6, s5, t6) {
                t6 || (e6 = b5(e6));
                var n6, r5, a5 = this, t6 = "application/octet-stream" === e6.type, i5 = function() {
                  for (var e7 = a5, t7 = "writestart progress write writeend".split(" "), s6 = void 0, n7 = (t7 = [].concat(t7)).length; n7--; ) {
                    var r6 = e7["on" + t7[n7]];
                    if ("function" == typeof r6)
                      try {
                        r6.call(e7, s6 || e7);
                      } catch (e8) {
                        f5(e8);
                      }
                  }
                };
                a5.readyState = a5.INIT, c5 ? (n6 = u5().createObjectURL(e6), setTimeout(function() {
                  var e7, t7;
                  l5.href = n6, l5.download = s5, e7 = l5, t7 = new MouseEvent("click"), e7.dispatchEvent(t7), i5(), p5(n6), a5.readyState = a5.DONE;
                })) : (d5 || t6 && h5) && o5.FileReader ? ((r5 = new FileReader()).onloadend = function() {
                  var e7 = d5 ? r5.result : r5.result.replace(/^data:[^;]*;/, "data:attachment/file;");
                  o5.open(e7, "_blank") || (o5.location.href = e7), a5.readyState = a5.DONE, i5();
                }, r5.readAsDataURL(e6), a5.readyState = a5.INIT) : (n6 = n6 || u5().createObjectURL(e6), !t6 && o5.open(n6, "_blank") || (o5.location.href = n6), a5.readyState = a5.DONE, i5(), p5(n6));
              }).prototype, "undefined" != typeof navigator && navigator.msSaveOrOpenBlob ? function(e6, t6, s5) {
                return t6 = t6 || e6.name || "download", s5 || (e6 = b5(e6)), navigator.msSaveOrOpenBlob(e6, t6);
              } : (e5.abort = function() {
              }, e5.readyState = e5.INIT = 0, e5.WRITING = 1, e5.DONE = 2, e5.error = e5.onwritestart = e5.onprogress = e5.onwrite = e5.onabort = e5.onerror = e5.onwriteend = null, function(e6, t6, s5) {
                return new n5(e6, t6 || e6.name || "download", s5);
              });
          }("undefined" != typeof self && self || "undefined" != typeof window && window || this.content);
          "undefined" != typeof module && module.exports ? module.exports.saveAs = yn : "undefined" != typeof define && null !== define && null !== define.amd && define("FileSaver.js", function() {
            return yn;
          }), (bs.isCordova || bs.isMeteorServer || bs.isNode) && console.log("It looks like you are using the browser version of AlaSQL. Please use the alasql.fs.js file instead."), L.utils.saveAs = yn;
        }
        return new Gs("alasql"), L.use("alasql"), L;
      });
    }
  });

  // stores/global-units.js
  var require_global_units = __commonJS({
    "stores/global-units.js"(exports) {
      exports.globalUnits = {
        "stk.": { unit: "kus", factor: 1 },
        blatt: { unit: "kus", factor: 1 },
        paar: { unit: "kus", factor: 1 },
        stk: { unit: "kus", factor: 1 },
        st: { unit: "kus", factor: 1 },
        teebeutel: { unit: "kus", factor: 1 },
        t\u00FCcher: { unit: "kus", factor: 1 },
        rollen: { unit: "kus", factor: 1 },
        tabs: { unit: "kus", factor: 1 },
        st\u00FCck: { unit: "kus", factor: 1 },
        mm: { unit: "cm", factor: 0.1 },
        cm: { unit: "cm", factor: 1 },
        zentimeter: { unit: "cm", factor: 1 },
        m: { unit: "cm", factor: 100 },
        meter: { unit: "cm", factor: 100 },
        g: { unit: "g", factor: 1 },
        gr: { unit: "g", factor: 1 },
        gramm: { unit: "g", factor: 1 },
        dag: { unit: "g", factor: 10 },
        kg: { unit: "g", factor: 1e3 },
        kilogramm: { unit: "g", factor: 1e3 },
        ml: { unit: "ml", factor: 1 },
        milliliter: { unit: "ml", factor: 1 },
        dl: { unit: "ml", factor: 10 },
        cl: { unit: "ml", factor: 100 },
        l: { unit: "ml", factor: 1e3 },
        lt: { unit: "ml", factor: 1e3 },
        liter: { unit: "ml", factor: 1e3 },
        wg: { unit: "wg", factor: 1 },
        ks: { unit: "kus", factor: 1 },
        rol\u00ED: { unit: "kus", factor: 1 },
        role: { unit: "kus", factor: 1 },
        rolky: { unit: "kus", factor: 1 },
        rl: { unit: "kus", factor: 1 },
        "m\xB2": { unit: "m\xB2", factor: 1 },
        "p.d\xE1v": { unit: "p.d\xE1v", factor: 1 },
        pd: { unit: "p.d\xE1v", factor: 1 }
      };
    }
  });

  // site/model/stores.js
  var require_stores = __commonJS({
    "site/model/stores.js"(exports) {
      exports.stores = {
        billa: {
          name: "Billa",
          budgetBrands: ["clever"],
          color: "yellow",
          defaultChecked: true,
          getUrl: (item) => item.url ? `https://shop.billa.cz/produkt/${item.url}` : `https://www.google.com/search?q="${item.id}"`
        },
        lidl: {
          name: "Lidl",
          budgetBrands: ["milbona", "alpengut", "cien", "livarno", "wiesentaler", "pilos", "n\xE1\u0161 kraj", "crivit", "parkside", "silvercrest", "esmara"],
          color: "pink",
          defaultChecked: true,
          getUrl: (item) => `https://www.lidl.cz${item.url}`,
          removeOld: true
        },
        penny: {
          name: "Penny",
          budgetBrands: [
            "louisa a bodie",
            "na gril",
            "boni",
            "kouzeln\xFD \u010Daj",
            "penny",
            "karlova koruna",
            "tanja",
            "\u0159ezn\xEDk\u016Fv tal\xED\u0159",
            "staro\u010Dech",
            "od \u010Desk\xFDch farm\xE1\u0159\u016F",
            "wippy",
            "mraziv\xE1 \u010Derstvost",
            "enjoy",
            "solty",
            "crip crop"
          ],
          color: "purple",
          defaultChecked: true,
          getUrl: (item) => `https://www.penny.cz/products/${item.url}`,
          removeOld: true
        },
        dm: {
          name: "DM",
          budgetBrands: ["balea"],
          color: "orange",
          defaultChecked: true,
          getUrl: (item) => `https://www.dm.cz/product-p${item.url}`
        },
        albert: {
          name: "Albert",
          budgetBrands: [],
          color: "green",
          defaultChecked: true,
          getUrl: (item) => `https://www.albert.cz${item.url}`
        },
        globus: {
          name: "Globus",
          budgetBrands: [],
          color: "rose",
          defaultChecked: true,
          getUrl: (item) => `https://shop.iglobus.cz${item.url}`
        },
        tesco: {
          name: "Tesco",
          budgetBrands: [],
          color: "emerald",
          defaultChecked: true,
          getUrl: (item) => `https://nakup.itesco.cz/groceries/cs-CZ/products/${item.id}`
        },
        kaufland: {
          name: "Kaufland",
          budgetBrands: [],
          color: "blue",
          defaultChecked: true,
          getUrl: (item) => `https://www.kosik.cz${item.url}`
        }
      };
      exports.STORE_KEYS = Object.keys(exports.stores);
      exports.BUDGET_BRANDS = [...new Set([].concat(...Object.values(exports.stores).map((store) => store.budgetBrands)))];
    }
  });

  // site/js/misc.js
  var require_misc = __commonJS({
    "site/js/misc.js"(exports) {
      var alasql = require_alasql_min();
      var globalUnits = require_global_units();
      var { stores, BUDGET_BRANDS } = require_stores();
      if (typeof window !== "undefined") {
        let setupLiveEdit2 = function() {
          if (window.location.host.indexOf("localhost") < 0 && window.location.host.indexOf("127.0.0.1") < 0)
            return;
          var script = document.createElement("script");
          script.type = "text/javascript";
          script.onload = () => {
            let lastChangeTimestamp = null;
            let socket = io({ transports: ["websocket"] });
            socket.on("message", (timestamp) => {
              if (lastChangeTimestamp != timestamp) {
                setTimeout(() => location.reload(), 100);
                lastChangeTimestamp = timestamp;
              }
            });
          };
          script.src = "js/socket.io.js";
          document.body.appendChild(script);
        };
        setupLiveEdit = setupLiveEdit2;
        setupLiveEdit2();
      }
      var setupLiveEdit;
      exports.isMobile = () => {
        return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      };
      exports.today = () => {
        const currentDate = /* @__PURE__ */ new Date();
        const year = currentDate.getFullYear();
        const month = String(currentDate.getMonth() + 1).padStart(2, "0");
        const day = String(currentDate.getDate()).padStart(2, "0");
        return `${year}-${month}-${day}`;
      };
      exports.fetchJSON = async (url) => {
        const response = await fetch(url);
        return await response.json();
      };
      exports.downloadJSON = (filename, content) => {
        exports.downloadFile(filename, JSON.stringify(content, null, 2));
      };
      exports.downloadFile = (filename, content) => {
        const blob = new Blob([content], { type: "text/plain" });
        const element = document.createElement("a");
        element.href = URL.createObjectURL(blob);
        element.download = filename;
        element.style.display = "none";
        document.body.appendChild(element);
        element.click();
        document.body.removeChild(element);
        URL.revokeObjectURL(element.href);
      };
      exports.dom = (element, innerHTML) => {
        const el = document.createElement(element);
        el.innerHTML = innerHTML;
        return el;
      };
      exports.getQueryParameter = (name) => {
        const url = new URL(window.location.href);
        const params = url.searchParams.getAll(name);
        return params.length > 1 ? params : params?.[0];
      };
      exports.getBooleanAttribute = (element, name) => {
        return element.hasAttribute(name) && (element.getAttribute(name).length == 0 || element.getAttribute(name) === "true");
      };
      exports.parseNumber = (value, defaultValue) => {
        try {
          return Number.parseFloat(value);
        } catch (e) {
          return defaultValue;
        }
      };
      exports.queryItemsAlasql = (query, items) => {
        alasql.fn.hasPriceChange = (priceHistory, date, endDate) => {
          if (!endDate)
            return priceHistory.some((price) => price.date == date);
          else
            return priceHistory.some((price) => price.date >= date && price.date <= endDate);
        };
        alasql.fn.hasPriceChangeLike = (priceHistory, date) => {
          return priceHistory.some((price) => price.date.indexOf(date) >= 0);
        };
        alasql.fn.daysBetween = (date1, date2) => {
          const d1 = new Date(date1);
          const d2 = new Date(date2);
          const diffInMs = Math.abs(d2 - d1);
          const days = Math.ceil(diffInMs / (1e3 * 60 * 60 * 24));
          return days;
        };
        alasql.fn.priceOn = (priceHistory, date) => {
          return exports.priceOn(priceHistory, date);
        };
        alasql.fn.unitPriceOn = (priceHistory, date) => {
          return exports.unitPriceOn(priceHistory, date);
        };
        alasql.fn.percentageChangeSince = (priceHistory, date) => {
          const firstPrice = exports.priceOn(priceHistory, date);
          const price = priceHistory[0].price;
          return (price - firstPrice) / firstPrice * 100;
        };
        query = query.substring(1);
        return alasql("select * from ? where " + query, [items]);
      };
      exports.queryItems = (query, items, exactWord) => {
        query = query.trim().replace(",", ".").toLowerCase();
        if (query.length < 3)
          return { items: [], queryTokens: [] };
        const regex = /([\p{L}&-\.][\p{L}\p{N}&-\.]*)|(>=|<=|=|>|<)|(\d+[^\s.]+)|(\d+(\.\d+[^\s.]+)?)/gu;
        let tokens = query.match(regex);
        let newTokens = [];
        let unitQueries = [];
        const operators = ["<", "<=", ">", ">=", "="];
        for (let i = 0; i < tokens.length; i++) {
          const token2 = tokens[i];
          let unit = globalUnits.globalUnits[token2];
          if (unit && i > 0 && /^\d+(\.\d+)?$/.test(tokens[i - 1])) {
            newTokens.pop();
            let operator = "=";
            if (i > 1 && operators.includes(tokens[i - 2])) {
              newTokens.pop();
              operator = tokens[i - 2];
            }
            unitQueries.push({
              operator,
              quantity: Number.parseFloat(tokens[i - 1]) * unit.factor,
              unit: unit.unit
            });
          } else {
            newTokens.push(token2);
          }
        }
        tokens = newTokens;
        let hits = [];
        for (const item of items) {
          let allFound = true;
          for (let token2 of tokens) {
            if (token2.length === 0)
              continue;
            let not = false;
            if (token2.startsWith("-") && token2.length > 1) {
              not = true;
              token2 = token2.substring(1);
            }
            const index = item.search.indexOf(token2);
            if (!not && index < 0 || not && index >= 0) {
              allFound = false;
              break;
            }
            if (exactWord) {
              if (index > 0 && item.search.charAt(index - 1) != " " && item.search.charAt(index - 1) != "-") {
                allFound = false;
                break;
              }
              if (index + token2.length < item.search.length && item.search.charAt(index + token2.length) != " ") {
                allFound = false;
                break;
              }
            }
          }
          if (allFound) {
            let allUnitsMatched = true;
            for (const query2 of unitQueries) {
              if (query2.unit != item.unit) {
                allUnitsMatched = false;
                break;
              }
              if (query2.operator == "=" && !(item.quantity == query2.quantity)) {
                allUnitsMatched = false;
                break;
              }
              if (query2.operator == "<" && !(item.quantity < query2.quantity)) {
                allUnitsMatched = false;
                break;
              }
              if (query2.operator == "<=" && !(item.quantity <= query2.quantity)) {
                allUnitsMatched = false;
                break;
              }
              if (query2.operator == ">" && !(item.quantity > query2.quantity)) {
                allUnitsMatched = false;
                break;
              }
              if (query2.operator == ">=" && !(item.quantity >= query2.quantity)) {
                allUnitsMatched = false;
                break;
              }
            }
            if (allUnitsMatched)
              hits.push(item);
          }
        }
        return { items: hits, queryTokens: tokens.filter((token2) => !token2.startsWith("-")) };
      };
      exports.onVisibleOnce = (target, callback) => {
        let isTargetVisible = false;
        const observer = new IntersectionObserver((entries) => {
          entries.forEach((entry) => {
            if (entry.target === target && entry.isIntersecting) {
              if (!isTargetVisible) {
                isTargetVisible = true;
                callback();
              }
              observer.unobserve(target);
            }
          });
        });
        observer.observe(target);
      };
      exports.log = (message, trace = false) => {
        const now = /* @__PURE__ */ new Date();
        const hours = String(now.getHours()).padStart(2, "0");
        const minutes = String(now.getMinutes()).padStart(2, "0");
        const seconds = String(now.getSeconds()).padStart(2, "0");
        console.log(`${hours}:${minutes}:${seconds}: ${message}`);
        if (trace)
          console.trace("trace");
      };
      exports.deltaTime = (start) => {
        return (performance.now() - start) / 1e3;
      };
      exports.itemsToCSV = (items) => {
        let result = "store;id;name;priceDate;price;isBudgetBrand;quantity;unit;isWeighted;isBio;isAvailable;url\n";
        for (const item of items) {
          if (item.store == "lidl" || item.store == "penny")
            continue;
          if (!item.name)
            continue;
          let rowFront = "";
          rowFront += item.store + ";";
          rowFront += `"${item.id}";`;
          rowFront += item.name.replace(";", " ") + ";";
          let rowBack = ";";
          rowBack += BUDGET_BRANDS.some((budgetBrand) => item.name.toLowerCase().indexOf(budgetBrand) >= 0) + ";";
          rowBack += item.quantity + ";";
          rowBack += item.unit + ";";
          rowBack += (item.isWeighted ?? false) + ";";
          rowBack += (item.bio ?? false) + ";";
          rowBack += !(item.unavailable ?? false) + ";";
          rowBack += stores[item.store].getUrl(item) + ";";
          for (const price of item.priceHistory) {
            result += rowFront + price.date + ";" + price.price + rowBack + "\n";
          }
        }
        return result;
      };
      exports.numberToLocale = (number) => {
        try {
          let locale = "at-DE";
          if (navigator) {
            locale = navigator.language;
          }
          return number.toLocaleString(locale, { minimumFractionDigits: 0, maximumFractionDigits: 2 });
        } catch (e) {
          return number;
        }
      };
      exports.priceOn = (priceHistory, date) => {
        let startPrice = null;
        priceHistory.forEach((price) => {
          if (!startPrice && price.date <= date) {
            startPrice = price.price;
          }
        });
        if (startPrice == null) {
          const firstPrice = priceHistory[priceHistory.length - 1];
          startPrice = firstPrice.price;
        }
        return startPrice;
      };
      exports.unitPriceOn = (priceHistory, date) => {
        let startPrice = null;
        priceHistory.forEach((price) => {
          if (!startPrice && price.date <= date) {
            startPrice = price.unitPrice;
          }
        });
        if (startPrice == null) {
          const firstPrice = priceHistory[priceHistory.length - 1];
          startPrice = firstPrice.unitPrice;
        }
        return startPrice;
      };
      exports.uniqueDates = (items, startDate, endDate) => {
        const allDates = items.flatMap(
          (product) => product.priceHistory.filter((price) => price.date >= startDate && price.date <= endDate).map((item) => item.date)
        );
        let uniqueDates = new Set(allDates);
        uniqueDates.add(startDate);
        uniqueDates.add(endDate);
        uniqueDates = [...uniqueDates];
        uniqueDates.sort();
        return uniqueDates;
      };
      exports.calculateItemPriceTimeSeries = (product, percentageChange, startDate, uniqueDates) => {
        const getPrice = exports.unitPrice ? (o) => o.unitPrice : (o) => o.price;
        const priceScratch = new Array(uniqueDates.length);
        let startPrice = null;
        const priceHistoryLookup = {};
        priceScratch.fill(null);
        if (!product.priceHistoryLookup) {
          product.priceHistory.forEach((price) => {
            priceHistoryLookup[price.date] = price;
            if (!startPrice && price.date <= startDate) {
              startPrice = getPrice(price);
            }
          });
        }
        if (startPrice == null) {
          const firstPrice = product.priceHistory[product.priceHistory.length - 1];
          startPrice = getPrice(firstPrice);
        }
        for (let i = 0; i < uniqueDates.length; i++) {
          const priceObj = priceHistoryLookup[uniqueDates[i]];
          priceScratch[i] = priceObj ? getPrice(priceObj) : null;
        }
        for (let i = 0; i < priceScratch.length; i++) {
          if (priceScratch[i] == null) {
            priceScratch[i] = startPrice;
          } else {
            startPrice = priceScratch[i];
          }
        }
        if (priceScratch.some((price) => price == null)) {
          return null;
        }
        if (percentageChange) {
          const firstPrice = priceScratch.find((price) => price != 0);
          if (firstPrice == 0)
            return null;
          for (let i = 0; i < priceScratch.length; i++) {
            priceScratch[i] = (priceScratch[i] - firstPrice) / firstPrice * 100;
          }
        }
        if (priceScratch.some((price) => isNaN(price))) {
          return null;
        }
        return priceScratch;
      };
    }
  });

  // site/model/model.js
  var require_model = __commonJS({
    "site/model/model.js"(exports) {
      var Model = class {
        constructor() {
          this._listeners = [];
        }
        addListener(listener) {
          this._listeners.push(listener);
        }
        removeListener(listener) {
          const index = this._listeners.findIndex((item) => item === listener);
          if (index != -1)
            this._listeners.splice(index, 1);
        }
        notify(exclude) {
          for (const listener of this._listeners) {
            if (listener != exclude)
              listener();
          }
        }
      };
      exports.Model = Model;
    }
  });

  // site/model/carts.js
  var require_carts = __commonJS({
    "site/model/carts.js"(exports) {
      var misc = require_misc();
      var { Model } = require_model();
      var Carts = class extends Model {
        constructor() {
          super();
          this._carts = [];
        }
        get carts() {
          return this._carts;
        }
        async load(itemsLookup) {
          const val = localStorage.getItem("carts");
          let carts = this._carts = val ? JSON.parse(val) : [];
          if (!localStorage.getItem("updatedMomentum") || !carts.some((cart) => cart.name === "Momentum Eigenmarken Vergleich")) {
            localStorage.setItem("updatedMomentum", "true");
            const momentumCart = await misc.fetchJSON("data/momentum-cart.new.json");
            carts.unshift(momentumCart);
          }
          if (!localStorage.getItem("updatedKnnCarts")) {
            localStorage.setItem("updatedKnnCarts", "true");
            carts = this._carts = carts.filter((cart) => cart.name != "Markenprodukte Billa/Spar");
            carts = this._carts = carts.filter((cart) => cart.name != "Diskont-Marken Produkte Billa/Spar");
            carts = this._carts = carts.filter((cart) => cart.name != "Bio Eigenmarken Produkte Billa/Spar");
            carts = this._carts = carts.filter((cart) => cart.name != "Mittelpreisige Eigenmarken Produkte Billa/Spar");
          }
          if (!carts.some((cart) => cart.name == "Markenprodukte Billa/Spar")) {
            const billaSparCart = await misc.fetchJSON("data/billa-spar-cart.json");
            carts.unshift(billaSparCart);
          }
          if (!carts.some((cart) => cart.name == "Diskont-Marken Produkte Billa/Spar")) {
            const budgetCart = await misc.fetchJSON("data/budget-cart.json");
            carts.unshift(budgetCart);
          }
          if (!carts.some((cart) => cart.name == "Bio Eigenmarken Produkte Billa/Spar")) {
            const budgetCart = await misc.fetchJSON("data/bio-cart.json");
            carts.unshift(budgetCart);
          }
          if (!carts.some((cart) => cart.name == "Mittelpreisige Eigenmarken Produkte Billa/Spar")) {
            const budgetCart = await misc.fetchJSON("data/midrange-cart.json");
            carts.unshift(budgetCart);
          }
          for (const cart of carts) {
            const items = [];
            for (const cartItem of cart.items) {
              const item = itemsLookup[cartItem.store + cartItem.id];
              if (item)
                items.push(item);
            }
            cart.items = items;
          }
          this.save();
        }
        save() {
          const carts = [];
          for (const cart of this._carts) {
            carts.push({
              name: cart.name,
              items: cart.items.map((item) => {
                return { store: item.store, id: item.id };
              })
            });
          }
          localStorage.setItem("carts", JSON.stringify(carts, null, 2));
          this.notify();
        }
        add(name) {
          this._carts.push({ name, items: [] });
          this.save();
        }
        remove(name) {
          this._carts = this._carts.filter((cart) => cart.name !== name);
          this.save();
        }
      };
      exports.Carts = Carts;
    }
  });

  // site/model/settings.js
  var require_settings = __commonJS({
    "site/model/settings.js"(exports) {
      var { STORE_KEYS: STORE_KEYS2, stores } = require_stores();
      var { Model } = require_model();
      var { log } = require_misc();
      var Settings = class extends Model {
        constructor() {
          super();
          this.startDate = "2017-01-01";
          this.chartType = "stepped";
          STORE_KEYS2.forEach((store) => {
            this[store] = stores[store].defaultChecked;
          });
          this.onlyAvailable = true;
          this.stickyChart = false;
          this.stickySearch = false;
          let settings = localStorage.getItem("settings");
          if (settings) {
            settings = JSON.parse(settings);
            for (const prop of Object.getOwnPropertyNames(settings)) {
              this[prop] = settings[prop];
            }
          }
        }
        save() {
          const settings = {};
          for (const prop of Object.getOwnPropertyNames(this)) {
            if (prop.startsWith("_"))
              continue;
            settings[prop] = this[prop];
          }
          localStorage.setItem("settings", JSON.stringify(settings));
        }
      };
      exports.Settings = Settings;
    }
  });

  // site/model/items.js
  var require_items = __commonJS({
    "site/model/items.js"(exports) {
      var { Model } = require_model();
      var { STORE_KEYS: STORE_KEYS2 } = require_stores();
      var { Settings } = require_settings();
      var { log, deltaTime } = require_misc();
      var Items = class extends Model {
        constructor() {
          super();
          this._items = [];
          this._filteredItems = [];
          this._lookup = {};
        }
        get items() {
          return this._items;
        }
        get filteredItems() {
          return this._filteredItems;
        }
        set filteredItems(newItems) {
          this._filteredItems = newItems;
          this.notify();
        }
        get lookup() {
          return this._lookup;
        }
        async load(progress) {
          const settings = new Settings();
          let start = performance.now();
          const compressedItemsPerStore = [];
          for (const store of STORE_KEYS2) {
            compressedItemsPerStore.push(
              new Promise(async (resolve) => {
                let start2 = performance.now();
                try {
                  const response = await fetch(`data/latest-canonical.${store}.compressed.json`);
                  const json = await response.json();
                  log(`Loader - loading compressed items for ${store} took ${deltaTime(start2)} secs`);
                  start2 = performance.now();
                  let items2 = exports.decompress(json);
                  log(`Loader - Decompressing items for ${store} took ${deltaTime(start2)} secs`);
                  resolve(items2);
                } catch (e) {
                  log(`Loader - error while loading compressed items for ${store} ${e.message}`);
                  resolve([]);
                }
                if (progress)
                  progress();
              })
            );
          }
          let items = [].concat(...await Promise.all(compressedItemsPerStore));
          log(`Loader - loaded ${items.length} items took ${deltaTime(start).toFixed(4)} secs`);
          const result = this.processItems(items);
          log(`Loader - total loading took ${deltaTime(start).toFixed(4)} secs`);
          this._items = result.items.filter((item) => item.priceHistory.length > 0);
          this._lookup = result.lookup;
        }
        processItems(items) {
          const lookup = {};
          const start = performance.now();
          const interns = /* @__PURE__ */ new Map();
          const intern = (value) => {
            if (interns.has(value)) {
              return interns.get(value);
            } else {
              interns.set(value, value);
              return value;
            }
          };
          const getters = {
            unitPrice: {
              get() {
                const unitPriceFactor = this.unit == "g" || this.unit == "ml" ? 1e3 : 1;
                return this.price / this.quantity * unitPriceFactor;
              }
            },
            numPrices: {
              get() {
                return this.priceHistory.length;
              }
            },
            date: {
              get() {
                return this.priceHistory[0].date;
              }
            },
            priceOldest: {
              get() {
                return this.priceHistory[this.priceHistory.length - 1].price;
              }
            },
            dateOldest: {
              get() {
                return this.priceHistory[this.priceHistory.length - 1].date;
              }
            }
          };
          for (let i = 1; i <= 3; i++) {
            getters[`price${i}`] = {
              get() {
                return this.priceHistory[i] ? this.priceHistory[i].price : 0;
              }
            }, getters[`date${i}`] = {
              get() {
                return this.priceHistory[i] ? this.priceHistory[i].date : null;
              }
            };
          }
          items.forEach((item) => {
            lookup[item.store + item.id] = item;
            for (const getter in getters) {
              Object.defineProperty(item, getter, getters[getter]);
            }
            item.store = intern(item.store);
            item.id = intern(item.id);
            item.name = intern(item.name);
            item.category = intern(item.category);
            item.price = item.price;
            for (const price of item.priceHistory) {
              price.date = intern(price.date);
              price.price = price.price;
            }
            item.priceHistory = item.priceHistory.filter((price) => price.price > 0);
            item.unit = intern(item.unit);
            item.quantity = item.quantity;
            item.search = item.name + " " + item.quantity + " " + item.unit;
            item.search = intern(item.search.toLowerCase().replace(",", "."));
            const unitPriceFactor = item.unit == "g" || item.unit == "ml" ? 1e3 : 1;
            for (let i = 0; i < item.priceHistory.length; i++) {
              const price = item.priceHistory[i];
              price.unitPrice = price.price / item.quantity * unitPriceFactor;
            }
          });
          items.sort((a, b) => {
            if (a.store < b.store) {
              return -1;
            } else if (a.store > b.store) {
              return 1;
            }
            if (a.name < b.name) {
              return -1;
            } else if (a.name > b.name) {
              return 1;
            }
            return 0;
          });
          log(`Loader - processing ${items.length} items took ${deltaTime(start).toFixed(4)} secs`);
          return { items, lookup };
        }
      };
      exports.Items = Items;
      exports.decompress = (compressedItems) => {
        const storeLookup = compressedItems.stores;
        const data = compressedItems.data;
        const dates = compressedItems.dates;
        const numItems = compressedItems.n;
        const items = new Array(numItems);
        let i = 0;
        for (let l = 0; l < numItems; l++) {
          const store = storeLookup[data[i++]];
          const id = data[i++];
          const name = data[i++].replace("M & M", "M&M");
          const category = data[i++];
          const unavailable = data[i++] == 1;
          const numPrices = data[i++];
          const prices = new Array(numPrices);
          for (let j = 0; j < numPrices; j++) {
            const date = dates[data[i++]];
            const price = data[i++];
            prices[j] = {
              date: date.substring(0, 4) + "-" + date.substring(4, 6) + "-" + date.substring(6, 8),
              price
            };
          }
          const unit = data[i++];
          const quantity = data[i++];
          const isWeighted = data[i++] == 1;
          const bio = data[i++] == 1;
          const url = data[i++];
          items[l] = {
            store,
            id,
            name,
            category,
            unavailable,
            price: prices[0].price,
            priceHistory: prices,
            isWeighted,
            unit,
            quantity,
            bio,
            url
          };
        }
        return items;
      };
    }
  });

  // site/model/categories.js
  var require_categories = __commonJS({
    "site/model/categories.js"(exports, module) {
      exports.categories = [
        {
          name: "pecivo-1198"
        },
        {
          name: "grilovani-2094"
        },
        {
          name: "zpatky-do-skoly-2211"
        },
        {
          name: "ovoce-a-zelenina-1165"
        },
        {
          name: "chlazene-mlecne-a-rostlinne-vyrobky-1207"
        },
        {
          name: "maso-a-ryby-1263"
        },
        {
          name: "uzeniny-lahudky-a-hotova-jidla-1276"
        },
        {
          name: "mrazene-1307"
        },
        {
          name: "trvanlive-potraviny-1332"
        },
        {
          name: "cukrovinky-1449"
        },
        {
          name: "napoje-1474"
        },
        {
          name: "specialni-a-rostlinna-vyziva-1576"
        },
        {
          name: "pece-o-dite-1582"
        },
        {
          name: "drogerie-a-domacnost-1901"
        },
        {
          name: "mazlicci-1630"
        },
        {
          name: "billa-regionalne-1667"
        }
      ];
      exports.categories.forEach((category, index) => category.index = index);
      exports.toCategoryCode = (i, j) => {
        return (i < 10 ? "" + i : String.fromCharCode("A".charCodeAt(0) + (i - 10))) + (j < 10 ? "" + j : String.fromCharCode("A".charCodeAt(0) + (j - 10)));
      };
      exports.fromCategoryCode = (code) => {
        if (!code || code.length != 2)
          return [exports.categories.length - 1, 0];
        const codeI = code.charCodeAt(0);
        const codeJ = code.charCodeAt(1);
        return [
          codeI - (codeI < "A".charCodeAt(0) ? "0".charCodeAt(0) : "A".charCodeAt(0) - 10),
          codeJ - (codeJ < "A".charCodeAt(0) ? "0".charCodeAt(0) : "A".charCodeAt(0) - 10)
        ];
      };
      exports.isValidCode = (code) => {
        const [i, j] = exports.fromCategoryCode(code);
        if (i < 0 || i >= exports.categories.length)
          return false;
        const category = exports.categories[i];
        if (j < 0 || j >= exports.categories.subcategories)
          return false;
        return true;
      };
      exports.getCategory = (code) => {
        const [i, j] = exports.fromCategoryCode(code);
        return [exports.categories[i], exports.categories[i].subcategories[j]];
      };
      exports.UNKNOWN_CATEGORY = exports.toCategoryCode(exports.categories.length - 1, 0);
      if (__require.main === module) {
        const code = exports.toCategoryCode(10, 1);
        console.log(code);
        const [i, j] = exports.fromCategoryCode("A1");
        console.log(i + ", " + j);
        console.log(exports.isValidCode("F1"));
        console.log(exports.isValidCode("11"));
        console.log(exports.getCategory("A1"));
      }
    }
  });

  // site/model/index.js
  var require_model2 = __commonJS({
    "site/model/index.js"(exports) {
      var { Carts } = require_carts();
      var { Items } = require_items();
      var { Settings } = require_settings();
      exports.stores = require_stores();
      exports.categories = require_categories();
      exports.carts = new Carts();
      exports.items = new Items();
      exports.settings = new Settings();
      exports.load = async (progress) => {
        await exports.items.load(progress);
        await exports.carts.load(exports.items.lookup);
      };
    }
  });

  // site/views/view.js
  var require_view = __commonJS({
    "site/views/view.js"(exports) {
      var { getBooleanAttribute, log, isMobile } = require_misc();
      var View = class extends HTMLElement {
        constructor() {
          super();
          this._model = null;
          this._listener = () => this.render();
          this._disableChangeEvent = false;
        }
        static traverse(element, parents, filter, childrenProcessed) {
          if (!element)
            return;
          if (element.getAttribute("x-id")) {
            if (filter(parents, element))
              parents.push(element);
            else
              return;
          }
          const childNodes = element.childNodes;
          for (let i = 0; i < childNodes.length; i++) {
            const child = childNodes[i];
            if (child.nodeType === Node.ELEMENT_NODE) {
              View.traverse(child, parents, filter, childrenProcessed);
            }
          }
          if (parents.length > 0)
            parents.pop();
          childrenProcessed(parents, element);
        }
        static elements(view) {
          let elements = [...view.querySelectorAll("[x-id]")];
          elements = elements.filter((el) => {
            let parent = el.parentElement;
            while (parent != view) {
              if (parent instanceof View)
                return false;
              if (getBooleanAttribute(parent, "x-notraverse"))
                return false;
              parent = parent.parentElement;
            }
            return true;
          });
          const result = {};
          elements.forEach((element) => {
            if (result[element.getAttribute("x-id")]) {
              log(`View - Duplicate element x-id ${element.getAttribute("x-id")} in ${view.localName}`);
            }
            result[element.getAttribute("x-id")] = element;
          });
          return result;
        }
        get elements() {
          return View.elements(this);
        }
        set model(model2) {
          if (this._model)
            this._model.removeListener(this._listener);
          this._model = model2;
          this._model.addListener(this._listener);
          this.render();
        }
        get model() {
          return this._model;
        }
        static getStateProperty(element) {
          if (element instanceof HTMLInputElement) {
            if (element.type === "checkbox" || element.type === "radio") {
              return "checked";
            } else {
              return "value";
            }
          } else if (element instanceof HTMLOptionElement) {
            return "selected";
          } else if (element instanceof HTMLTextAreaElement || element instanceof HTMLSelectElement) {
            return "value";
          } else if (element.localName === "custom-checkbox") {
            return "checked";
          } else {
            return null;
          }
        }
        get state() {
          const elements = this.elements;
          const state = {};
          for (const key of Object.keys(elements)) {
            const element = elements[key];
            if (!element.hasAttribute("x-state"))
              continue;
            const property = View.getStateProperty(element);
            if (property == null) {
              log(`View.state() - Unknown state property for element ${element.getAttribute("x-id")} in ${this.localName}`);
              continue;
            }
            if (property in element) {
              state[key] = element[property];
            }
          }
          return state;
        }
        set state(state) {
          const elements = this.elements;
          this._disableChangeEvent = true;
          for (const key of Object.keys(state)) {
            const elementState = state[key];
            const element = elements[key];
            if (element) {
              const property = View.getStateProperty(element);
              element[property] = elementState;
            }
          }
          this._disableChangeEvent = false;
          this.fireChangeEvent();
        }
        get shareableState() {
          const state = this.state;
          const shareableState = Object.keys(state).sort().map((el) => {
            let value = state[el];
            if (value === true)
              value = ".";
            if (value === false)
              value = "-";
            return value;
          }).join(";");
          return shareableState;
        }
        set shareableState(shareableState) {
          const values = shareableState.split(";");
          const state = this.state;
          Object.keys(state).sort().forEach((el, index) => {
            if (values[index] === ".")
              state[el] = true;
            else if (values[index] === "-")
              state[el] = false;
            else
              state[el] = values[index];
          });
          this.state = state;
        }
        render() {
        }
        setupEventHandlers() {
          const handler = (event) => this.fireChangeEvent();
          const elements = this.elements;
          for (const key of Object.keys(elements)) {
            const element = elements[key];
            if (element._handlerSet)
              continue;
            if (element.hasAttribute("x-change")) {
              element.addEventListener("change", handler);
              element._handlerSet = true;
            }
            if (element.hasAttribute("x-click")) {
              element.addEventListener("click", handler);
              element._handlerSet = true;
            }
            if (element.hasAttribute("x-input")) {
              element.addEventListener("input", handler);
              element._handlerSet = true;
            }
            if (element.hasAttribute("x-input-debounce")) {
              const DEBOUNCE_MS = isMobile() ? 150 : 50;
              let timeoutId = 0;
              const debounceHandler = (event) => {
                clearTimeout(timeoutId);
                timeoutId = setTimeout(() => {
                  this.fireChangeEvent();
                }, DEBOUNCE_MS);
              };
              element.addEventListener("input", debounceHandler);
              element._handlerSet = true;
            }
          }
        }
        fireChangeEvent() {
          if (this._disableChangeEvent)
            return;
          const event = new CustomEvent("x-change", {
            bubbles: true,
            cancelable: true
          });
          this.dispatchEvent(event);
        }
      };
      exports.View = View;
    }
  });

  // site/views/custom-checkbox.js
  var require_custom_checkbox = __commonJS({
    "site/views/custom-checkbox.js"() {
      var { dom } = require_misc();
      var { View } = require_view();
      var CustomCheckbox = class extends View {
        constructor() {
          super();
          const isChecked = this.hasAttribute("checked") && (this.getAttribute("checked").length == 0 || this.getAttribute("checked") === "true");
          const label = this.hasAttribute("label") ? this.getAttribute("label") : "";
          const abbr = this.hasAttribute("abbr") ? this.getAttribute("abbr") : "";
          this.innerHTML = /*html*/
          `
            <label class="inline-flex items-center gap-x-1 cursor-pointer">
                <input x-id="checkbox" x-change type="checkbox" ${isChecked ? "checked" : ""} class="hidden peer">
                <svg class="h-2 w-2 stroke-gray-600 fill-gray-100 peer-checked:fill-gray-600" viewBox="0 0 6 6">
                    <circle cx="3" cy="3" r="2" />
                </svg>
                ${this.hasAttribute("abbr") ? `<abbr title="${abbr}"><span x-id="label">${label}</span></abbr>` : `<span x-id="label">${label}</span>`}
            </label>
        `;
          this.classList.add("customcheckbox");
          this._checkbox = View.elements(this).checkbox;
          this._checkbox.addEventListener("change", (event) => {
            event.stopPropagation();
            this.fireChangeEvent();
          });
        }
        get checkbox() {
          return this._checkbox;
        }
        get checked() {
          return this._checkbox.checked;
        }
        set checked(value) {
          this._checkbox.checked = value;
        }
        set label(value) {
          this.elements.label.innerText = value;
        }
      };
      customElements.define("custom-checkbox", CustomCheckbox);
    }
  });

  // locales/cs.json
  var require_cs = __commonJS({
    "locales/cs.json"(exports, module) {
      module.exports = {
        "Heisse Preise": "Hl\xEDda\u010D supermarket\u016F",
        page_description: "Nekomer\u010Dn\xED open source projekt umo\u017E\u0148uj\xEDc\xED spot\u0159ebitel\u016Fm naj\xEDt nejlevn\u011Bj\u0161\xED verzi produktu v obchodech.",
        Einstellungen: "Nastaven\xED",
        Impressum: "Imprint",
        Logs: "Logy",
        "Historische Daten von": "Historick\xE1 data od",
        "Alle Angaben ohne Gew\xE4hr, Irrt\xFCmer vorbehalten.": "Ve\u0161ker\xE9 informace jsou poskytov\xE1ny bez z\xE1ruky, chyby vyhrazeny.",
        "Markennamen und Warenzeichen sind Eigentum der jeweiligen Inhaber.": "N\xE1zvy zna\u010Dek a ochrann\xE9 zn\xE1mky jsou majetkem p\u0159\xEDslu\u0161n\xFDch vlastn\xEDk\u016F.",
        Suche: "Vyhled\xE1v\xE1n\xED",
        Preis\u00E4nderungen: "Zm\u011Bny cen",
        Warenk\u00F6rbe: "N\xE1kupn\xED voz\xEDky",
        "Noch keine Produkte im Warenkorb.": "N\xE1kupn\xED ko\u0161\xEDk je pr\xE1zdn\xFD.",
        "Produkte suchen und mit '+' zum Warenkorb hinzuf\xFCgen.": "Vyhledejte produkty a p\u0159idejte je do n\xE1kupn\xEDho ko\u0161\xEDku pomoc\xED '+'.",
        "Filtern...": "Filtr...",
        "(min. 3 Zeichen)": "(alespo\u0148 3 znaky)",
        "Produkt hinzuf\xFCgen...": "P\u0159idat produkt...",
        "Neuer Warenkorb": "Nov\xFD n\xE1kupn\xED ko\u0161\xEDk",
        Exportieren: "Export",
        Importieren: "Import",
        Medieninhaber: "Majitel",
        Kontakt: "Kontakt",
        Adresse: "Adresa",
        "Diese nicht-kommerzielle Seite dient KonsumentInnen dazu, Preise von Produkten im Lebensmittelhandel vergleichen zu k\xF6nnen.": "Tato nekomer\u010Dn\xED str\xE1nka umo\u017E\u0148uje spot\u0159ebitel\u016Fm porovn\xE1vat ceny produkt\u016F v obchod\u011B s potravinami.",
        "Video Anleitung": "Video instrukce (n\u011Bmecky)",
        "Text Anleitung": "Textov\xE9 instrukce (n\u011Bmecky)",
        Medienberichte: "Napsali o n\xE1s",
        Produktsuche: "Vyhled\xE1v\xE1n\xED produkt\u016F",
        "Radio & Fernsehen": "R\xE1dio & Televize",
        "Print & Online": "Tisk & Online",
        CartsList_Name: "N\xE1zev",
        CartsList_Produkte: "Produkt",
        CartsList_Preis: "Cena",
        CartsList_Preis\u00E4nderungen: "Zm\u011Bny cen",
        CartsList_Teilen: "Sd\xEDlet",
        CartsList_JSON: "JSON",
        CartsList_L\u00F6schen: "Smazat",
        "ItemsChart_Keine Daten ausgew\xE4hlt": "Nejsou vybr\xE1na \u017E\xE1dn\xE1 data",
        "ItemsChart_Preissumme Gesamt": "Celkov\xE1 cena",
        "ItemsChart_Preissumme Ketten": "Cena \u0159et\u011Bzce",
        "ItemsChart_Nur heutige Preise": "Cena dnes",
        "ItemsChart_\xC4nderung in % seit": "Zm\u011Bna v % od",
        "ItemsChart_\xC4nderung in % seit {{date}}": "Zm\u011Bna v % od {{date}}",
        "ItemsChart_Preissumme {{s}}": "Cena {{s}}",
        "ItemsFilter_Produkte suchen...": "Vyhled\xE1v\xE1n\xED produkt\u016F...",
        "ItemsFilter_Filter anzeigen/ausblenden": "Zobrazit/skr\xFDt filtry",
        ItemsFilter_Alle: "V\u0161e",
        ItemsFilter_Datum: "Datum",
        "ItemsFilter_Billiger seit letzter \xC4nderung": "Levn\u011Bj\u0161\xED od posledn\xED zm\u011Bny",
        "ItemsFilter_Nur Diskont-Eigenmarken": "Pouze priv\xE1tn\xED zna\u010Dky",
        "ItemsFilter_Nur Bio": "Pouze bio",
        "ItemsFilter_Exaktes Wort": "P\u0159esn\xE1 slova",
        "ItemsFilter_Preis \u20AC": "Cena K\u010D",
        ItemsFilter_Teurer: "Dra\u017E\u0161\xED",
        ItemsFilter_Billiger: "Levn\u011Bj\u0161\xED",
        ItemsList_Resultate: "V\xFDsledky",
        ItemsList_Diagramm: "Graf",
        ItemsList_Verkaufspreis: "Prodejn\xED cena",
        ItemsList_Mengenpreis: "M\u011Brn\xE1 cena",
        ItemsList_Sortieren: "Se\u0159adit podle",
        "ItemsList_Preis aufsteigend": "Cena vzestupn\u011B",
        "ItemsList_Preis absteigend": "Cena sestupn\u011B",
        "ItemsList_Menge aufsteigend": "Mno\u017Estv\xED vzsetupn\u011B",
        "ItemsList_Menge absteigend": "Mno\u017Estv\xED sestupn\u011B",
        "ItemsList_Kette &amp; Name": "\u0158et\u011Bzec &amp; n\xE1zev",
        ItemsList_Namens\u00E4hnlichkeit: "Podobnost jm\xE9na",
        ItemsList_Kette: "\u0158et\u011Bzec",
        ItemsList_Name: "N\xE1zev",
        ItemsList_Preis: "Cena",
        Cart_Teilen: "Detail",
        Cart_Speichern: "Ulo\u017Eit",
        "Cart_Warenkorb {{name}}": "N\xE1kupn\xED ko\u0161\xEDk {{name}}",
        "Cart_Warenkorb '{{name}}' existiert bereits. Bitte einen anderen Namen f\xFCr den zu speichernden Warenkorb eingeben": "N\xE1kupn\xED ko\u0161\xEDk '{{name}}' ji\u017E existuje. Zadejte pros\xEDm jin\xFD n\xE1zev",
        "Cart_Warenkorb '{{name}}' existiert nicht.": "N\xE1kupn\xED ko\u0161\xEDk '{{name}}' neexistuje.",
        Cart_Artikel: "Polo\u017Eka",
        "Carts_Name f\xFCr Warenkorb eingeben:": "Zadejte n\xE1zev n\xE1kupn\xEDho ko\u0161\xEDku:",
        "Carts_Warenkorb mit Namen '{{name}}' existiert bereits": "N\xE1kupn\xED ko\u0161\xEDk se jm\xE9nem '{{name}}' ji\u017E existuje",
        "Carts_Warenkorb '{{name}}' existiert bereits. Bitte einen anderen Namen f\xFCr den zu importierenden Warenkorb eingeben": "N\xE1kupn\xED ko\u0161\xEDk '{{name}}' ji\u017E existuje. Zadejte pros\xEDm jin\xFD n\xE1zev pod kter\xFD se n\xE1kupn\xED ko\u0161\xEDk importuje",
        "Settings_Vorselektierte Ketten": "P\u0159edvybran\xE9 \u0159et\u011Bzce",
        "Settings_Start-Datum f\xFCr Diagramme": "Po\u010D\xE1te\u010Dn\xED datum pro grafy",
        "Settings_Diagramm Typ": "Typ grafu",
        Settings_Stufen: "Schodov\xFD",
        Settings_Linien: "\u010C\xE1rov\xFD",
        "Settings_Nur verf\xFCgbare Produkte anzeigen": "Zobrazit pouze dostupn\xE9 produkty",
        "Settings_Diagramm immer anzeigen (wenn verf\xFCgbar)": "V\u017Edy zobrazovat graf (pokud je k dispozici)",
        "Settings_Suche immer anzeigen (wenn verf\xFCgbar)": "V\u017Edy zobrazit vyhled\xE1v\xE1n\xED (je-li k dispozici)"
      };
    }
  });

  // locales/de.json
  var require_de = __commonJS({
    "locales/de.json"(exports, module) {
      module.exports = {
        "Heisse Preise": "Heisse Preise",
        page_description: "Nicht-kommerzielles Open-Source-Projekt um KonsumentInnen es zu erm\xF6glichen, die g\xFCnstigste Variante eines Produktes im Handel ausfindig zu machen.",
        Einstellungen: "Einstellungen",
        Impressum: "Impressum",
        Logs: "Logs",
        "Historische Daten von": "Historische Daten von",
        "Alle Angaben ohne Gew\xE4hr, Irrt\xFCmer vorbehalten.": "Alle Angaben ohne Gew\xE4hr, Irrt\xFCmer vorbehalten.",
        "Markennamen und Warenzeichen sind Eigentum der jeweiligen Inhaber.": "Markennamen und Warenzeichen sind Eigentum der jeweiligen Inhaber.",
        Suche: "Suche",
        Preis\u00E4nderungen: "Preis\xE4nderungen",
        Warenk\u00F6rbe: "Warenk\xF6rbe",
        "Noch keine Produkte im Warenkorb.": "Noch keine Produkte im Warenkorb.",
        "Produkte suchen und mit '+' zum Warenkorb hinzuf\xFCgen.": "Produkte suchen und mit '+' zum Warenkorb hinzuf\xFCgen.",
        "Filtern...": "Filtern...",
        "(min. 3 Zeichen)": "(min. 3 Zeichen)",
        "Produkt hinzuf\xFCgen...": "Produkt hinzuf\xFCgen...",
        "Neuer Warenkorb": "Neuer Warenkorb",
        Exportieren: "Exportieren",
        Importieren: "Importieren",
        Medieninhaber: "Medieninhaber",
        Kontakt: "Kontakt",
        Adresse: "Adresse",
        "Diese nicht-kommerzielle Seite dient KonsumentInnen dazu, Preise von Produkten im Lebensmittelhandel vergleichen zu k\xF6nnen.": "Diese nicht-kommerzielle Seite dient KonsumentInnen dazu, Preise von Produkten im Lebensmittelhandel vergleichen zu k\xF6nnen.",
        "Video Anleitung": "Video Anleitung",
        "Text Anleitung": "Text Anleitung",
        Medienberichte: "Medienberichte",
        Produktsuche: "Produktsuche",
        "Radio & Fernsehen": "Radio & Fernsehen",
        "Print & Online": "Print & Online",
        CartsList_Name: "Name",
        CartsList_Produkte: "Produkte",
        CartsList_Preis: "Preis",
        CartsList_Preis\u00E4nderungen: "Preis\xE4nderungen",
        CartsList_Teilen: "Teilen",
        CartsList_JSON: "JSON",
        CartsList_L\u00F6schen: "L\xF6schen",
        "ItemsChart_Keine Daten ausgew\xE4hlt": "Keine Daten ausgew\xE4hlt",
        "ItemsChart_Preissumme Gesamt": "Preissumme Gesamt",
        "ItemsChart_Preissumme Ketten": "Preissumme Ketten",
        "ItemsChart_Nur heutige Preise": "Nur heutige Preise",
        "ItemsChart_\xC4nderung in % seit": "\xC4nderung in % seit",
        "ItemsChart_\xC4nderung in % seit {{date}}": "\xC4nderung in % seit {{date}}",
        "ItemsChart_Preissumme {{s}}": "Preissumme {{s}}",
        "ItemsFilter_Produkte suchen...": "Produkte suchen...",
        "ItemsFilter_Filter anzeigen/ausblenden": "Filter anzeigen/ausblenden",
        ItemsFilter_Alle: "Alle",
        ItemsFilter_Datum: "Datum",
        "ItemsFilter_Billiger seit letzter \xC4nderung": "Billiger seit letzter \xC4nderung",
        "ItemsFilter_Nur Diskont-Eigenmarken": "Nur Diskont-Eigenmarken",
        "ItemsFilter_Nur Bio": "Nur Bio",
        "ItemsFilter_Exaktes Wort": "Exaktes Wort",
        "ItemsFilter_Preis \u20AC": "Preis \u20AC",
        ItemsFilter_Teurer: "Teurer",
        ItemsFilter_Billiger: "Billiger",
        ItemsList_Resultate: "Resultate",
        ItemsList_Diagramm: "Diagramm",
        ItemsList_Verkaufspreis: "Verkaufspreis",
        ItemsList_Mengenpreis: "Mengenpreis",
        ItemsList_Sortieren: "Sortieren",
        "ItemsList_Preis aufsteigend": "Preis aufsteigend",
        "ItemsList_Preis absteigend": "Preis absteigend",
        "ItemsList_Menge aufsteigend": "Menge aufsteigend",
        "ItemsList_Menge absteigend": "Menge absteigend",
        "ItemsList_Kette &amp; Name": "Kette &amp; Name",
        ItemsList_Namens\u00E4hnlichkeit: "Namens\xE4hnlichkeit",
        ItemsList_Kette: "Kette",
        ItemsList_Name: "Name",
        ItemsList_Preis: "Preis",
        Cart_Teilen: "Teilen",
        Cart_Speichern: "Speichern",
        "Cart_Warenkorb {{name}}": "Warenkorb {{name}}",
        "Cart_Warenkorb '{{name}}' existiert bereits. Bitte einen anderen Namen f\xFCr den zu speichernden Warenkorb eingeben": "Warenkorb '{{name}}' existiert bereits. Bitte einen anderen Namen f\xFCr den zu speichernden Warenkorb eingeben",
        "Cart_Warenkorb '{{name}}' existiert nicht.": "Warenkorb '{{name}}' existiert nicht.",
        Cart_Artikel: "Artikel",
        "Carts_Name f\xFCr Warenkorb eingeben:": "Name f\xFCr Warenkorb eingeben:",
        "Carts_Warenkorb mit Namen '{{name}}' existiert bereits": "Warenkorb mit Namen '{{name}}' existiert bereits",
        "Carts_Warenkorb '{{name}}' existiert bereits. Bitte einen anderen Namen f\xFCr den zu importierenden Warenkorb eingeben": "Warenkorb '{{name}}' existiert bereits. Bitte einen anderen Namen f\xFCr den zu importierenden Warenkorb eingeben",
        "Settings_Vorselektierte Ketten": "Vorselektierte Ketten",
        "Settings_Start-Datum f\xFCr Diagramme": "Start-Datum f\xFCr Diagramme",
        "Settings_Diagramm Typ": "Diagramm Typ",
        Settings_Stufen: "Stufen",
        Settings_Linien: "Linien",
        "Settings_Nur verf\xFCgbare Produkte anzeigen": "Nur verf\xFCgbare Produkte anzeigen",
        "Settings_Diagramm immer anzeigen (wenn verf\xFCgbar)": "Diagramm immer anzeigen (wenn verf\xFCgbar)",
        "Settings_Suche immer anzeigen (wenn verf\xFCgbar)": "Suche immer anzeigen (wenn verf\xFCgbar)"
      };
    }
  });

  // locales/en.json
  var require_en = __commonJS({
    "locales/en.json"(exports, module) {
      module.exports = {
        "Heisse Preise": "Hot Prices",
        page_description: "Non-commercial open source project to enable consumers to find the cheapest version of a product in stores.",
        Einstellungen: "Settings",
        Impressum: "Imprint",
        Logs: "Logs",
        "Historische Daten von": "Historic data from",
        "Alle Angaben ohne Gew\xE4hr, Irrt\xFCmer vorbehalten.": "All information provided without guarantee, errors excepted.",
        "Markennamen und Warenzeichen sind Eigentum der jeweiligen Inhaber.": "Brand names and trademarks are the property of their respective owners.",
        Suche: "Search",
        Preis\u00E4nderungen: "Price changes",
        Warenk\u00F6rbe: "Shopping carts",
        "Noch keine Produkte im Warenkorb.": "No products in your shopping cart yet.",
        "Produkte suchen und mit '+' zum Warenkorb hinzuf\xFCgen.": "Search for products and add them to the shopping cart with '+'.",
        "Filtern...": "Filter...",
        "(min. 3 Zeichen)": "(at least 3 characters)",
        "Produkt hinzuf\xFCgen...": "Add product...",
        "Neuer Warenkorb": "New shopping cart",
        Exportieren: "Export",
        Importieren: "Import",
        Medieninhaber: "Owner",
        Kontakt: "Contact",
        Adresse: "Address",
        "Diese nicht-kommerzielle Seite dient KonsumentInnen dazu, Preise von Produkten im Lebensmittelhandel vergleichen zu k\xF6nnen.": "This non-commercial site allows consumers to compare prices of products in the grocery store.",
        "Video Anleitung": "Video instructions (in German)",
        "Text Anleitung": "Text instructions (in German)",
        Medienberichte: "Media reports",
        Produktsuche: "Product search",
        "Radio & Fernsehen": "Radio & Television",
        "Print & Online": "Print & Online",
        CartsList_Name: "Name",
        CartsList_Produkte: "Product",
        CartsList_Preis: "Price",
        CartsList_Preis\u00E4nderungen: "Price changes",
        CartsList_Teilen: "Share",
        CartsList_JSON: "JSON",
        CartsList_L\u00F6schen: "Delete",
        "ItemsChart_Keine Daten ausgew\xE4hlt": "No data selected",
        "ItemsChart_Preissumme Gesamt": "Total price",
        "ItemsChart_Preissumme Ketten": "Store price",
        "ItemsChart_Nur heutige Preise": "Price today",
        "ItemsChart_\xC4nderung in % seit": "Change in % since",
        "ItemsChart_\xC4nderung in % seit {{date}}": "Change in % since {{date}}",
        "ItemsChart_Preissumme {{s}}": "Price {{s}}",
        "ItemsFilter_Produkte suchen...": "Product search...",
        "ItemsFilter_Filter anzeigen/ausblenden": "Show/hide filters",
        ItemsFilter_Alle: "All",
        ItemsFilter_Datum: "Date",
        "ItemsFilter_Billiger seit letzter \xC4nderung": "Cheaper since last change",
        "ItemsFilter_Nur Diskont-Eigenmarken": "Discount store brands only",
        "ItemsFilter_Nur Bio": "Only bio",
        "ItemsFilter_Exaktes Wort": "Exact word",
        "ItemsFilter_Preis \u20AC": "Price \u20AC",
        ItemsFilter_Teurer: "More expensive",
        ItemsFilter_Billiger: "Cheaper",
        ItemsList_Resultate: "Results",
        ItemsList_Diagramm: "Chart",
        ItemsList_Verkaufspreis: "Unit price",
        ItemsList_Mengenpreis: "Bulk price",
        ItemsList_Sortieren: "Sort by",
        "ItemsList_Preis aufsteigend": "Price ascending",
        "ItemsList_Preis absteigend": "Price descending",
        "ItemsList_Menge aufsteigend": "Quantity ascending",
        "ItemsList_Menge absteigend": "Quantity descending",
        "ItemsList_Kette &amp; Name": "Store chain &amp; name",
        ItemsList_Namens\u00E4hnlichkeit: "Name similarity",
        ItemsList_Kette: "Store chain",
        ItemsList_Name: "Name",
        ItemsList_Preis: "Price",
        Cart_Teilen: "Detail",
        Cart_Speichern: "Save",
        "Cart_Warenkorb {{name}}": "Shopping cart {{name}}",
        "Cart_Warenkorb '{{name}}' existiert bereits. Bitte einen anderen Namen f\xFCr den zu speichernden Warenkorb eingeben": "Shopping cart '{{name}}' already exists. Please enter a different name for the shopping cart to be saved",
        "Cart_Warenkorb '{{name}}' existiert nicht.": "Shopping cart '{{name}}' does not exist.",
        Cart_Artikel: "Item",
        "Carts_Name f\xFCr Warenkorb eingeben:": "Enter name for shopping cart:",
        "Carts_Warenkorb mit Namen '{{name}}' existiert bereits": "Shopping cart with name '{{name}}' already exists",
        "Carts_Warenkorb '{{name}}' existiert bereits. Bitte einen anderen Namen f\xFCr den zu importierenden Warenkorb eingeben": "Shopping cart '{{name}}' already exists. Please enter a different name for the shopping cart to be imported",
        "Settings_Vorselektierte Ketten": "Pre-selected store chains",
        "Settings_Start-Datum f\xFCr Diagramme": "Start date for charts",
        "Settings_Diagramm Typ": "Chart type",
        Settings_Stufen: "Stepped",
        Settings_Linien: "Lines",
        "Settings_Nur verf\xFCgbare Produkte anzeigen": "Show only available products",
        "Settings_Diagramm immer anzeigen (wenn verf\xFCgbar)": "Always show chart (when available)",
        "Settings_Suche immer anzeigen (wenn verf\xFCgbar)": "Always show search (when available)"
      };
    }
  });

  // i18n.js
  var require_i18n = __commonJS({
    "i18n.js"(exports) {
      var translations = {
        // sorted alphabetically
        cs: require_cs(),
        de: require_de(),
        en: require_en()
      };
      var locales = Object.keys(translations);
      var defaultLocale = "de";
      function translateWithLocale(locale, key, args) {
        let translation = translations[locale][key];
        if (translation === void 0) {
          console.error("Untranslated key in ", locale, ": ", key);
          if (locale != defaultLocale) {
            translation = translations[defaultLocale][key] || key;
          } else {
            translation = key;
          }
        }
        if (typeof args === "object") {
          for (const arg in args) {
            translation = translation.replaceAll("{{" + arg + "}}", args[arg]);
          }
        }
        return translation;
      }
      exports.defaultLocale = defaultLocale;
      exports.locales = locales;
      exports.translateWithLocale = translateWithLocale;
    }
  });

  // site/browser_i18n.js
  var require_browser_i18n = __commonJS({
    "site/browser_i18n.js"(exports) {
      var i18n = require_i18n();
      var currentLocale = i18n.defaultLocale;
      function setLocale(locale) {
        if (i18n.locales.includes(locale)) {
          console.log("Locale changed to " + locale);
          currentLocale = locale;
          return true;
        }
        console.error("Attempted to setLocale to unsupported language: ", locale);
        return false;
      }
      function translate(key, args) {
        return i18n.translateWithLocale(currentLocale, key, args);
      }
      for (const langCode of navigator.languages) {
        let lang = langCode.length >= 2 ? langCode.substring(0, 2) : null;
        if (lang == null)
          continue;
        if (i18n.locales.includes(lang)) {
          setLocale(lang);
          break;
        }
      }
      exports.__ = translate;
    }
  });

  // site/views/carts-list.js
  var require_carts_list = __commonJS({
    "site/views/carts-list.js"() {
      var { downloadJSON: downloadJSON2, dom } = require_misc();
      var { View } = require_view();
      var { __: __2 } = require_browser_i18n();
      var CartsList = class extends View {
        constructor() {
          super();
          this.innerHTML = /*html*/
          `
            <table class="w-full">
                <thead>
                    <tr class="bg-primary text-left hidden md:table-row uppercase text-sm text-white">
                        <th class="px-2">${__2("CartsList_Name")}</th>
                        <th class="px-2">${__2("CartsList_Produkte")}</th>
                        <th class="px-2">${__2("CartsList_Preis")}</th>
                        <th class="px-2"></th>
                    </tr>
                </thead>
                <tbody x-id="tableBody">
                </tbody>
            </table>
        `;
          this._cartTemplate = dom(
            "tr",
            /*html*/
            `
            <td class="px-2 col-span-3">
                <a x-id="name" class="hover:underline"></a>
            </td>
            <td class="px-2">
                <span class="md:hidden text-sm">${__2("CartsList_Produkte")}: </span>
                <span x-id="numProducts"></span>
            </td>
            <td class="px-2 col-span-2">
                <span class="md:hidden text-sm">${__2("CartsList_Preis\xE4nderungen")}: </span>
                <span x-id="price"></span>
            </td>
            <td class="px-2 col-span-3">
                <div class="flex gap-4">
                    <a x-id="share" class="text-primary hover:underline text-sm font-medium">${__2("CartsList_Teilen")}</a>
                    <a x-id="json" class="text-primary hover:underline text-sm font-medium" href="">${__2("CartsList_JSON")}</a>
                    <input x-id="delete" class="ml-auto text-red-500 hover:underline text-sm font-medium" type="button" value="${__2(
              "CartsList_L\xF6schen"
            )}">
                </div>
            </td>
        `
          );
          this._cartTemplate.setAttribute("class", "grid grid-cols-3 hover:bg-gray-100 border border-gray-200 rounded-md p-2 md:table-row");
        }
        render() {
          const model2 = this._model;
          const tableBody = this.elements.tableBody;
          tableBody.innerHTML = "";
          for (const cart of model2.carts) {
            let oldPrice = 0;
            let currPrice = 0;
            let shareLink = "cart.html?cart=" + encodeURIComponent(cart.name) + ";";
            for (const item of cart.items) {
              oldPrice += item.priceHistory[item.priceHistory.length - 1].price;
              currPrice += item.priceHistory[0].price;
              shareLink += item.store + item.id + ";";
            }
            const increase = oldPrice != 0 ? Math.round((currPrice - oldPrice) / oldPrice * 100) : 0;
            const cartUrl = `cart.html?name=${encodeURIComponent(cart.name)}`;
            const cartListItem = this._cartTemplate.cloneNode(true);
            const elements = View.elements(cartListItem);
            elements.name.href = cartUrl;
            elements.name.innerText = cart.name;
            elements.numProducts.innerText = cart.items.length;
            elements.price.innerText = `${currPrice.toFixed(2)} ${(increase > 0 ? "+" : "") + increase + "%"}`;
            elements.price.style.color = currPrice > oldPrice ? "red" : "green";
            elements.share.href = shareLink;
            elements.json.addEventListener("click", (event) => {
              event.preventDefault();
              downloadJSON2(cart.name + ".json", cart);
            });
            if (cart.name === "Momentum Eigenmarken Vergleich") {
              elements.delete.classList.add("hidden");
            } else {
              elements.delete.addEventListener("click", () => model2.remove(cart.name));
            }
            tableBody.append(cartListItem);
          }
        }
      };
      customElements.define("carts-list", CartsList);
    }
  });

  // site/views/items-filter.js
  var require_items_filter = __commonJS({
    "site/views/items-filter.js"() {
      var { today: today2, parseNumber, dom, getBooleanAttribute, queryItems, queryItemsAlasql, log, deltaTime } = require_misc();
      var { stores, STORE_KEYS: STORE_KEYS2, BUDGET_BRANDS } = require_stores();
      var { fromCategoryCode, categories } = require_categories();
      var { settings } = require_model2();
      var { View } = require_view();
      var { __: __2 } = require_browser_i18n();
      var ItemsFilter = class extends View {
        constructor() {
          super();
          this._emptyQuery = getBooleanAttribute(this, "emptyquery");
          this._filterByPriceChanges = getBooleanAttribute(this, "pricechanges");
          this._filterByPriceDirection = getBooleanAttribute(this, "pricedirection");
          this._filterByStores = getBooleanAttribute(this, "stores");
          this._filterByMisc = getBooleanAttribute(this, "misc");
          this._noChartClear = getBooleanAttribute(this, "nochartclear");
          this._availableOption = getBooleanAttribute(this, "availableoption");
          const hidePriceChanges = this._filterByPriceChanges ? "" : "hidden";
          const hidePriceDirection = this._filterByPriceDirection ? "" : "hidden";
          const hideStores = this._filterByStores ? "" : "hidden";
          const hideMisc = this._filterByMisc ? "" : "hidden";
          const hideAvailableObption = this._availableOption ? "" : "hidden";
          const placeholder = this.hasAttribute("placeholder") ? this.getAttribute("placeholder") : __2("ItemsFilter_Produkte suchen...") + " " + __2("(min. 3 Zeichen)");
          this.innerHTML = /*html*/
          `
            ${settings.stickySearch ? `
            <div class="wrapper wrapper--search">
                <input x-id="query" x-state x-input-debounce class="rounded-lg px-2 py-1 w-full" type="text" placeholder="${placeholder}" />
                <label for="filter-toggle-search"><abbr title="${__2("ItemsFilter_Filter anzeigen/ausblenden")}">\u{1F39A}</abbr></label>
            </div>
            <input class="toggle toggle--hidden" type="checkbox" id="filter-toggle-search" />
            <div class="wrapper wrapper--sticky">
            ` : `
            <input x-id="query" x-state x-input-debounce class="rounded-lg px-2 py-1 w-full" type="text" placeholder="${placeholder}" />
            `}

            <div x-id="sqlError" class="hidden mt-4 p-4">
            </div>

            <div x-id="stores" class="flex justify-center gap-2 flex-wrap mt-4 ${hideStores}">
                <custom-checkbox x-id="allStores" label="${__2("ItemsFilter_Alle")}" ${Object.values(stores).every((store) => store.defaultChecked) ? "checked" : ""}></custom-checkbox>
                ${STORE_KEYS2.map(
            (store) => (
              /*html*/
              `
                        <custom-checkbox
                            x-id="${store}" x-state x-change
                            label="${stores[store].name}"
                            class="${stores[store].color}"
                            ${settings[store] ? "checked" : ""}
                        ></custom-checkbox>`
            )
          ).join("")}
            </div>

            <div x-id="priceChanges" class="text-sm flex justify-center gap-4 mt-4 ${hidePriceChanges}">
                <label>
                    <input x-id="priceChangesToday" x-state type="radio" name="type" checked /> ${__2("ItemsFilter_Datum")}
                    <select x-id="priceChangesDate" x-state x-change class="bg-white rounded-full">
                        <option>${today2()}</option>
                    </select>
                </label>
                <label>
                    <input x-id="priceChangesCheaper" x-state type="radio" name="type" /> ${__2("ItemsFilter_Billiger seit letzter \xC4nderung")}
                </label>
            </div>

            <div x-id="misc" class="flex items-center justify-center flex-wrap gap-2 mt-4 ${hideMisc}">
                <custom-checkbox
                    x-id="budgetBrands" x-state x-change
                    label="${__2("ItemsFilter_Nur Diskont-Eigenmarken")}"
                    abbr="${BUDGET_BRANDS.map((budgetBrand) => budgetBrand.toUpperCase()).join(", ")}"
                ></custom-checkbox>
                <custom-checkbox x-id="bio" x-state x-change label="${__2("ItemsFilter_Nur Bio")}"></custom-checkbox>
                <custom-checkbox x-id="exact" x-state x-change label="${__2("ItemsFilter_Exaktes Wort")}"></custom-checkbox>
                <label class="cursor-pointer inline-flex items-center gap-x-1 rounded-full bg-white border border-gray-400 px-2 py-1 text-xs font-medium text-gray-600">
                ${__2("ItemsFilter_Preis \u20AC")} <input x-id="minPrice" x-state x-input class="w-12" type="number" min="0" value="0">
                    -
                    <input x-id="maxPrice" x-state x-input-debounce class="w-12" type="number" min="0" value="100">
                </label>
            </div>

            <div x-id="priceDirection" class="flex justify-center gap-2 mt-4 ${this._hideMisc ? "" : "mb-4"} ${hidePriceDirection}">
                <custom-checkbox x-id="priceIncreased" x-state x-change label="${__2("ItemsFilter_Teurer")}" checked class="gray"></custom-checkbox>
                <custom-checkbox x-id="priceDecreased" x-state x-change label="${__2("ItemsFilter_Billiger")}" checked class="gray"></custom-checkbox>
            </div>

            <div x-id="categories" class="flex justify-center gap-2 flex-wrap mt-4 hidden">
                    ${categories.map(
            (category, index) => (
              /*html*/
              `
                        <custom-checkbox
                            x-id="category-${index}" x-state x-change
                            label="${category.name}"
                            class="indigo"
                        ></custom-checkbox>`
            )
          ).join("")}
            </div>
            ${settings.stickySearch ? `
            </div>
            ` : ""}
        `;
          this.classList.add("items-filter");
          if (settings.stickySearch) {
            this.classList.add("sticky");
            this.style = "top: -1px;z-index:20;";
          }
          const elements = this.elements;
          elements.query.addEventListener("input", () => {
            let query = elements.query.value.trim();
            if (query.length > 0 && query.charAt(0) == "!") {
              elements.stores.classList.add("hidden");
              elements.misc.classList.add("hidden");
            } else {
              if (!hideStores)
                elements.stores.classList.remove("hidden");
              if (!hideMisc)
                elements.misc.classList.remove("hidden");
            }
          });
          const handleChangeAll = () => {
            const checked = elements.allStores.checked;
            STORE_KEYS2.forEach((store) => elements[store].checked = checked);
            this.fireChangeEvent();
          };
          const storeElements = STORE_KEYS2.map((store) => elements[store]);
          storeElements.forEach(
            (store) => store.addEventListener("change", () => {
              const allChecked = storeElements.every((store2) => store2.checked);
              elements.allStores.removeEventListener("change", handleChangeAll);
              elements.allStores.checked = allChecked;
              elements.allStores.addEventListener("change", handleChangeAll);
            })
          );
          elements.allStores.addEventListener("x-change", handleChangeAll);
          elements.priceChangesToday.addEventListener("change", () => {
            this.fireChangeEvent();
          });
          elements.priceChangesCheaper.addEventListener("change", () => {
            this.fireChangeEvent();
          });
          this.setupEventHandlers();
          this.addEventListener("x-change", () => {
            this.filter();
          });
        }
        setVisibility(query, numCategories, elements) {
          if (query.length > 0 && query.charAt(0) == "!") {
            elements.stores.classList.add("hidden");
            elements.priceChanges.classList.add("hidden");
            elements.misc.classList.add("hidden");
            elements.priceDirection.classList.add("hidden");
            elements.categories.classList.add("hidden");
          } else {
            if (this._filterByStores)
              elements.stores.classList.remove("hidden");
            if (this._filterByPriceChanges)
              elements.priceChanges.classList.remove("hidden");
            if (this._filterByMisc)
              elements.misc.classList.remove("hidden");
            if (this._filterByPriceDirection) {
              if (elements.priceChangesToday.checked)
                elements.priceDirection.classList.remove("hidden");
              else
                elements.priceDirection.classList.add("hidden");
            }
            if (this.model.filteredItems.length > 0 && numCategories != 0) {
              elements.categories.classList.remove("hidden");
            } else {
              elements.categories.classList.add("hidden");
            }
          }
        }
        filter() {
          if (!this.model)
            return;
          const start = performance.now();
          const elements = this.elements;
          elements.sqlError.classList.add("hidden");
          this.model.totalItems = this.model.items.length;
          let filteredItems = new Array(this.model.items.length);
          for (let i = 0; i < this.model.items.length; i++) {
            filteredItems[i] = this.model.items[i];
          }
          let query = elements.query.value.trim();
          if (query.length == 0 && this._emptyQuery) {
            this.setVisibility(query, 0, elements);
            this.model.removeListener(this._listener);
            this.model.filteredItems = [];
            this.model.addListener(this._listener);
            return;
          }
          this.model.lastDate = null;
          if (this._filterByPriceChanges) {
            if (elements.priceChangesToday.checked) {
              const today3 = elements.priceChangesDate.value;
              this.model.priceChangesToday = today3;
              filteredItems = filteredItems.filter((item) => {
                if (item.priceHistory.length == 1)
                  return false;
                for (let i = 0; i < item.priceHistory.length; i++) {
                  if (item.priceHistory[i].date === today3 && i + 1 < item.priceHistory.length) {
                    return true;
                  }
                }
                return false;
              });
            } else {
              filteredItems = filteredItems.filter((item) => {
                if (item.priceHistory.length == 1)
                  return false;
                return item.priceHistory[0].price < item.priceHistory[1].price;
              });
            }
            this.model.totalItems = filteredItems.length;
          }
          if (this._filterByPriceDirection) {
            const increased = elements.priceIncreased.checked;
            const decreased = elements.priceDecreased.checked;
            filteredItems = filteredItems.filter((item) => {
              if (item.priceHistory.length == 1)
                return false;
              if (this._filterByPriceChanges && elements.priceChangesToday.checked) {
                const today3 = elements.priceChangesDate.value;
                for (let i = 0; i < item.priceHistory.length; i++) {
                  if (item.priceHistory[i].date == today3 && i + 1 < item.priceHistory.length) {
                    if (increased && item.priceHistory[i].price > item.priceHistory[i + 1].price) {
                      return true;
                    }
                    if (decreased && item.priceHistory[i].price < item.priceHistory[i + 1].price) {
                      return true;
                    }
                  }
                }
              } else {
                if (increased && item.priceHistory[0].price > item.priceHistory[1].price)
                  return true;
                if (decreased && item.priceHistory[0].price < item.priceHistory[1].price)
                  return true;
              }
              return false;
            });
          }
          if (query.charAt(0) != "!") {
            if (this._filterByStores) {
              filteredItems = filteredItems.filter((item) => elements[item.store].checked);
            }
            if (this._filterByMisc) {
              const budgetBrands = elements.budgetBrands.checked;
              const bio = elements.bio.checked;
              const minPrice = parseNumber(elements.minPrice.value, 0);
              const maxPrice = parseNumber(elements.maxPrice.value, 100);
              filteredItems = filteredItems.filter((item) => {
                if (budgetBrands && !BUDGET_BRANDS.some((budgetBrand) => item.name.toLowerCase().indexOf(budgetBrand) >= 0))
                  return false;
                if (bio && !item.bio)
                  return false;
                if (minPrice > item.price)
                  return false;
                if (maxPrice < item.price)
                  return false;
                return true;
              });
            }
          }
          if (query.length > 0) {
            if (query.charAt(0) == "!") {
              try {
                filteredItems = queryItemsAlasql(query, filteredItems);
              } catch (e) {
                elements.sqlError.classList.remove("hidden");
                elements.sqlError.innerText = e.message;
                filteredItems = [];
                this.lastQueryTokens = [];
              }
            } else {
              const result = queryItems(query, filteredItems, elements.exact.checked);
              filteredItems = result.items;
              this.model.lastQueryTokens = result.queryTokens;
            }
          }
          let queryChanged = this.model.lastQuery && this.model.lastQuery != query;
          if (queryChanged && !this._noChartClear) {
            filteredItems.forEach((item) => item.chart = false);
          }
          this.model.lastQuery = query;
          if (this.model.numItemsBeforeCategories && this.model.numItemsBeforeCategories != filteredItems.length)
            queryChanged = true;
          this.model.numItemsBeforeCategories = filteredItems.length;
          const filteredCategories = {};
          if (Object.keys(filteredCategories).length != 0) {
            let numEnabledCategories = 0;
            Object.keys(filteredCategories).forEach((categoryIndex) => {
              if (elements["category-" + categoryIndex].checked) {
                numEnabledCategories++;
              }
            });
            if (numEnabledCategories > 0) {
              filteredItems = filteredItems.filter((item) => {
                const category = categories[fromCategoryCode(item.category)[0]];
                return elements["category-" + category.index].checked;
              });
            }
          }
          log(`ItemsFilter - Filtering ${this.model.items.length} took ${deltaTime(start).toFixed(4)} secs, ${filteredItems.length} results.`);
          this.model.removeListener(this._listener);
          this.model.filteredItems = filteredItems;
          this.model.addListener(this._listener);
          this.setVisibility(query, Object.keys(filteredCategories).length, elements);
        }
        render() {
          const start = performance.now();
          const elements = this.elements;
          const items = this.model.items;
          if (this._filterByPriceChanges) {
            const dates = {};
            for (const item of items) {
              if (item.priceHistory.length == 1)
                continue;
              for (let i = 0; i < item.priceHistory.length; i++) {
                const price = item.priceHistory[i];
                if (i + 1 < item.priceHistory.length) {
                  if (item.priceHistory[i].price != item.priceHistory[i + 1].price) {
                    if (i == 0 || item.priceHistory[i].date != item.priceHistory[i - 1].date) {
                      dates[price.date] = dates[price.date] ? dates[price.date] + 1 : 1;
                    }
                  }
                }
              }
            }
            const priceChangesDates = elements.priceChangesDate;
            priceChangesDates.innerHTML = "";
            for (const date of Object.keys(dates).sort((a, b) => b.localeCompare(a))) {
              const dateDom = dom("option");
              dateDom.value = date;
              dateDom.innerText = `${date} (${dates[date]})`;
              priceChangesDates.append(dateDom);
            }
          }
          log(`ItemsFilter - rendering items filter took ${deltaTime(start)}`);
        }
        get shareableState() {
          const state = this.state;
          const shareableState = Object.keys(state).sort().filter((el) => !STORE_KEYS2.includes(el)).map((el) => {
            let value = state[el];
            if (value === true)
              value = ".";
            if (value === false)
              value = "-";
            if (el == "query")
              value = encodeURIComponent(value);
            return value;
          }).join(";");
          const disabledStores = STORE_KEYS2.filter((storeName) => {
            const store = state[storeName];
            if (stores[storeName].defaultChecked && !store)
              return true;
            if (!stores[storeName].defaultChecked && store)
              return true;
            return false;
          }).join(";");
          if (disabledStores.length > 0)
            return shareableState + ";" + disabledStores;
          else
            return shareableState;
        }
        set shareableState(shareableState) {
          const values = shareableState.split(";");
          const state = this.state;
          let storeIndex = -1;
          Object.keys(state).sort().filter((el) => !STORE_KEYS2.includes(el)).forEach((el, index) => {
            if (values[index] === ".")
              state[el] = true;
            else if (values[index] === "-")
              state[el] = false;
            else if (el == "query")
              state[el] = values[index];
            else
              state[el] = values[index];
            storeIndex = index + 1;
          });
          if (storeIndex < values.length) {
            for (let i = storeIndex; i < values.length; i++) {
              const storeName = values[i];
              state[storeName] = !stores[storeName].defaultChecked;
            }
          }
          this.state = state;
        }
      };
      customElements.define("items-filter", ItemsFilter);
    }
  });

  // site/js/stem.js
  var require_stem = __commonJS({
    "site/js/stem.js"(exports) {
      function stem(word) {
        word = word.replace(/([aeiouyäöü])u([aeiouyäöü])/g, "$1U$2");
        word = word.replace(/([aeiouyäöü])y([aeiouyäöü])/g, "$1Y$2");
        word = word.replace(/ß/g, "ss");
        var r1Index = word.search(/[aeiouyäöü][^aeiouyäöü]/);
        var r1 = "";
        if (r1Index != -1) {
          r1Index += 2;
          r1 = word.substring(r1Index);
        }
        var r2Index = -1;
        var r2 = "";
        if (r1Index != -1) {
          var r2Index = r1.search(/[aeiouyäöü][^aeiouyäöü]/);
          if (r2Index != -1) {
            r2Index += 2;
            r2 = r1.substring(r2Index);
            r2Index += r1Index;
          } else {
            r2 = "";
          }
        }
        if (r1Index != -1 && r1Index < 3) {
          r1Index = 3;
          r1 = word.substring(r1Index);
        }
        var a1Index = word.search(/(em|ern|er)$/g);
        var b1Index = word.search(/(e|en|es)$/g);
        var c1Index = word.search(/([bdfghklmnrt]s)$/g);
        if (c1Index != -1) {
          c1Index++;
        }
        var index1 = 1e4;
        var optionUsed1 = "";
        if (a1Index != -1 && a1Index < index1) {
          optionUsed1 = "a";
          index1 = a1Index;
        }
        if (b1Index != -1 && b1Index < index1) {
          optionUsed1 = "b";
          index1 = b1Index;
        }
        if (c1Index != -1 && c1Index < index1) {
          optionUsed1 = "c";
          index1 = c1Index;
        }
        if (index1 != 1e4 && r1Index != -1) {
          if (index1 >= r1Index) {
            word = word.substring(0, index1);
            if (optionUsed1 == "b") {
              if (word.search(/niss$/) != -1) {
                word = word.substring(0, word.length - 1);
              }
            }
          }
        }
        var a2Index = word.search(/(en|er|est)$/g);
        var b2Index = word.search(/(.{3}[bdfghklmnt]st)$/g);
        if (b2Index != -1) {
          b2Index += 4;
        }
        var index2 = 1e4;
        var optionUsed2 = "";
        if (a2Index != -1 && a2Index < index2) {
          optionUsed2 = "a";
          index2 = a2Index;
        }
        if (b2Index != -1 && b2Index < index2) {
          optionUsed2 = "b";
          index2 = b2Index;
        }
        if (index2 != 1e4 && r1Index != -1) {
          if (index2 >= r1Index) {
            word = word.substring(0, index2);
          }
        }
        var a3Index = word.search(/(end|ung)$/g);
        var b3Index = word.search(/[^e](ig|ik|isch)$/g);
        var c3Index = word.search(/(lich|heit)$/g);
        var d3Index = word.search(/(keit)$/g);
        if (b3Index != -1) {
          b3Index++;
        }
        var index3 = 1e4;
        var optionUsed3 = "";
        if (a3Index != -1 && a3Index < index3) {
          optionUsed3 = "a";
          index3 = a3Index;
        }
        if (b3Index != -1 && b3Index < index3) {
          optionUsed3 = "b";
          index3 = b3Index;
        }
        if (c3Index != -1 && c3Index < index3) {
          optionUsed3 = "c";
          index3 = c3Index;
        }
        if (d3Index != -1 && d3Index < index3) {
          optionUsed3 = "d";
          index3 = d3Index;
        }
        if (index3 != 1e4 && r2Index != -1) {
          if (index3 >= r2Index) {
            word = word.substring(0, index3);
            var optionIndex = -1;
            var optionSubsrt = "";
            if (optionUsed3 == "a") {
              optionIndex = word.search(/[^e](ig)$/);
              if (optionIndex != -1) {
                optionIndex++;
                if (optionIndex >= r2Index) {
                  word = word.substring(0, optionIndex);
                }
              }
            } else if (optionUsed3 == "c") {
              optionIndex = word.search(/(er|en)$/);
              if (optionIndex != -1) {
                if (optionIndex >= r1Index) {
                  word = word.substring(0, optionIndex);
                }
              }
            } else if (optionUsed3 == "d") {
              optionIndex = word.search(/(lich|ig)$/);
              if (optionIndex != -1) {
                if (optionIndex >= r2Index) {
                  word = word.substring(0, optionIndex);
                }
              }
            }
          }
        }
        word = word.replace(/U/g, "u");
        word = word.replace(/Y/g, "y");
        word = word.replace(/ä/g, "a");
        word = word.replace(/ö/g, "o");
        word = word.replace(/ü/g, "u");
        return word;
      }
      exports.stem = stem;
      exports.stopWords = [
        "ab",
        "aber",
        "alle",
        "allein",
        "allem",
        "allen",
        "aller",
        "allerdings",
        "allerlei",
        "alles",
        "allm\xE4hlich",
        "allzu",
        "als",
        "alsbald",
        "also",
        "am",
        "an",
        "and",
        "ander",
        "andere",
        "anderem",
        "anderen",
        "anderer",
        "andererseits",
        "anderes",
        "anderm",
        "andern",
        "andernfalls",
        "anders",
        "anstatt",
        "auch",
        "auf",
        "aus",
        "ausgenommen",
        "ausser",
        "ausserdem",
        "au\xDFer",
        "au\xDFerdem",
        "au\xDFerhalb",
        "bald",
        "bei",
        "beide",
        "beiden",
        "beiderlei",
        "beides",
        "beim",
        "beinahe",
        "bereits",
        "besonders",
        "besser",
        "betr\xE4chtlich",
        "bevor",
        "bez\xFCglich",
        "bin",
        "bis",
        "bisher",
        "bislang",
        "bist",
        "blo\xDF",
        "bsp.",
        "bzw",
        "ca",
        "ca.",
        "content",
        "da",
        "dabei",
        "dadurch",
        "daf\xFCr",
        "dagegen",
        "daher",
        "dahin",
        "damals",
        "damit",
        "danach",
        "daneben",
        "dann",
        "daran",
        "darauf",
        "daraus",
        "darin",
        "darum",
        "darunter",
        "dar\xFCber",
        "dar\xFCberhinaus",
        "das",
        "dass",
        "dasselbe",
        "davon",
        "davor",
        "dazu",
        "da\xDF",
        "dein",
        "deine",
        "deinem",
        "deinen",
        "deiner",
        "deines",
        "dem",
        "demnach",
        "demselben",
        "den",
        "denen",
        "denn",
        "dennoch",
        "denselben",
        "der",
        "derart",
        "derartig",
        "derem",
        "deren",
        "derer",
        "derjenige",
        "derjenigen",
        "derselbe",
        "derselben",
        "derzeit",
        "des",
        "deshalb",
        "desselben",
        "dessen",
        "desto",
        "deswegen",
        "dich",
        "die",
        "diejenige",
        "dies",
        "diese",
        "dieselbe",
        "dieselben",
        "diesem",
        "diesen",
        "dieser",
        "dieses",
        "diesseits",
        "dir",
        "direkt",
        "direkte",
        "direkten",
        "direkter",
        "doch",
        "dort",
        "dorther",
        "dorthin",
        "drauf",
        "drin",
        "drunter",
        "dr\xFCber",
        "du",
        "dunklen",
        "durch",
        "durchaus",
        "eben",
        "ebenfalls",
        "ebenso",
        "eher",
        "eigenen",
        "eigenes",
        "eigentlich",
        "ein",
        "eine",
        "einem",
        "einen",
        "einer",
        "einerseits",
        "eines",
        "einfach",
        "einf\xFChren",
        "einf\xFChrte",
        "einf\xFChrten",
        "eingesetzt",
        "einig",
        "einige",
        "einigem",
        "einigen",
        "einiger",
        "einigerma\xDFen",
        "einiges",
        "einmal",
        "eins",
        "einseitig",
        "einseitige",
        "einseitigen",
        "einseitiger",
        "einst",
        "einstmals",
        "einzig",
        "entsprechend",
        "entweder",
        "er",
        "erst",
        "es",
        "etc",
        "etliche",
        "etwa",
        "etwas",
        "euch",
        "euer",
        "eure",
        "eurem",
        "euren",
        "eurer",
        "eures",
        "falls",
        "fast",
        "ferner",
        "folgende",
        "folgenden",
        "folgender",
        "folgendes",
        "folglich",
        "fuer",
        "f\xFCr",
        "gab",
        "ganze",
        "ganzem",
        "ganzen",
        "ganzer",
        "ganzes",
        "gar",
        "gegen",
        "gem\xE4ss",
        "ggf",
        "gleich",
        "gleichwohl",
        "gleichzeitig",
        "gl\xFCcklicherweise",
        "g\xE4nzlich",
        "hab",
        "habe",
        "haben",
        "haette",
        "hast",
        "hat",
        "hatte",
        "hatten",
        "hattest",
        "hattet",
        "heraus",
        "herein",
        "hier",
        "hier",
        "hinter",
        "hiermit",
        "hiesige",
        "hin",
        "hinein",
        "hinten",
        "hinter",
        "hinterher",
        "http",
        "h\xE4tt",
        "h\xE4tte",
        "h\xE4tten",
        "h\xF6chstens",
        "ich",
        "igitt",
        "ihm",
        "ihn",
        "ihnen",
        "ihr",
        "ihre",
        "ihrem",
        "ihren",
        "ihrer",
        "ihres",
        "im",
        "immer",
        "immerhin",
        "in",
        "indem",
        "indessen",
        "infolge",
        "innen",
        "innerhalb",
        "ins",
        "insofern",
        "inzwischen",
        "irgend",
        "irgendeine",
        "irgendwas",
        "irgendwen",
        "irgendwer",
        "irgendwie",
        "irgendwo",
        "ist",
        "ja",
        "je",
        "jed",
        "jede",
        "jedem",
        "jeden",
        "jedenfalls",
        "jeder",
        "jederlei",
        "jedes",
        "jedoch",
        "jemand",
        "jene",
        "jenem",
        "jenen",
        "jener",
        "jenes",
        "jenseits",
        "jetzt",
        "j\xE4hrig",
        "j\xE4hrige",
        "j\xE4hrigen",
        "j\xE4hriges",
        "kam",
        "kann",
        "kannst",
        "kaum",
        "kein",
        "keine",
        "keinem",
        "keinen",
        "keiner",
        "keinerlei",
        "keines",
        "keineswegs",
        "klar",
        "klare",
        "klaren",
        "klares",
        "klein",
        "kleinen",
        "kleiner",
        "kleines",
        "koennen",
        "koennt",
        "koennte",
        "koennten",
        "komme",
        "kommen",
        "kommt",
        "konkret",
        "konkrete",
        "konkreten",
        "konkreter",
        "konkretes",
        "k\xF6nnen",
        "k\xF6nnt",
        "k\xFCnftig",
        "leider",
        "machen",
        "man",
        "manche",
        "manchem",
        "manchen",
        "mancher",
        "mancherorts",
        "manches",
        "manchmal",
        "mehr",
        "mehrere",
        "mein",
        "meine",
        "meinem",
        "meinen",
        "meiner",
        "meines",
        "mich",
        "mir",
        "mit",
        "mithin",
        "muessen",
        "muesst",
        "muesste",
        "muss",
        "musst",
        "musste",
        "mussten",
        "mu\xDF",
        "mu\xDFt",
        "m\xFCssen",
        "m\xFCsste",
        "m\xFCssten",
        "m\xFC\xDFt",
        "m\xFC\xDFte",
        "nach",
        "nachdem",
        "nachher",
        "nachhinein",
        "nahm",
        "nat\xFCrlich",
        "neben",
        "nebenan",
        "nehmen",
        "nein",
        "nicht",
        "nichts",
        "nie",
        "niemals",
        "niemand",
        "nirgends",
        "nirgendwo",
        "noch",
        "nun",
        "nur",
        "n\xE4chste",
        "n\xE4mlich",
        "n\xF6tigenfalls",
        "ob",
        "oben",
        "oberhalb",
        "obgleich",
        "obschon",
        "obwohl",
        "oder",
        "oft",
        "per",
        "pl\xF6tzlich",
        "schlie\xDFlich",
        "schon",
        "sehr",
        "sehrwohl",
        "seid",
        "sein",
        "seine",
        "seinem",
        "seinen",
        "seiner",
        "seines",
        "seit",
        "seitdem",
        "seither",
        "selber",
        "selbst",
        "sich",
        "sicher",
        "sicherlich",
        "sie",
        "sind",
        "so",
        "sobald",
        "sodass",
        "sofort",
        "sofern",
        "sog",
        "sogar",
        "solange",
        "solch",
        "solche",
        "solchem",
        "solchen",
        "solcher",
        "solches",
        "soll",
        "sollen",
        "sollst",
        "sollt",
        "sollte",
        "sollten",
        "somit",
        "sondern",
        "sonst",
        "sonstige",
        "sonstigen",
        "sonstiger",
        "sonstiges",
        "sooft",
        "soviel",
        "soweit",
        "sowie",
        "sowieso",
        "sowohl",
        "sp\xE4ter",
        "statt",
        "stattfinden",
        "stattfand",
        "stattgefunden",
        "steht",
        "stets",
        "such",
        "suche",
        "suchen",
        "tats\xE4chlich",
        "tats\xE4chlichen",
        "tats\xE4chlicher",
        "tats\xE4chliches",
        "tats\xE4chlich",
        "tats\xE4chlichen",
        "tats\xE4chlicher",
        "tats\xE4chliches",
        "tief",
        "tiefer",
        "trotz",
        "trotzdem",
        "tun",
        "\xFCber",
        "\xFCberall",
        "\xFCberallhin",
        "\xFCberdies",
        "\xFCberhaupt",
        "\xFCbrig",
        "\xFCbrigens",
        "um",
        "umso",
        "umsoweniger",
        "unbedingt",
        "und",
        "unm\xF6glich",
        "unn\xF6tig",
        "unser",
        "unsere",
        "unserem",
        "unseren",
        "unserer",
        "unseres",
        "unserseits",
        "unter",
        "unterhalb",
        "unterhalb",
        "untereinander",
        "untergebracht",
        "unterhalb",
        "unterhalb",
        "unterhalb",
        "unterhalb",
        "unterhalb",
        "unterhalb",
        "unterschiedlich",
        "unterschiedliche",
        "unterschiedlichen",
        "unterschiedlicher",
        "unterschiedliches",
        "unterschiedlich",
        "unterschiedliche",
        "unterschiedlichen",
        "unterschiedlicher",
        "unterschiedliches",
        "unzwar",
        "usw",
        "usw.",
        "vermag",
        "verm\xF6gen",
        "vermutlich",
        "verrate",
        "verraten",
        "verr\xE4tst",
        "verschieden",
        "verschiedene",
        "verschiedenen",
        "verschiedener",
        "verschiedenes",
        "versorgen",
        "versorgt",
        "versorgte",
        "versorgten",
        "viel",
        "viele",
        "vielem",
        "vielen",
        "vieler",
        "vieles",
        "vielleicht",
        "vielmals",
        "vier",
        "vierte",
        "viertel",
        "vierten",
        "vierter",
        "viertes",
        "vom",
        "von",
        "vor",
        "vorbei",
        "vorgestern",
        "vorher",
        "vor\xFCber",
        "wach",
        "wachen",
        "wahrend",
        "wann",
        "war",
        "warauf",
        "ward",
        "waren",
        "warst",
        "wart",
        "warum",
        "was",
        "weder",
        "weil",
        "weiter",
        "weitere",
        "weiterem",
        "weiteren",
        "weiterer",
        "weiteres",
        "weiterhin",
        "weitgehend",
        "welche",
        "welchem",
        "welchen",
        "welcher",
        "welches",
        "wem",
        "wen",
        "wenig",
        "wenige",
        "wenigem",
        "wenigen",
        "weniger",
        "wenigstens",
        "wenn",
        "wenngleich",
        "wer",
        "werde",
        "werden",
        "werdet",
        "weshalb",
        "wessen",
        "wichtig",
        "wie",
        "wieder",
        "wiederum",
        "wieso",
        "will",
        "willst",
        "wir",
        "wird",
        "wirklich",
        "wirst",
        "wissen",
        "wo",
        "woanders",
        "wohl",
        "woher",
        "wohin",
        "wohingegen",
        "wohl",
        "wohlweislich",
        "wollen",
        "wollt",
        "wollte",
        "wollten",
        "womit",
        "woraufhin",
        "woraus",
        "woraussichtlich",
        "worauf",
        "woraus",
        "worin",
        "wor\xFCber",
        "wovon",
        "wovor",
        "wozu",
        "w\xE4hrend",
        "w\xE4hrenddessen",
        "w\xE4r",
        "w\xE4re",
        "w\xE4ren",
        "w\xE4rst",
        "w\xE4re",
        "w\xE4ren",
        "w\xE4rst",
        "w\xFCrde",
        "w\xFCrden",
        "w\xFCrdest",
        "w\xFCrdet",
        "zB",
        "z.b.",
        "zehn",
        "zeigen",
        "zeitweise",
        "zu",
        "zufolge",
        "zugleich",
        "zuletzt",
        "zum",
        "zumal",
        "zumeist",
        "zun\xE4chst",
        "zur",
        "zur\xFCck",
        "zur\xFCckgehend",
        "zur\xFCckgehen",
        "zur\xFCckgegangen",
        "zur\xFCckgekommen",
        "zur\xFCckgekommen",
        "zur\xFCckgekommen",
        "zur\xFCckgekommen",
        "zur\xFCckgezogen",
        "zusammen",
        "zus\xE4tzlich",
        "zusammen",
        "zuvor",
        "zuviel",
        "zuweilen",
        "zwanzig",
        "zwar",
        "zwei",
        "zweite",
        "zweiten",
        "zweiter",
        "zweites",
        "zwischen",
        "zwischendurch",
        "zw\xF6lf",
        "\xFCberall",
        "\xFCberallhin",
        "\xFCberdies",
        "\xFCberhaupt",
        "\xFCbrig",
        "\xFCbrigens"
      ];
    }
  });

  // site/js/knn.js
  var require_knn = __commonJS({
    "site/js/knn.js"(exports) {
      var { stem, stopWords } = require_stem();
      function dotProduct(vector1, vector2) {
        let product = 0;
        for (const key in vector1) {
          if (vector2.hasOwnProperty(key)) {
            product += vector1[key] * vector2[key];
          }
        }
        return product;
      }
      exports.dotProduct = dotProduct;
      function addVector(vector1, vector2) {
        for (const key in vector2) {
          vector1[key] = (vector1[key] || 0) + vector2[key];
        }
      }
      exports.addVector = addVector;
      function scaleVector(vector, scalar) {
        for (const key in vector) {
          vector[key] *= scalar;
        }
      }
      exports.scaleVector = scaleVector;
      function normalizeVector(vector) {
        const len = magnitude(vector);
        for (const key in vector) {
          vector[key] /= len;
        }
      }
      exports.normalizeVector = normalizeVector;
      function magnitude(vector) {
        let sumOfSquares = 0;
        for (const key in vector) {
          sumOfSquares += vector[key] ** 2;
        }
        return Math.sqrt(sumOfSquares);
      }
      exports.magnitude = magnitude;
      function findMostSimilarItem(refItem, items) {
        let maxSimilarity = -1;
        let similarItem = null;
        let similarItemIdx = -1;
        for (let idx = 0; idx < items.length; idx++) {
          const item = items[idx];
          if (item.sorted)
            continue;
          let similarity = dotProduct(refItem.vector, item.vector);
          if (similarity > maxSimilarity || similarity > 0.9999999) {
            maxSimilarity = similarity;
            similarItem = item;
            similarItemIdx = idx;
          }
          if (similarity > 0.9999999) {
            break;
          }
        }
        return {
          similarity: maxSimilarity,
          item: similarItem,
          index: similarItemIdx
        };
      }
      exports.findMostSimilarItem = findMostSimilarItem;
      function findMostSimilarItems(refItem, items, k = 5, accept = (ref, item) => true) {
        let topSimilarItems = [];
        let topSimilarities = [];
        items.forEach((item, idx) => {
          if (!accept(refItem, item))
            return;
          let similarity = dotProduct(refItem.vector, item.vector);
          if (topSimilarItems.length < k) {
            topSimilarItems.push(item);
            topSimilarities.push(similarity);
          } else {
            let minSimilarity = Math.min(...topSimilarities);
            let minIndex = topSimilarities.indexOf(minSimilarity);
            if (similarity > minSimilarity) {
              topSimilarItems[minIndex] = item;
              topSimilarities[minIndex] = similarity;
            }
          }
        });
        let similarItemsWithIndices = topSimilarItems.map((item, index) => {
          return {
            similarity: topSimilarities[index],
            item,
            index: items.indexOf(item)
          };
        });
        return similarItemsWithIndices;
      }
      exports.findMostSimilarItems = findMostSimilarItems;
      function similaritySortItems(items, progress) {
        if (items.length == 0)
          return items;
        sortedItems = [items.shift()];
        let refItem = sortedItems[0];
        items.forEach((item) => item.sorted = false);
        while (items.length != sortedItems.length) {
          const similarItem = findMostSimilarItem(refItem, items);
          sortedItems.push(similarItem.item);
          similarItem.item.sorted = true;
          refItem = similarItem.item;
          if (progress)
            progress(sortedItems, items);
        }
        items.forEach((item) => delete item.sorted);
        return sortedItems;
      }
      exports.similaritySortItems = similaritySortItems;
      var NGRAM = 4;
      function vectorizeTokens(tokens) {
        const vector = {};
        for (token of tokens) {
          if (token.length > NGRAM) {
            for (let i = 0; i < token.length - NGRAM; i++) {
              let trigram = token.substring(i, i + NGRAM);
              vector[trigram] = (vector[trigram] || 0) + 1;
            }
          } else {
            vector[token] = (vector[token] || 0) + 1;
          }
        }
        normalizeVector(vector);
        return vector;
      }
      exports.vectorizeTokens = vectorizeTokens;
      function vectorizeItem(item, useUnit = true, useStem = true) {
        const isNumber = /^\d+\.\d+$/;
        let name = item.name.toLowerCase().replace(/[^\w\s]|_/g, "").replace("-", " ").replace(",", " ");
        item.tokens = name.split(/\s+/).filter((token2) => !stopWords.includes(token2)).filter((token2) => !isNumber.test(token2)).map((token2) => useStem ? stem(token2) : token2);
        if (useUnit) {
          if (item.quantity)
            item.tokens.push("" + item.quantity);
          if (item.unit)
            item.tokens.push(item.unit);
        }
        item.vector = vectorizeTokens(item.tokens);
      }
      exports.vectorizeItem = vectorizeItem;
      function vectorizeItems(items, useUnit = true) {
        items.forEach((item) => {
          if (!item.vector)
            vectorizeItem(item, useUnit);
        });
      }
      exports.vectorizeItems = vectorizeItems;
    }
  });

  // node_modules/moment/moment.js
  var require_moment = __commonJS({
    "node_modules/moment/moment.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global2.moment = factory();
      })(exports, function() {
        "use strict";
        var hookCallback;
        function hooks() {
          return hookCallback.apply(null, arguments);
        }
        function setHookCallback(callback) {
          hookCallback = callback;
        }
        function isArray(input) {
          return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
        }
        function isObject(input) {
          return input != null && Object.prototype.toString.call(input) === "[object Object]";
        }
        function hasOwnProp(a, b) {
          return Object.prototype.hasOwnProperty.call(a, b);
        }
        function isObjectEmpty(obj) {
          if (Object.getOwnPropertyNames) {
            return Object.getOwnPropertyNames(obj).length === 0;
          } else {
            var k;
            for (k in obj) {
              if (hasOwnProp(obj, k)) {
                return false;
              }
            }
            return true;
          }
        }
        function isUndefined(input) {
          return input === void 0;
        }
        function isNumber(input) {
          return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
        }
        function isDate(input) {
          return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
        }
        function map(arr, fn) {
          var res = [], i, arrLen = arr.length;
          for (i = 0; i < arrLen; ++i) {
            res.push(fn(arr[i], i));
          }
          return res;
        }
        function extend(a, b) {
          for (var i in b) {
            if (hasOwnProp(b, i)) {
              a[i] = b[i];
            }
          }
          if (hasOwnProp(b, "toString")) {
            a.toString = b.toString;
          }
          if (hasOwnProp(b, "valueOf")) {
            a.valueOf = b.valueOf;
          }
          return a;
        }
        function createUTC(input, format2, locale2, strict) {
          return createLocalOrUTC(input, format2, locale2, strict, true).utc();
        }
        function defaultParsingFlags() {
          return {
            empty: false,
            unusedTokens: [],
            unusedInput: [],
            overflow: -2,
            charsLeftOver: 0,
            nullInput: false,
            invalidEra: null,
            invalidMonth: null,
            invalidFormat: false,
            userInvalidated: false,
            iso: false,
            parsedDateParts: [],
            era: null,
            meridiem: null,
            rfc2822: false,
            weekdayMismatch: false
          };
        }
        function getParsingFlags(m) {
          if (m._pf == null) {
            m._pf = defaultParsingFlags();
          }
          return m._pf;
        }
        var some;
        if (Array.prototype.some) {
          some = Array.prototype.some;
        } else {
          some = function(fun) {
            var t = Object(this), len = t.length >>> 0, i;
            for (i = 0; i < len; i++) {
              if (i in t && fun.call(this, t[i], i, t)) {
                return true;
              }
            }
            return false;
          };
        }
        function isValid(m) {
          if (m._isValid == null) {
            var flags = getParsingFlags(m), parsedParts = some.call(flags.parsedDateParts, function(i) {
              return i != null;
            }), isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
            if (m._strict) {
              isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
            }
            if (Object.isFrozen == null || !Object.isFrozen(m)) {
              m._isValid = isNowValid;
            } else {
              return isNowValid;
            }
          }
          return m._isValid;
        }
        function createInvalid(flags) {
          var m = createUTC(NaN);
          if (flags != null) {
            extend(getParsingFlags(m), flags);
          } else {
            getParsingFlags(m).userInvalidated = true;
          }
          return m;
        }
        var momentProperties = hooks.momentProperties = [], updateInProgress = false;
        function copyConfig(to2, from2) {
          var i, prop, val, momentPropertiesLen = momentProperties.length;
          if (!isUndefined(from2._isAMomentObject)) {
            to2._isAMomentObject = from2._isAMomentObject;
          }
          if (!isUndefined(from2._i)) {
            to2._i = from2._i;
          }
          if (!isUndefined(from2._f)) {
            to2._f = from2._f;
          }
          if (!isUndefined(from2._l)) {
            to2._l = from2._l;
          }
          if (!isUndefined(from2._strict)) {
            to2._strict = from2._strict;
          }
          if (!isUndefined(from2._tzm)) {
            to2._tzm = from2._tzm;
          }
          if (!isUndefined(from2._isUTC)) {
            to2._isUTC = from2._isUTC;
          }
          if (!isUndefined(from2._offset)) {
            to2._offset = from2._offset;
          }
          if (!isUndefined(from2._pf)) {
            to2._pf = getParsingFlags(from2);
          }
          if (!isUndefined(from2._locale)) {
            to2._locale = from2._locale;
          }
          if (momentPropertiesLen > 0) {
            for (i = 0; i < momentPropertiesLen; i++) {
              prop = momentProperties[i];
              val = from2[prop];
              if (!isUndefined(val)) {
                to2[prop] = val;
              }
            }
          }
          return to2;
        }
        function Moment(config) {
          copyConfig(this, config);
          this._d = new Date(config._d != null ? config._d.getTime() : NaN);
          if (!this.isValid()) {
            this._d = /* @__PURE__ */ new Date(NaN);
          }
          if (updateInProgress === false) {
            updateInProgress = true;
            hooks.updateOffset(this);
            updateInProgress = false;
          }
        }
        function isMoment(obj) {
          return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
        }
        function warn(msg) {
          if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
            console.warn("Deprecation warning: " + msg);
          }
        }
        function deprecate(msg, fn) {
          var firstTime = true;
          return extend(function() {
            if (hooks.deprecationHandler != null) {
              hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
              var args = [], arg, i, key, argLen = arguments.length;
              for (i = 0; i < argLen; i++) {
                arg = "";
                if (typeof arguments[i] === "object") {
                  arg += "\n[" + i + "] ";
                  for (key in arguments[0]) {
                    if (hasOwnProp(arguments[0], key)) {
                      arg += key + ": " + arguments[0][key] + ", ";
                    }
                  }
                  arg = arg.slice(0, -2);
                } else {
                  arg = arguments[i];
                }
                args.push(arg);
              }
              warn(
                msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack
              );
              firstTime = false;
            }
            return fn.apply(this, arguments);
          }, fn);
        }
        var deprecations = {};
        function deprecateSimple(name, msg) {
          if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(name, msg);
          }
          if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
          }
        }
        hooks.suppressDeprecationWarnings = false;
        hooks.deprecationHandler = null;
        function isFunction(input) {
          return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
        }
        function set(config) {
          var prop, i;
          for (i in config) {
            if (hasOwnProp(config, i)) {
              prop = config[i];
              if (isFunction(prop)) {
                this[i] = prop;
              } else {
                this["_" + i] = prop;
              }
            }
          }
          this._config = config;
          this._dayOfMonthOrdinalParseLenient = new RegExp(
            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
          );
        }
        function mergeConfigs(parentConfig, childConfig) {
          var res = extend({}, parentConfig), prop;
          for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
              if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                res[prop] = {};
                extend(res[prop], parentConfig[prop]);
                extend(res[prop], childConfig[prop]);
              } else if (childConfig[prop] != null) {
                res[prop] = childConfig[prop];
              } else {
                delete res[prop];
              }
            }
          }
          for (prop in parentConfig) {
            if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
              res[prop] = extend({}, res[prop]);
            }
          }
          return res;
        }
        function Locale(config) {
          if (config != null) {
            this.set(config);
          }
        }
        var keys;
        if (Object.keys) {
          keys = Object.keys;
        } else {
          keys = function(obj) {
            var i, res = [];
            for (i in obj) {
              if (hasOwnProp(obj, i)) {
                res.push(i);
              }
            }
            return res;
          };
        }
        var defaultCalendar = {
          sameDay: "[Today at] LT",
          nextDay: "[Tomorrow at] LT",
          nextWeek: "dddd [at] LT",
          lastDay: "[Yesterday at] LT",
          lastWeek: "[Last] dddd [at] LT",
          sameElse: "L"
        };
        function calendar(key, mom, now2) {
          var output = this._calendar[key] || this._calendar["sameElse"];
          return isFunction(output) ? output.call(mom, now2) : output;
        }
        function zeroFill(number, targetLength, forceSign) {
          var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign2 = number >= 0;
          return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
        }
        var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
        function addFormatToken(token3, padded, ordinal2, callback) {
          var func = callback;
          if (typeof callback === "string") {
            func = function() {
              return this[callback]();
            };
          }
          if (token3) {
            formatTokenFunctions[token3] = func;
          }
          if (padded) {
            formatTokenFunctions[padded[0]] = function() {
              return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
          }
          if (ordinal2) {
            formatTokenFunctions[ordinal2] = function() {
              return this.localeData().ordinal(
                func.apply(this, arguments),
                token3
              );
            };
          }
        }
        function removeFormattingTokens(input) {
          if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, "");
          }
          return input.replace(/\\/g, "");
        }
        function makeFormatFunction(format2) {
          var array = format2.match(formattingTokens), i, length;
          for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
              array[i] = formatTokenFunctions[array[i]];
            } else {
              array[i] = removeFormattingTokens(array[i]);
            }
          }
          return function(mom) {
            var output = "", i2;
            for (i2 = 0; i2 < length; i2++) {
              output += isFunction(array[i2]) ? array[i2].call(mom, format2) : array[i2];
            }
            return output;
          };
        }
        function formatMoment(m, format2) {
          if (!m.isValid()) {
            return m.localeData().invalidDate();
          }
          format2 = expandFormat(format2, m.localeData());
          formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
          return formatFunctions[format2](m);
        }
        function expandFormat(format2, locale2) {
          var i = 5;
          function replaceLongDateFormatTokens(input) {
            return locale2.longDateFormat(input) || input;
          }
          localFormattingTokens.lastIndex = 0;
          while (i >= 0 && localFormattingTokens.test(format2)) {
            format2 = format2.replace(
              localFormattingTokens,
              replaceLongDateFormatTokens
            );
            localFormattingTokens.lastIndex = 0;
            i -= 1;
          }
          return format2;
        }
        var defaultLongDateFormat = {
          LTS: "h:mm:ss A",
          LT: "h:mm A",
          L: "MM/DD/YYYY",
          LL: "MMMM D, YYYY",
          LLL: "MMMM D, YYYY h:mm A",
          LLLL: "dddd, MMMM D, YYYY h:mm A"
        };
        function longDateFormat(key) {
          var format2 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
          if (format2 || !formatUpper) {
            return format2;
          }
          this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
            if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
              return tok.slice(1);
            }
            return tok;
          }).join("");
          return this._longDateFormat[key];
        }
        var defaultInvalidDate = "Invalid date";
        function invalidDate() {
          return this._invalidDate;
        }
        var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
        function ordinal(number) {
          return this._ordinal.replace("%d", number);
        }
        var defaultRelativeTime = {
          future: "in %s",
          past: "%s ago",
          s: "a few seconds",
          ss: "%d seconds",
          m: "a minute",
          mm: "%d minutes",
          h: "an hour",
          hh: "%d hours",
          d: "a day",
          dd: "%d days",
          w: "a week",
          ww: "%d weeks",
          M: "a month",
          MM: "%d months",
          y: "a year",
          yy: "%d years"
        };
        function relativeTime(number, withoutSuffix, string, isFuture) {
          var output = this._relativeTime[string];
          return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
        }
        function pastFuture(diff2, output) {
          var format2 = this._relativeTime[diff2 > 0 ? "future" : "past"];
          return isFunction(format2) ? format2(output) : format2.replace(/%s/i, output);
        }
        var aliases = {};
        function addUnitAlias(unit, shorthand) {
          var lowerCase = unit.toLowerCase();
          aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
        }
        function normalizeUnits(units) {
          return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
        }
        function normalizeObjectUnits(inputObject) {
          var normalizedInput = {}, normalizedProp, prop;
          for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
              normalizedProp = normalizeUnits(prop);
              if (normalizedProp) {
                normalizedInput[normalizedProp] = inputObject[prop];
              }
            }
          }
          return normalizedInput;
        }
        var priorities = {};
        function addUnitPriority(unit, priority) {
          priorities[unit] = priority;
        }
        function getPrioritizedUnits(unitsObj) {
          var units = [], u;
          for (u in unitsObj) {
            if (hasOwnProp(unitsObj, u)) {
              units.push({ unit: u, priority: priorities[u] });
            }
          }
          units.sort(function(a, b) {
            return a.priority - b.priority;
          });
          return units;
        }
        function isLeapYear(year) {
          return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
        }
        function absFloor(number) {
          if (number < 0) {
            return Math.ceil(number) || 0;
          } else {
            return Math.floor(number);
          }
        }
        function toInt(argumentForCoercion) {
          var coercedNumber = +argumentForCoercion, value = 0;
          if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
          }
          return value;
        }
        function makeGetSet(unit, keepTime) {
          return function(value) {
            if (value != null) {
              set$1(this, unit, value);
              hooks.updateOffset(this, keepTime);
              return this;
            } else {
              return get(this, unit);
            }
          };
        }
        function get(mom, unit) {
          return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
        }
        function set$1(mom, unit, value) {
          if (mom.isValid() && !isNaN(value)) {
            if (unit === "FullYear" && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
              value = toInt(value);
              mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](
                value,
                mom.month(),
                daysInMonth(value, mom.month())
              );
            } else {
              mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
            }
          }
        }
        function stringGet(units) {
          units = normalizeUnits(units);
          if (isFunction(this[units])) {
            return this[units]();
          }
          return this;
        }
        function stringSet(units, value) {
          if (typeof units === "object") {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units), i, prioritizedLen = prioritized.length;
            for (i = 0; i < prioritizedLen; i++) {
              this[prioritized[i].unit](units[prioritized[i].unit]);
            }
          } else {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
              return this[units](value);
            }
          }
          return this;
        }
        var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, regexes;
        regexes = {};
        function addRegexToken(token3, regex, strictRegex) {
          regexes[token3] = isFunction(regex) ? regex : function(isStrict, localeData2) {
            return isStrict && strictRegex ? strictRegex : regex;
          };
        }
        function getParseRegexForToken(token3, config) {
          if (!hasOwnProp(regexes, token3)) {
            return new RegExp(unescapeFormat(token3));
          }
          return regexes[token3](config._strict, config._locale);
        }
        function unescapeFormat(s) {
          return regexEscape(
            s.replace("\\", "").replace(
              /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
              function(matched, p1, p2, p3, p4) {
                return p1 || p2 || p3 || p4;
              }
            )
          );
        }
        function regexEscape(s) {
          return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
        }
        var tokens = {};
        function addParseToken(token3, callback) {
          var i, func = callback, tokenLen;
          if (typeof token3 === "string") {
            token3 = [token3];
          }
          if (isNumber(callback)) {
            func = function(input, array) {
              array[callback] = toInt(input);
            };
          }
          tokenLen = token3.length;
          for (i = 0; i < tokenLen; i++) {
            tokens[token3[i]] = func;
          }
        }
        function addWeekParseToken(token3, callback) {
          addParseToken(token3, function(input, array, config, token4) {
            config._w = config._w || {};
            callback(input, config._w, config, token4);
          });
        }
        function addTimeToArrayFromToken(token3, input, config) {
          if (input != null && hasOwnProp(tokens, token3)) {
            tokens[token3](input, config._a, config, token3);
          }
        }
        var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
        function mod(n, x) {
          return (n % x + x) % x;
        }
        var indexOf;
        if (Array.prototype.indexOf) {
          indexOf = Array.prototype.indexOf;
        } else {
          indexOf = function(o) {
            var i;
            for (i = 0; i < this.length; ++i) {
              if (this[i] === o) {
                return i;
              }
            }
            return -1;
          };
        }
        function daysInMonth(year, month) {
          if (isNaN(year) || isNaN(month)) {
            return NaN;
          }
          var modMonth = mod(month, 12);
          year += (month - modMonth) / 12;
          return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
        }
        addFormatToken("M", ["MM", 2], "Mo", function() {
          return this.month() + 1;
        });
        addFormatToken("MMM", 0, 0, function(format2) {
          return this.localeData().monthsShort(this, format2);
        });
        addFormatToken("MMMM", 0, 0, function(format2) {
          return this.localeData().months(this, format2);
        });
        addUnitAlias("month", "M");
        addUnitPriority("month", 8);
        addRegexToken("M", match1to2);
        addRegexToken("MM", match1to2, match2);
        addRegexToken("MMM", function(isStrict, locale2) {
          return locale2.monthsShortRegex(isStrict);
        });
        addRegexToken("MMMM", function(isStrict, locale2) {
          return locale2.monthsRegex(isStrict);
        });
        addParseToken(["M", "MM"], function(input, array) {
          array[MONTH] = toInt(input) - 1;
        });
        addParseToken(["MMM", "MMMM"], function(input, array, config, token3) {
          var month = config._locale.monthsParse(input, token3, config._strict);
          if (month != null) {
            array[MONTH] = month;
          } else {
            getParsingFlags(config).invalidMonth = input;
          }
        });
        var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split(
          "_"
        ), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
        function localeMonths(m, format2) {
          if (!m) {
            return isArray(this._months) ? this._months : this._months["standalone"];
          }
          return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m.month()];
        }
        function localeMonthsShort(m, format2) {
          if (!m) {
            return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
          }
          return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m.month()];
        }
        function handleStrictParse(monthName, format2, strict) {
          var i, ii, mom, llc = monthName.toLocaleLowerCase();
          if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i < 12; ++i) {
              mom = createUTC([2e3, i]);
              this._shortMonthsParse[i] = this.monthsShort(
                mom,
                ""
              ).toLocaleLowerCase();
              this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
            }
          }
          if (strict) {
            if (format2 === "MMM") {
              ii = indexOf.call(this._shortMonthsParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf.call(this._longMonthsParse, llc);
              return ii !== -1 ? ii : null;
            }
          } else {
            if (format2 === "MMM") {
              ii = indexOf.call(this._shortMonthsParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._longMonthsParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf.call(this._longMonthsParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._shortMonthsParse, llc);
              return ii !== -1 ? ii : null;
            }
          }
        }
        function localeMonthsParse(monthName, format2, strict) {
          var i, mom, regex;
          if (this._monthsParseExact) {
            return handleStrictParse.call(this, monthName, format2, strict);
          }
          if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
          }
          for (i = 0; i < 12; i++) {
            mom = createUTC([2e3, i]);
            if (strict && !this._longMonthsParse[i]) {
              this._longMonthsParse[i] = new RegExp(
                "^" + this.months(mom, "").replace(".", "") + "$",
                "i"
              );
              this._shortMonthsParse[i] = new RegExp(
                "^" + this.monthsShort(mom, "").replace(".", "") + "$",
                "i"
              );
            }
            if (!strict && !this._monthsParse[i]) {
              regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
              this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
            }
            if (strict && format2 === "MMMM" && this._longMonthsParse[i].test(monthName)) {
              return i;
            } else if (strict && format2 === "MMM" && this._shortMonthsParse[i].test(monthName)) {
              return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
              return i;
            }
          }
        }
        function setMonth(mom, value) {
          var dayOfMonth;
          if (!mom.isValid()) {
            return mom;
          }
          if (typeof value === "string") {
            if (/^\d+$/.test(value)) {
              value = toInt(value);
            } else {
              value = mom.localeData().monthsParse(value);
              if (!isNumber(value)) {
                return mom;
              }
            }
          }
          dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
          mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
          return mom;
        }
        function getSetMonth(value) {
          if (value != null) {
            setMonth(this, value);
            hooks.updateOffset(this, true);
            return this;
          } else {
            return get(this, "Month");
          }
        }
        function getDaysInMonth() {
          return daysInMonth(this.year(), this.month());
        }
        function monthsShortRegex(isStrict) {
          if (this._monthsParseExact) {
            if (!hasOwnProp(this, "_monthsRegex")) {
              computeMonthsParse.call(this);
            }
            if (isStrict) {
              return this._monthsShortStrictRegex;
            } else {
              return this._monthsShortRegex;
            }
          } else {
            if (!hasOwnProp(this, "_monthsShortRegex")) {
              this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
          }
        }
        function monthsRegex(isStrict) {
          if (this._monthsParseExact) {
            if (!hasOwnProp(this, "_monthsRegex")) {
              computeMonthsParse.call(this);
            }
            if (isStrict) {
              return this._monthsStrictRegex;
            } else {
              return this._monthsRegex;
            }
          } else {
            if (!hasOwnProp(this, "_monthsRegex")) {
              this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
          }
        }
        function computeMonthsParse() {
          function cmpLenRev(a, b) {
            return b.length - a.length;
          }
          var shortPieces = [], longPieces = [], mixedPieces = [], i, mom;
          for (i = 0; i < 12; i++) {
            mom = createUTC([2e3, i]);
            shortPieces.push(this.monthsShort(mom, ""));
            longPieces.push(this.months(mom, ""));
            mixedPieces.push(this.months(mom, ""));
            mixedPieces.push(this.monthsShort(mom, ""));
          }
          shortPieces.sort(cmpLenRev);
          longPieces.sort(cmpLenRev);
          mixedPieces.sort(cmpLenRev);
          for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
          }
          for (i = 0; i < 24; i++) {
            mixedPieces[i] = regexEscape(mixedPieces[i]);
          }
          this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
          this._monthsShortRegex = this._monthsRegex;
          this._monthsStrictRegex = new RegExp(
            "^(" + longPieces.join("|") + ")",
            "i"
          );
          this._monthsShortStrictRegex = new RegExp(
            "^(" + shortPieces.join("|") + ")",
            "i"
          );
        }
        addFormatToken("Y", 0, 0, function() {
          var y = this.year();
          return y <= 9999 ? zeroFill(y, 4) : "+" + y;
        });
        addFormatToken(0, ["YY", 2], 0, function() {
          return this.year() % 100;
        });
        addFormatToken(0, ["YYYY", 4], 0, "year");
        addFormatToken(0, ["YYYYY", 5], 0, "year");
        addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
        addUnitAlias("year", "y");
        addUnitPriority("year", 1);
        addRegexToken("Y", matchSigned);
        addRegexToken("YY", match1to2, match2);
        addRegexToken("YYYY", match1to4, match4);
        addRegexToken("YYYYY", match1to6, match6);
        addRegexToken("YYYYYY", match1to6, match6);
        addParseToken(["YYYYY", "YYYYYY"], YEAR);
        addParseToken("YYYY", function(input, array) {
          array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
        });
        addParseToken("YY", function(input, array) {
          array[YEAR] = hooks.parseTwoDigitYear(input);
        });
        addParseToken("Y", function(input, array) {
          array[YEAR] = parseInt(input, 10);
        });
        function daysInYear(year) {
          return isLeapYear(year) ? 366 : 365;
        }
        hooks.parseTwoDigitYear = function(input) {
          return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
        };
        var getSetYear = makeGetSet("FullYear", true);
        function getIsLeapYear() {
          return isLeapYear(this.year());
        }
        function createDate(y, m, d, h, M, s, ms) {
          var date;
          if (y < 100 && y >= 0) {
            date = new Date(y + 400, m, d, h, M, s, ms);
            if (isFinite(date.getFullYear())) {
              date.setFullYear(y);
            }
          } else {
            date = new Date(y, m, d, h, M, s, ms);
          }
          return date;
        }
        function createUTCDate(y) {
          var date, args;
          if (y < 100 && y >= 0) {
            args = Array.prototype.slice.call(arguments);
            args[0] = y + 400;
            date = new Date(Date.UTC.apply(null, args));
            if (isFinite(date.getUTCFullYear())) {
              date.setUTCFullYear(y);
            }
          } else {
            date = new Date(Date.UTC.apply(null, arguments));
          }
          return date;
        }
        function firstWeekOffset(year, dow, doy) {
          var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
          return -fwdlw + fwd - 1;
        }
        function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
          var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
          if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
          } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
          } else {
            resYear = year;
            resDayOfYear = dayOfYear;
          }
          return {
            year: resYear,
            dayOfYear: resDayOfYear
          };
        }
        function weekOfYear(mom, dow, doy) {
          var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
          if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
          } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
          } else {
            resYear = mom.year();
            resWeek = week;
          }
          return {
            week: resWeek,
            year: resYear
          };
        }
        function weeksInYear(year, dow, doy) {
          var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
          return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
        }
        addFormatToken("w", ["ww", 2], "wo", "week");
        addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
        addUnitAlias("week", "w");
        addUnitAlias("isoWeek", "W");
        addUnitPriority("week", 5);
        addUnitPriority("isoWeek", 5);
        addRegexToken("w", match1to2);
        addRegexToken("ww", match1to2, match2);
        addRegexToken("W", match1to2);
        addRegexToken("WW", match1to2, match2);
        addWeekParseToken(
          ["w", "ww", "W", "WW"],
          function(input, week, config, token3) {
            week[token3.substr(0, 1)] = toInt(input);
          }
        );
        function localeWeek(mom) {
          return weekOfYear(mom, this._week.dow, this._week.doy).week;
        }
        var defaultLocaleWeek = {
          dow: 0,
          // Sunday is the first day of the week.
          doy: 6
          // The week that contains Jan 6th is the first week of the year.
        };
        function localeFirstDayOfWeek() {
          return this._week.dow;
        }
        function localeFirstDayOfYear() {
          return this._week.doy;
        }
        function getSetWeek(input) {
          var week = this.localeData().week(this);
          return input == null ? week : this.add((input - week) * 7, "d");
        }
        function getSetISOWeek(input) {
          var week = weekOfYear(this, 1, 4).week;
          return input == null ? week : this.add((input - week) * 7, "d");
        }
        addFormatToken("d", 0, "do", "day");
        addFormatToken("dd", 0, 0, function(format2) {
          return this.localeData().weekdaysMin(this, format2);
        });
        addFormatToken("ddd", 0, 0, function(format2) {
          return this.localeData().weekdaysShort(this, format2);
        });
        addFormatToken("dddd", 0, 0, function(format2) {
          return this.localeData().weekdays(this, format2);
        });
        addFormatToken("e", 0, 0, "weekday");
        addFormatToken("E", 0, 0, "isoWeekday");
        addUnitAlias("day", "d");
        addUnitAlias("weekday", "e");
        addUnitAlias("isoWeekday", "E");
        addUnitPriority("day", 11);
        addUnitPriority("weekday", 11);
        addUnitPriority("isoWeekday", 11);
        addRegexToken("d", match1to2);
        addRegexToken("e", match1to2);
        addRegexToken("E", match1to2);
        addRegexToken("dd", function(isStrict, locale2) {
          return locale2.weekdaysMinRegex(isStrict);
        });
        addRegexToken("ddd", function(isStrict, locale2) {
          return locale2.weekdaysShortRegex(isStrict);
        });
        addRegexToken("dddd", function(isStrict, locale2) {
          return locale2.weekdaysRegex(isStrict);
        });
        addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config, token3) {
          var weekday = config._locale.weekdaysParse(input, token3, config._strict);
          if (weekday != null) {
            week.d = weekday;
          } else {
            getParsingFlags(config).invalidWeekday = input;
          }
        });
        addWeekParseToken(["d", "e", "E"], function(input, week, config, token3) {
          week[token3] = toInt(input);
        });
        function parseWeekday(input, locale2) {
          if (typeof input !== "string") {
            return input;
          }
          if (!isNaN(input)) {
            return parseInt(input, 10);
          }
          input = locale2.weekdaysParse(input);
          if (typeof input === "number") {
            return input;
          }
          return null;
        }
        function parseIsoWeekday(input, locale2) {
          if (typeof input === "string") {
            return locale2.weekdaysParse(input) % 7 || 7;
          }
          return isNaN(input) ? null : input;
        }
        function shiftWeekdays(ws, n) {
          return ws.slice(n, 7).concat(ws.slice(0, n));
        }
        var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
        function localeWeekdays(m, format2) {
          var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format2) ? "format" : "standalone"];
          return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
        }
        function localeWeekdaysShort(m) {
          return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
        }
        function localeWeekdaysMin(m) {
          return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
        }
        function handleStrictParse$1(weekdayName, format2, strict) {
          var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
          if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];
            for (i = 0; i < 7; ++i) {
              mom = createUTC([2e3, 1]).day(i);
              this._minWeekdaysParse[i] = this.weekdaysMin(
                mom,
                ""
              ).toLocaleLowerCase();
              this._shortWeekdaysParse[i] = this.weekdaysShort(
                mom,
                ""
              ).toLocaleLowerCase();
              this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
            }
          }
          if (strict) {
            if (format2 === "dddd") {
              ii = indexOf.call(this._weekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else if (format2 === "ddd") {
              ii = indexOf.call(this._shortWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf.call(this._minWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            }
          } else {
            if (format2 === "dddd") {
              ii = indexOf.call(this._weekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._shortWeekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._minWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else if (format2 === "ddd") {
              ii = indexOf.call(this._shortWeekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._weekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._minWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf.call(this._minWeekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._weekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._shortWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            }
          }
        }
        function localeWeekdaysParse(weekdayName, format2, strict) {
          var i, mom, regex;
          if (this._weekdaysParseExact) {
            return handleStrictParse$1.call(this, weekdayName, format2, strict);
          }
          if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
          }
          for (i = 0; i < 7; i++) {
            mom = createUTC([2e3, 1]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
              this._fullWeekdaysParse[i] = new RegExp(
                "^" + this.weekdays(mom, "").replace(".", "\\.?") + "$",
                "i"
              );
              this._shortWeekdaysParse[i] = new RegExp(
                "^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$",
                "i"
              );
              this._minWeekdaysParse[i] = new RegExp(
                "^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$",
                "i"
              );
            }
            if (!this._weekdaysParse[i]) {
              regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
              this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
            }
            if (strict && format2 === "dddd" && this._fullWeekdaysParse[i].test(weekdayName)) {
              return i;
            } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i].test(weekdayName)) {
              return i;
            } else if (strict && format2 === "dd" && this._minWeekdaysParse[i].test(weekdayName)) {
              return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
              return i;
            }
          }
        }
        function getSetDayOfWeek(input) {
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }
          var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
          if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, "d");
          } else {
            return day;
          }
        }
        function getSetLocaleDayOfWeek(input) {
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }
          var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
          return input == null ? weekday : this.add(input - weekday, "d");
        }
        function getSetISODayOfWeek(input) {
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }
          if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
          } else {
            return this.day() || 7;
          }
        }
        function weekdaysRegex(isStrict) {
          if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, "_weekdaysRegex")) {
              computeWeekdaysParse.call(this);
            }
            if (isStrict) {
              return this._weekdaysStrictRegex;
            } else {
              return this._weekdaysRegex;
            }
          } else {
            if (!hasOwnProp(this, "_weekdaysRegex")) {
              this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
          }
        }
        function weekdaysShortRegex(isStrict) {
          if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, "_weekdaysRegex")) {
              computeWeekdaysParse.call(this);
            }
            if (isStrict) {
              return this._weekdaysShortStrictRegex;
            } else {
              return this._weekdaysShortRegex;
            }
          } else {
            if (!hasOwnProp(this, "_weekdaysShortRegex")) {
              this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
          }
        }
        function weekdaysMinRegex(isStrict) {
          if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, "_weekdaysRegex")) {
              computeWeekdaysParse.call(this);
            }
            if (isStrict) {
              return this._weekdaysMinStrictRegex;
            } else {
              return this._weekdaysMinRegex;
            }
          } else {
            if (!hasOwnProp(this, "_weekdaysMinRegex")) {
              this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
          }
        }
        function computeWeekdaysParse() {
          function cmpLenRev(a, b) {
            return b.length - a.length;
          }
          var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
          for (i = 0; i < 7; i++) {
            mom = createUTC([2e3, 1]).day(i);
            minp = regexEscape(this.weekdaysMin(mom, ""));
            shortp = regexEscape(this.weekdaysShort(mom, ""));
            longp = regexEscape(this.weekdays(mom, ""));
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
          }
          minPieces.sort(cmpLenRev);
          shortPieces.sort(cmpLenRev);
          longPieces.sort(cmpLenRev);
          mixedPieces.sort(cmpLenRev);
          this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
          this._weekdaysShortRegex = this._weekdaysRegex;
          this._weekdaysMinRegex = this._weekdaysRegex;
          this._weekdaysStrictRegex = new RegExp(
            "^(" + longPieces.join("|") + ")",
            "i"
          );
          this._weekdaysShortStrictRegex = new RegExp(
            "^(" + shortPieces.join("|") + ")",
            "i"
          );
          this._weekdaysMinStrictRegex = new RegExp(
            "^(" + minPieces.join("|") + ")",
            "i"
          );
        }
        function hFormat() {
          return this.hours() % 12 || 12;
        }
        function kFormat() {
          return this.hours() || 24;
        }
        addFormatToken("H", ["HH", 2], 0, "hour");
        addFormatToken("h", ["hh", 2], 0, hFormat);
        addFormatToken("k", ["kk", 2], 0, kFormat);
        addFormatToken("hmm", 0, 0, function() {
          return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
        });
        addFormatToken("hmmss", 0, 0, function() {
          return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
        });
        addFormatToken("Hmm", 0, 0, function() {
          return "" + this.hours() + zeroFill(this.minutes(), 2);
        });
        addFormatToken("Hmmss", 0, 0, function() {
          return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
        });
        function meridiem(token3, lowercase) {
          addFormatToken(token3, 0, 0, function() {
            return this.localeData().meridiem(
              this.hours(),
              this.minutes(),
              lowercase
            );
          });
        }
        meridiem("a", true);
        meridiem("A", false);
        addUnitAlias("hour", "h");
        addUnitPriority("hour", 13);
        function matchMeridiem(isStrict, locale2) {
          return locale2._meridiemParse;
        }
        addRegexToken("a", matchMeridiem);
        addRegexToken("A", matchMeridiem);
        addRegexToken("H", match1to2);
        addRegexToken("h", match1to2);
        addRegexToken("k", match1to2);
        addRegexToken("HH", match1to2, match2);
        addRegexToken("hh", match1to2, match2);
        addRegexToken("kk", match1to2, match2);
        addRegexToken("hmm", match3to4);
        addRegexToken("hmmss", match5to6);
        addRegexToken("Hmm", match3to4);
        addRegexToken("Hmmss", match5to6);
        addParseToken(["H", "HH"], HOUR);
        addParseToken(["k", "kk"], function(input, array, config) {
          var kInput = toInt(input);
          array[HOUR] = kInput === 24 ? 0 : kInput;
        });
        addParseToken(["a", "A"], function(input, array, config) {
          config._isPm = config._locale.isPM(input);
          config._meridiem = input;
        });
        addParseToken(["h", "hh"], function(input, array, config) {
          array[HOUR] = toInt(input);
          getParsingFlags(config).bigHour = true;
        });
        addParseToken("hmm", function(input, array, config) {
          var pos = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos));
          array[MINUTE] = toInt(input.substr(pos));
          getParsingFlags(config).bigHour = true;
        });
        addParseToken("hmmss", function(input, array, config) {
          var pos1 = input.length - 4, pos2 = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos1));
          array[MINUTE] = toInt(input.substr(pos1, 2));
          array[SECOND] = toInt(input.substr(pos2));
          getParsingFlags(config).bigHour = true;
        });
        addParseToken("Hmm", function(input, array, config) {
          var pos = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos));
          array[MINUTE] = toInt(input.substr(pos));
        });
        addParseToken("Hmmss", function(input, array, config) {
          var pos1 = input.length - 4, pos2 = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos1));
          array[MINUTE] = toInt(input.substr(pos1, 2));
          array[SECOND] = toInt(input.substr(pos2));
        });
        function localeIsPM(input) {
          return (input + "").toLowerCase().charAt(0) === "p";
        }
        var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
        function localeMeridiem(hours2, minutes2, isLower) {
          if (hours2 > 11) {
            return isLower ? "pm" : "PM";
          } else {
            return isLower ? "am" : "AM";
          }
        }
        var baseConfig = {
          calendar: defaultCalendar,
          longDateFormat: defaultLongDateFormat,
          invalidDate: defaultInvalidDate,
          ordinal: defaultOrdinal,
          dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
          relativeTime: defaultRelativeTime,
          months: defaultLocaleMonths,
          monthsShort: defaultLocaleMonthsShort,
          week: defaultLocaleWeek,
          weekdays: defaultLocaleWeekdays,
          weekdaysMin: defaultLocaleWeekdaysMin,
          weekdaysShort: defaultLocaleWeekdaysShort,
          meridiemParse: defaultLocaleMeridiemParse
        };
        var locales = {}, localeFamilies = {}, globalLocale;
        function commonPrefix(arr1, arr2) {
          var i, minl = Math.min(arr1.length, arr2.length);
          for (i = 0; i < minl; i += 1) {
            if (arr1[i] !== arr2[i]) {
              return i;
            }
          }
          return minl;
        }
        function normalizeLocale(key) {
          return key ? key.toLowerCase().replace("_", "-") : key;
        }
        function chooseLocale(names) {
          var i = 0, j, next, locale2, split;
          while (i < names.length) {
            split = normalizeLocale(names[i]).split("-");
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split("-") : null;
            while (j > 0) {
              locale2 = loadLocale(split.slice(0, j).join("-"));
              if (locale2) {
                return locale2;
              }
              if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
                break;
              }
              j--;
            }
            i++;
          }
          return globalLocale;
        }
        function isLocaleNameSane(name) {
          return name.match("^[^/\\\\]*$") != null;
        }
        function loadLocale(name) {
          var oldLocale = null, aliasedRequire;
          if (locales[name] === void 0 && typeof module !== "undefined" && module && module.exports && isLocaleNameSane(name)) {
            try {
              oldLocale = globalLocale._abbr;
              aliasedRequire = __require;
              aliasedRequire("./locale/" + name);
              getSetGlobalLocale(oldLocale);
            } catch (e) {
              locales[name] = null;
            }
          }
          return locales[name];
        }
        function getSetGlobalLocale(key, values) {
          var data;
          if (key) {
            if (isUndefined(values)) {
              data = getLocale(key);
            } else {
              data = defineLocale(key, values);
            }
            if (data) {
              globalLocale = data;
            } else {
              if (typeof console !== "undefined" && console.warn) {
                console.warn(
                  "Locale " + key + " not found. Did you forget to load it?"
                );
              }
            }
          }
          return globalLocale._abbr;
        }
        function defineLocale(name, config) {
          if (config !== null) {
            var locale2, parentConfig = baseConfig;
            config.abbr = name;
            if (locales[name] != null) {
              deprecateSimple(
                "defineLocaleOverride",
                "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
              );
              parentConfig = locales[name]._config;
            } else if (config.parentLocale != null) {
              if (locales[config.parentLocale] != null) {
                parentConfig = locales[config.parentLocale]._config;
              } else {
                locale2 = loadLocale(config.parentLocale);
                if (locale2 != null) {
                  parentConfig = locale2._config;
                } else {
                  if (!localeFamilies[config.parentLocale]) {
                    localeFamilies[config.parentLocale] = [];
                  }
                  localeFamilies[config.parentLocale].push({
                    name,
                    config
                  });
                  return null;
                }
              }
            }
            locales[name] = new Locale(mergeConfigs(parentConfig, config));
            if (localeFamilies[name]) {
              localeFamilies[name].forEach(function(x) {
                defineLocale(x.name, x.config);
              });
            }
            getSetGlobalLocale(name);
            return locales[name];
          } else {
            delete locales[name];
            return null;
          }
        }
        function updateLocale(name, config) {
          if (config != null) {
            var locale2, tmpLocale, parentConfig = baseConfig;
            if (locales[name] != null && locales[name].parentLocale != null) {
              locales[name].set(mergeConfigs(locales[name]._config, config));
            } else {
              tmpLocale = loadLocale(name);
              if (tmpLocale != null) {
                parentConfig = tmpLocale._config;
              }
              config = mergeConfigs(parentConfig, config);
              if (tmpLocale == null) {
                config.abbr = name;
              }
              locale2 = new Locale(config);
              locale2.parentLocale = locales[name];
              locales[name] = locale2;
            }
            getSetGlobalLocale(name);
          } else {
            if (locales[name] != null) {
              if (locales[name].parentLocale != null) {
                locales[name] = locales[name].parentLocale;
                if (name === getSetGlobalLocale()) {
                  getSetGlobalLocale(name);
                }
              } else if (locales[name] != null) {
                delete locales[name];
              }
            }
          }
          return locales[name];
        }
        function getLocale(key) {
          var locale2;
          if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
          }
          if (!key) {
            return globalLocale;
          }
          if (!isArray(key)) {
            locale2 = loadLocale(key);
            if (locale2) {
              return locale2;
            }
            key = [key];
          }
          return chooseLocale(key);
        }
        function listLocales() {
          return keys(locales);
        }
        function checkOverflow(m) {
          var overflow, a = m._a;
          if (a && getParsingFlags(m).overflow === -2) {
            overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
              overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
              overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
              overflow = WEEKDAY;
            }
            getParsingFlags(m).overflow = overflow;
          }
          return m;
        }
        var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
          ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
          ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
          ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
          ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
          ["YYYY-DDD", /\d{4}-\d{3}/],
          ["YYYY-MM", /\d{4}-\d\d/, false],
          ["YYYYYYMMDD", /[+-]\d{10}/],
          ["YYYYMMDD", /\d{8}/],
          ["GGGG[W]WWE", /\d{4}W\d{3}/],
          ["GGGG[W]WW", /\d{4}W\d{2}/, false],
          ["YYYYDDD", /\d{7}/],
          ["YYYYMM", /\d{6}/, false],
          ["YYYY", /\d{4}/, false]
        ], isoTimes = [
          ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
          ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
          ["HH:mm:ss", /\d\d:\d\d:\d\d/],
          ["HH:mm", /\d\d:\d\d/],
          ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
          ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
          ["HHmmss", /\d\d\d\d\d\d/],
          ["HHmm", /\d\d\d\d/],
          ["HH", /\d\d/]
        ], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
          UT: 0,
          GMT: 0,
          EDT: -4 * 60,
          EST: -5 * 60,
          CDT: -5 * 60,
          CST: -6 * 60,
          MDT: -6 * 60,
          MST: -7 * 60,
          PDT: -7 * 60,
          PST: -8 * 60
        };
        function configFromISO(config) {
          var i, l, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
          if (match) {
            getParsingFlags(config).iso = true;
            for (i = 0, l = isoDatesLen; i < l; i++) {
              if (isoDates[i][1].exec(match[1])) {
                dateFormat = isoDates[i][0];
                allowTime = isoDates[i][2] !== false;
                break;
              }
            }
            if (dateFormat == null) {
              config._isValid = false;
              return;
            }
            if (match[3]) {
              for (i = 0, l = isoTimesLen; i < l; i++) {
                if (isoTimes[i][1].exec(match[3])) {
                  timeFormat = (match[2] || " ") + isoTimes[i][0];
                  break;
                }
              }
              if (timeFormat == null) {
                config._isValid = false;
                return;
              }
            }
            if (!allowTime && timeFormat != null) {
              config._isValid = false;
              return;
            }
            if (match[4]) {
              if (tzRegex.exec(match[4])) {
                tzFormat = "Z";
              } else {
                config._isValid = false;
                return;
              }
            }
            config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
            configFromStringAndFormat(config);
          } else {
            config._isValid = false;
          }
        }
        function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
          var result = [
            untruncateYear(yearStr),
            defaultLocaleMonthsShort.indexOf(monthStr),
            parseInt(dayStr, 10),
            parseInt(hourStr, 10),
            parseInt(minuteStr, 10)
          ];
          if (secondStr) {
            result.push(parseInt(secondStr, 10));
          }
          return result;
        }
        function untruncateYear(yearStr) {
          var year = parseInt(yearStr, 10);
          if (year <= 49) {
            return 2e3 + year;
          } else if (year <= 999) {
            return 1900 + year;
          }
          return year;
        }
        function preprocessRFC2822(s) {
          return s.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
        }
        function checkWeekday(weekdayStr, parsedInput, config) {
          if (weekdayStr) {
            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(
              parsedInput[0],
              parsedInput[1],
              parsedInput[2]
            ).getDay();
            if (weekdayProvided !== weekdayActual) {
              getParsingFlags(config).weekdayMismatch = true;
              config._isValid = false;
              return false;
            }
          }
          return true;
        }
        function calculateOffset(obsOffset, militaryOffset, numOffset) {
          if (obsOffset) {
            return obsOffsets[obsOffset];
          } else if (militaryOffset) {
            return 0;
          } else {
            var hm = parseInt(numOffset, 10), m = hm % 100, h = (hm - m) / 100;
            return h * 60 + m;
          }
        }
        function configFromRFC2822(config) {
          var match = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;
          if (match) {
            parsedArray = extractFromRFC2822Strings(
              match[4],
              match[3],
              match[2],
              match[5],
              match[6],
              match[7]
            );
            if (!checkWeekday(match[1], parsedArray, config)) {
              return;
            }
            config._a = parsedArray;
            config._tzm = calculateOffset(match[8], match[9], match[10]);
            config._d = createUTCDate.apply(null, config._a);
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
            getParsingFlags(config).rfc2822 = true;
          } else {
            config._isValid = false;
          }
        }
        function configFromString(config) {
          var matched = aspNetJsonRegex.exec(config._i);
          if (matched !== null) {
            config._d = /* @__PURE__ */ new Date(+matched[1]);
            return;
          }
          configFromISO(config);
          if (config._isValid === false) {
            delete config._isValid;
          } else {
            return;
          }
          configFromRFC2822(config);
          if (config._isValid === false) {
            delete config._isValid;
          } else {
            return;
          }
          if (config._strict) {
            config._isValid = false;
          } else {
            hooks.createFromInputFallback(config);
          }
        }
        hooks.createFromInputFallback = deprecate(
          "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
          function(config) {
            config._d = /* @__PURE__ */ new Date(config._i + (config._useUTC ? " UTC" : ""));
          }
        );
        function defaults(a, b, c) {
          if (a != null) {
            return a;
          }
          if (b != null) {
            return b;
          }
          return c;
        }
        function currentDateArray(config) {
          var nowValue = new Date(hooks.now());
          if (config._useUTC) {
            return [
              nowValue.getUTCFullYear(),
              nowValue.getUTCMonth(),
              nowValue.getUTCDate()
            ];
          }
          return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
        }
        function configFromArray(config) {
          var i, date, input = [], currentDate, expectedWeekday, yearToUse;
          if (config._d) {
            return;
          }
          currentDate = currentDateArray(config);
          if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
          }
          if (config._dayOfYear != null) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
            if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
              getParsingFlags(config)._overflowDayOfYear = true;
            }
            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
          }
          for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
          }
          for (; i < 7; i++) {
            config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
          }
          if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
          }
          config._d = (config._useUTC ? createUTCDate : createDate).apply(
            null,
            input
          );
          expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
          if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
          }
          if (config._nextDay) {
            config._a[HOUR] = 24;
          }
          if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
            getParsingFlags(config).weekdayMismatch = true;
          }
        }
        function dayOfYearFromWeekInfo(config) {
          var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
          w = config._w;
          if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;
            weekYear = defaults(
              w.GG,
              config._a[YEAR],
              weekOfYear(createLocal(), 1, 4).year
            );
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday < 1 || weekday > 7) {
              weekdayOverflow = true;
            }
          } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;
            curWeek = weekOfYear(createLocal(), dow, doy);
            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);
            week = defaults(w.w, curWeek.week);
            if (w.d != null) {
              weekday = w.d;
              if (weekday < 0 || weekday > 6) {
                weekdayOverflow = true;
              }
            } else if (w.e != null) {
              weekday = w.e + dow;
              if (w.e < 0 || w.e > 6) {
                weekdayOverflow = true;
              }
            } else {
              weekday = dow;
            }
          }
          if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
          } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
          } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
          }
        }
        hooks.ISO_8601 = function() {
        };
        hooks.RFC_2822 = function() {
        };
        function configFromStringAndFormat(config) {
          if (config._f === hooks.ISO_8601) {
            configFromISO(config);
            return;
          }
          if (config._f === hooks.RFC_2822) {
            configFromRFC2822(config);
            return;
          }
          config._a = [];
          getParsingFlags(config).empty = true;
          var string = "" + config._i, i, parsedInput, tokens2, token3, skipped, stringLength = string.length, totalParsedInputLength = 0, era, tokenLen;
          tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
          tokenLen = tokens2.length;
          for (i = 0; i < tokenLen; i++) {
            token3 = tokens2[i];
            parsedInput = (string.match(getParseRegexForToken(token3, config)) || [])[0];
            if (parsedInput) {
              skipped = string.substr(0, string.indexOf(parsedInput));
              if (skipped.length > 0) {
                getParsingFlags(config).unusedInput.push(skipped);
              }
              string = string.slice(
                string.indexOf(parsedInput) + parsedInput.length
              );
              totalParsedInputLength += parsedInput.length;
            }
            if (formatTokenFunctions[token3]) {
              if (parsedInput) {
                getParsingFlags(config).empty = false;
              } else {
                getParsingFlags(config).unusedTokens.push(token3);
              }
              addTimeToArrayFromToken(token3, parsedInput, config);
            } else if (config._strict && !parsedInput) {
              getParsingFlags(config).unusedTokens.push(token3);
            }
          }
          getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
          if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
          }
          if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = void 0;
          }
          getParsingFlags(config).parsedDateParts = config._a.slice(0);
          getParsingFlags(config).meridiem = config._meridiem;
          config._a[HOUR] = meridiemFixWrap(
            config._locale,
            config._a[HOUR],
            config._meridiem
          );
          era = getParsingFlags(config).era;
          if (era !== null) {
            config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
          }
          configFromArray(config);
          checkOverflow(config);
        }
        function meridiemFixWrap(locale2, hour, meridiem2) {
          var isPm;
          if (meridiem2 == null) {
            return hour;
          }
          if (locale2.meridiemHour != null) {
            return locale2.meridiemHour(hour, meridiem2);
          } else if (locale2.isPM != null) {
            isPm = locale2.isPM(meridiem2);
            if (isPm && hour < 12) {
              hour += 12;
            }
            if (!isPm && hour === 12) {
              hour = 0;
            }
            return hour;
          } else {
            return hour;
          }
        }
        function configFromStringAndArray(config) {
          var tempConfig, bestMoment, scoreToBeat, i, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config._f.length;
          if (configfLen === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = /* @__PURE__ */ new Date(NaN);
            return;
          }
          for (i = 0; i < configfLen; i++) {
            currentScore = 0;
            validFormatFound = false;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
              tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);
            if (isValid(tempConfig)) {
              validFormatFound = true;
            }
            currentScore += getParsingFlags(tempConfig).charsLeftOver;
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
            getParsingFlags(tempConfig).score = currentScore;
            if (!bestFormatIsValid) {
              if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
                if (validFormatFound) {
                  bestFormatIsValid = true;
                }
              }
            } else {
              if (currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
              }
            }
          }
          extend(config, bestMoment || tempConfig);
        }
        function configFromObject(config) {
          if (config._d) {
            return;
          }
          var i = normalizeObjectUnits(config._i), dayOrDate = i.day === void 0 ? i.date : i.day;
          config._a = map(
            [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
            function(obj) {
              return obj && parseInt(obj, 10);
            }
          );
          configFromArray(config);
        }
        function createFromConfig(config) {
          var res = new Moment(checkOverflow(prepareConfig(config)));
          if (res._nextDay) {
            res.add(1, "d");
            res._nextDay = void 0;
          }
          return res;
        }
        function prepareConfig(config) {
          var input = config._i, format2 = config._f;
          config._locale = config._locale || getLocale(config._l);
          if (input === null || format2 === void 0 && input === "") {
            return createInvalid({ nullInput: true });
          }
          if (typeof input === "string") {
            config._i = input = config._locale.preparse(input);
          }
          if (isMoment(input)) {
            return new Moment(checkOverflow(input));
          } else if (isDate(input)) {
            config._d = input;
          } else if (isArray(format2)) {
            configFromStringAndArray(config);
          } else if (format2) {
            configFromStringAndFormat(config);
          } else {
            configFromInput(config);
          }
          if (!isValid(config)) {
            config._d = null;
          }
          return config;
        }
        function configFromInput(config) {
          var input = config._i;
          if (isUndefined(input)) {
            config._d = new Date(hooks.now());
          } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
          } else if (typeof input === "string") {
            configFromString(config);
          } else if (isArray(input)) {
            config._a = map(input.slice(0), function(obj) {
              return parseInt(obj, 10);
            });
            configFromArray(config);
          } else if (isObject(input)) {
            configFromObject(config);
          } else if (isNumber(input)) {
            config._d = new Date(input);
          } else {
            hooks.createFromInputFallback(config);
          }
        }
        function createLocalOrUTC(input, format2, locale2, strict, isUTC) {
          var c = {};
          if (format2 === true || format2 === false) {
            strict = format2;
            format2 = void 0;
          }
          if (locale2 === true || locale2 === false) {
            strict = locale2;
            locale2 = void 0;
          }
          if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
            input = void 0;
          }
          c._isAMomentObject = true;
          c._useUTC = c._isUTC = isUTC;
          c._l = locale2;
          c._i = input;
          c._f = format2;
          c._strict = strict;
          return createFromConfig(c);
        }
        function createLocal(input, format2, locale2, strict) {
          return createLocalOrUTC(input, format2, locale2, strict, false);
        }
        var prototypeMin = deprecate(
          "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
          function() {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
              return other < this ? this : other;
            } else {
              return createInvalid();
            }
          }
        ), prototypeMax = deprecate(
          "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
          function() {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
              return other > this ? this : other;
            } else {
              return createInvalid();
            }
          }
        );
        function pickBy(fn, moments) {
          var res, i;
          if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
          }
          if (!moments.length) {
            return createLocal();
          }
          res = moments[0];
          for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
              res = moments[i];
            }
          }
          return res;
        }
        function min() {
          var args = [].slice.call(arguments, 0);
          return pickBy("isBefore", args);
        }
        function max() {
          var args = [].slice.call(arguments, 0);
          return pickBy("isAfter", args);
        }
        var now = function() {
          return Date.now ? Date.now() : +/* @__PURE__ */ new Date();
        };
        var ordering = [
          "year",
          "quarter",
          "month",
          "week",
          "day",
          "hour",
          "minute",
          "second",
          "millisecond"
        ];
        function isDurationValid(m) {
          var key, unitHasDecimal = false, i, orderLen = ordering.length;
          for (key in m) {
            if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
              return false;
            }
          }
          for (i = 0; i < orderLen; ++i) {
            if (m[ordering[i]]) {
              if (unitHasDecimal) {
                return false;
              }
              if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                unitHasDecimal = true;
              }
            }
          }
          return true;
        }
        function isValid$1() {
          return this._isValid;
        }
        function createInvalid$1() {
          return createDuration(NaN);
        }
        function Duration(duration) {
          var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
          this._isValid = isDurationValid(normalizedInput);
          this._milliseconds = +milliseconds2 + seconds2 * 1e3 + // 1000
          minutes2 * 6e4 + // 1000 * 60
          hours2 * 1e3 * 60 * 60;
          this._days = +days2 + weeks2 * 7;
          this._months = +months2 + quarters * 3 + years2 * 12;
          this._data = {};
          this._locale = getLocale();
          this._bubble();
        }
        function isDuration(obj) {
          return obj instanceof Duration;
        }
        function absRound(number) {
          if (number < 0) {
            return Math.round(-1 * number) * -1;
          } else {
            return Math.round(number);
          }
        }
        function compareArrays(array1, array2, dontConvert) {
          var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
          for (i = 0; i < len; i++) {
            if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
              diffs++;
            }
          }
          return diffs + lengthDiff;
        }
        function offset(token3, separator) {
          addFormatToken(token3, 0, 0, function() {
            var offset2 = this.utcOffset(), sign2 = "+";
            if (offset2 < 0) {
              offset2 = -offset2;
              sign2 = "-";
            }
            return sign2 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
          });
        }
        offset("Z", ":");
        offset("ZZ", "");
        addRegexToken("Z", matchShortOffset);
        addRegexToken("ZZ", matchShortOffset);
        addParseToken(["Z", "ZZ"], function(input, array, config) {
          config._useUTC = true;
          config._tzm = offsetFromString(matchShortOffset, input);
        });
        var chunkOffset = /([\+\-]|\d\d)/gi;
        function offsetFromString(matcher, string) {
          var matches = (string || "").match(matcher), chunk, parts, minutes2;
          if (matches === null) {
            return null;
          }
          chunk = matches[matches.length - 1] || [];
          parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
          minutes2 = +(parts[1] * 60) + toInt(parts[2]);
          return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
        }
        function cloneWithOffset(input, model2) {
          var res, diff2;
          if (model2._isUTC) {
            res = model2.clone();
            diff2 = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
            res._d.setTime(res._d.valueOf() + diff2);
            hooks.updateOffset(res, false);
            return res;
          } else {
            return createLocal(input).local();
          }
        }
        function getDateOffset(m) {
          return -Math.round(m._d.getTimezoneOffset());
        }
        hooks.updateOffset = function() {
        };
        function getSetOffset(input, keepLocalTime, keepMinutes) {
          var offset2 = this._offset || 0, localAdjust;
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }
          if (input != null) {
            if (typeof input === "string") {
              input = offsetFromString(matchShortOffset, input);
              if (input === null) {
                return this;
              }
            } else if (Math.abs(input) < 16 && !keepMinutes) {
              input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
              localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
              this.add(localAdjust, "m");
            }
            if (offset2 !== input) {
              if (!keepLocalTime || this._changeInProgress) {
                addSubtract(
                  this,
                  createDuration(input - offset2, "m"),
                  1,
                  false
                );
              } else if (!this._changeInProgress) {
                this._changeInProgress = true;
                hooks.updateOffset(this, true);
                this._changeInProgress = null;
              }
            }
            return this;
          } else {
            return this._isUTC ? offset2 : getDateOffset(this);
          }
        }
        function getSetZone(input, keepLocalTime) {
          if (input != null) {
            if (typeof input !== "string") {
              input = -input;
            }
            this.utcOffset(input, keepLocalTime);
            return this;
          } else {
            return -this.utcOffset();
          }
        }
        function setOffsetToUTC(keepLocalTime) {
          return this.utcOffset(0, keepLocalTime);
        }
        function setOffsetToLocal(keepLocalTime) {
          if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;
            if (keepLocalTime) {
              this.subtract(getDateOffset(this), "m");
            }
          }
          return this;
        }
        function setOffsetToParsedOffset() {
          if (this._tzm != null) {
            this.utcOffset(this._tzm, false, true);
          } else if (typeof this._i === "string") {
            var tZone = offsetFromString(matchOffset, this._i);
            if (tZone != null) {
              this.utcOffset(tZone);
            } else {
              this.utcOffset(0, true);
            }
          }
          return this;
        }
        function hasAlignedHourOffset(input) {
          if (!this.isValid()) {
            return false;
          }
          input = input ? createLocal(input).utcOffset() : 0;
          return (this.utcOffset() - input) % 60 === 0;
        }
        function isDaylightSavingTime() {
          return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
        }
        function isDaylightSavingTimeShifted() {
          if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
          }
          var c = {}, other;
          copyConfig(c, this);
          c = prepareConfig(c);
          if (c._a) {
            other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
            this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
          } else {
            this._isDSTShifted = false;
          }
          return this._isDSTShifted;
        }
        function isLocal() {
          return this.isValid() ? !this._isUTC : false;
        }
        function isUtcOffset() {
          return this.isValid() ? this._isUTC : false;
        }
        function isUtc() {
          return this.isValid() ? this._isUTC && this._offset === 0 : false;
        }
        var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
        function createDuration(input, key) {
          var duration = input, match = null, sign2, ret, diffRes;
          if (isDuration(input)) {
            duration = {
              ms: input._milliseconds,
              d: input._days,
              M: input._months
            };
          } else if (isNumber(input) || !isNaN(+input)) {
            duration = {};
            if (key) {
              duration[key] = +input;
            } else {
              duration.milliseconds = +input;
            }
          } else if (match = aspNetRegex.exec(input)) {
            sign2 = match[1] === "-" ? -1 : 1;
            duration = {
              y: 0,
              d: toInt(match[DATE]) * sign2,
              h: toInt(match[HOUR]) * sign2,
              m: toInt(match[MINUTE]) * sign2,
              s: toInt(match[SECOND]) * sign2,
              ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign2
              // the millisecond decimal point is included in the match
            };
          } else if (match = isoRegex.exec(input)) {
            sign2 = match[1] === "-" ? -1 : 1;
            duration = {
              y: parseIso(match[2], sign2),
              M: parseIso(match[3], sign2),
              w: parseIso(match[4], sign2),
              d: parseIso(match[5], sign2),
              h: parseIso(match[6], sign2),
              m: parseIso(match[7], sign2),
              s: parseIso(match[8], sign2)
            };
          } else if (duration == null) {
            duration = {};
          } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
            diffRes = momentsDifference(
              createLocal(duration.from),
              createLocal(duration.to)
            );
            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
          }
          ret = new Duration(duration);
          if (isDuration(input) && hasOwnProp(input, "_locale")) {
            ret._locale = input._locale;
          }
          if (isDuration(input) && hasOwnProp(input, "_isValid")) {
            ret._isValid = input._isValid;
          }
          return ret;
        }
        createDuration.fn = Duration.prototype;
        createDuration.invalid = createInvalid$1;
        function parseIso(inp, sign2) {
          var res = inp && parseFloat(inp.replace(",", "."));
          return (isNaN(res) ? 0 : res) * sign2;
        }
        function positiveMomentsDifference(base, other) {
          var res = {};
          res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
          if (base.clone().add(res.months, "M").isAfter(other)) {
            --res.months;
          }
          res.milliseconds = +other - +base.clone().add(res.months, "M");
          return res;
        }
        function momentsDifference(base, other) {
          var res;
          if (!(base.isValid() && other.isValid())) {
            return { milliseconds: 0, months: 0 };
          }
          other = cloneWithOffset(other, base);
          if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
          } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
          }
          return res;
        }
        function createAdder(direction, name) {
          return function(val, period) {
            var dur, tmp;
            if (period !== null && !isNaN(+period)) {
              deprecateSimple(
                name,
                "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
              );
              tmp = val;
              val = period;
              period = tmp;
            }
            dur = createDuration(val, period);
            addSubtract(this, dur, direction);
            return this;
          };
        }
        function addSubtract(mom, duration, isAdding, updateOffset) {
          var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
          if (!mom.isValid()) {
            return;
          }
          updateOffset = updateOffset == null ? true : updateOffset;
          if (months2) {
            setMonth(mom, get(mom, "Month") + months2 * isAdding);
          }
          if (days2) {
            set$1(mom, "Date", get(mom, "Date") + days2 * isAdding);
          }
          if (milliseconds2) {
            mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
          }
          if (updateOffset) {
            hooks.updateOffset(mom, days2 || months2);
          }
        }
        var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
        function isString(input) {
          return typeof input === "string" || input instanceof String;
        }
        function isMomentInput(input) {
          return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
        }
        function isMomentInputObject(input) {
          var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
            "years",
            "year",
            "y",
            "months",
            "month",
            "M",
            "days",
            "day",
            "d",
            "dates",
            "date",
            "D",
            "hours",
            "hour",
            "h",
            "minutes",
            "minute",
            "m",
            "seconds",
            "second",
            "s",
            "milliseconds",
            "millisecond",
            "ms"
          ], i, property, propertyLen = properties.length;
          for (i = 0; i < propertyLen; i += 1) {
            property = properties[i];
            propertyTest = propertyTest || hasOwnProp(input, property);
          }
          return objectTest && propertyTest;
        }
        function isNumberOrStringArray(input) {
          var arrayTest = isArray(input), dataTypeTest = false;
          if (arrayTest) {
            dataTypeTest = input.filter(function(item) {
              return !isNumber(item) && isString(input);
            }).length === 0;
          }
          return arrayTest && dataTypeTest;
        }
        function isCalendarSpec(input) {
          var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
            "sameDay",
            "nextDay",
            "lastDay",
            "nextWeek",
            "lastWeek",
            "sameElse"
          ], i, property;
          for (i = 0; i < properties.length; i += 1) {
            property = properties[i];
            propertyTest = propertyTest || hasOwnProp(input, property);
          }
          return objectTest && propertyTest;
        }
        function getCalendarFormat(myMoment, now2) {
          var diff2 = myMoment.diff(now2, "days", true);
          return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
        }
        function calendar$1(time, formats) {
          if (arguments.length === 1) {
            if (!arguments[0]) {
              time = void 0;
              formats = void 0;
            } else if (isMomentInput(arguments[0])) {
              time = arguments[0];
              formats = void 0;
            } else if (isCalendarSpec(arguments[0])) {
              formats = arguments[0];
              time = void 0;
            }
          }
          var now2 = time || createLocal(), sod = cloneWithOffset(now2, this).startOf("day"), format2 = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction(formats[format2]) ? formats[format2].call(this, now2) : formats[format2]);
          return this.format(
            output || this.localeData().calendar(format2, this, createLocal(now2))
          );
        }
        function clone() {
          return new Moment(this);
        }
        function isAfter(input, units) {
          var localInput = isMoment(input) ? input : createLocal(input);
          if (!(this.isValid() && localInput.isValid())) {
            return false;
          }
          units = normalizeUnits(units) || "millisecond";
          if (units === "millisecond") {
            return this.valueOf() > localInput.valueOf();
          } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
          }
        }
        function isBefore(input, units) {
          var localInput = isMoment(input) ? input : createLocal(input);
          if (!(this.isValid() && localInput.isValid())) {
            return false;
          }
          units = normalizeUnits(units) || "millisecond";
          if (units === "millisecond") {
            return this.valueOf() < localInput.valueOf();
          } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
          }
        }
        function isBetween(from2, to2, units, inclusivity) {
          var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
          if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
            return false;
          }
          inclusivity = inclusivity || "()";
          return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
        }
        function isSame(input, units) {
          var localInput = isMoment(input) ? input : createLocal(input), inputMs;
          if (!(this.isValid() && localInput.isValid())) {
            return false;
          }
          units = normalizeUnits(units) || "millisecond";
          if (units === "millisecond") {
            return this.valueOf() === localInput.valueOf();
          } else {
            inputMs = localInput.valueOf();
            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
          }
        }
        function isSameOrAfter(input, units) {
          return this.isSame(input, units) || this.isAfter(input, units);
        }
        function isSameOrBefore(input, units) {
          return this.isSame(input, units) || this.isBefore(input, units);
        }
        function diff(input, units, asFloat) {
          var that, zoneDelta, output;
          if (!this.isValid()) {
            return NaN;
          }
          that = cloneWithOffset(input, this);
          if (!that.isValid()) {
            return NaN;
          }
          zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
          units = normalizeUnits(units);
          switch (units) {
            case "year":
              output = monthDiff(this, that) / 12;
              break;
            case "month":
              output = monthDiff(this, that);
              break;
            case "quarter":
              output = monthDiff(this, that) / 3;
              break;
            case "second":
              output = (this - that) / 1e3;
              break;
            case "minute":
              output = (this - that) / 6e4;
              break;
            case "hour":
              output = (this - that) / 36e5;
              break;
            case "day":
              output = (this - that - zoneDelta) / 864e5;
              break;
            case "week":
              output = (this - that - zoneDelta) / 6048e5;
              break;
            default:
              output = this - that;
          }
          return asFloat ? output : absFloor(output);
        }
        function monthDiff(a, b) {
          if (a.date() < b.date()) {
            return -monthDiff(b, a);
          }
          var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
          if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
            adjust = (b - anchor) / (anchor - anchor2);
          } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
            adjust = (b - anchor) / (anchor2 - anchor);
          }
          return -(wholeMonthDiff + adjust) || 0;
        }
        hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
        hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
        function toString() {
          return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
        }
        function toISOString(keepOffset) {
          if (!this.isValid()) {
            return null;
          }
          var utc = keepOffset !== true, m = utc ? this.clone().utc() : this;
          if (m.year() < 0 || m.year() > 9999) {
            return formatMoment(
              m,
              utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
            );
          }
          if (isFunction(Date.prototype.toISOString)) {
            if (utc) {
              return this.toDate().toISOString();
            } else {
              return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m, "Z"));
            }
          }
          return formatMoment(
            m,
            utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
          );
        }
        function inspect() {
          if (!this.isValid()) {
            return "moment.invalid(/* " + this._i + " */)";
          }
          var func = "moment", zone = "", prefix, year, datetime, suffix;
          if (!this.isLocal()) {
            func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
            zone = "Z";
          }
          prefix = "[" + func + '("]';
          year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
          datetime = "-MM-DD[T]HH:mm:ss.SSS";
          suffix = zone + '[")]';
          return this.format(prefix + year + datetime + suffix);
        }
        function format(inputString) {
          if (!inputString) {
            inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
          }
          var output = formatMoment(this, inputString);
          return this.localeData().postformat(output);
        }
        function from(time, withoutSuffix) {
          if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
            return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
          } else {
            return this.localeData().invalidDate();
          }
        }
        function fromNow(withoutSuffix) {
          return this.from(createLocal(), withoutSuffix);
        }
        function to(time, withoutSuffix) {
          if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
            return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
          } else {
            return this.localeData().invalidDate();
          }
        }
        function toNow(withoutSuffix) {
          return this.to(createLocal(), withoutSuffix);
        }
        function locale(key) {
          var newLocaleData;
          if (key === void 0) {
            return this._locale._abbr;
          } else {
            newLocaleData = getLocale(key);
            if (newLocaleData != null) {
              this._locale = newLocaleData;
            }
            return this;
          }
        }
        var lang = deprecate(
          "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
          function(key) {
            if (key === void 0) {
              return this.localeData();
            } else {
              return this.locale(key);
            }
          }
        );
        function localeData() {
          return this._locale;
        }
        var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
        function mod$1(dividend, divisor) {
          return (dividend % divisor + divisor) % divisor;
        }
        function localStartOfDate(y, m, d) {
          if (y < 100 && y >= 0) {
            return new Date(y + 400, m, d) - MS_PER_400_YEARS;
          } else {
            return new Date(y, m, d).valueOf();
          }
        }
        function utcStartOfDate(y, m, d) {
          if (y < 100 && y >= 0) {
            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
          } else {
            return Date.UTC(y, m, d);
          }
        }
        function startOf(units) {
          var time, startOfDate;
          units = normalizeUnits(units);
          if (units === void 0 || units === "millisecond" || !this.isValid()) {
            return this;
          }
          startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
          switch (units) {
            case "year":
              time = startOfDate(this.year(), 0, 1);
              break;
            case "quarter":
              time = startOfDate(
                this.year(),
                this.month() - this.month() % 3,
                1
              );
              break;
            case "month":
              time = startOfDate(this.year(), this.month(), 1);
              break;
            case "week":
              time = startOfDate(
                this.year(),
                this.month(),
                this.date() - this.weekday()
              );
              break;
            case "isoWeek":
              time = startOfDate(
                this.year(),
                this.month(),
                this.date() - (this.isoWeekday() - 1)
              );
              break;
            case "day":
            case "date":
              time = startOfDate(this.year(), this.month(), this.date());
              break;
            case "hour":
              time = this._d.valueOf();
              time -= mod$1(
                time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                MS_PER_HOUR
              );
              break;
            case "minute":
              time = this._d.valueOf();
              time -= mod$1(time, MS_PER_MINUTE);
              break;
            case "second":
              time = this._d.valueOf();
              time -= mod$1(time, MS_PER_SECOND);
              break;
          }
          this._d.setTime(time);
          hooks.updateOffset(this, true);
          return this;
        }
        function endOf(units) {
          var time, startOfDate;
          units = normalizeUnits(units);
          if (units === void 0 || units === "millisecond" || !this.isValid()) {
            return this;
          }
          startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
          switch (units) {
            case "year":
              time = startOfDate(this.year() + 1, 0, 1) - 1;
              break;
            case "quarter":
              time = startOfDate(
                this.year(),
                this.month() - this.month() % 3 + 3,
                1
              ) - 1;
              break;
            case "month":
              time = startOfDate(this.year(), this.month() + 1, 1) - 1;
              break;
            case "week":
              time = startOfDate(
                this.year(),
                this.month(),
                this.date() - this.weekday() + 7
              ) - 1;
              break;
            case "isoWeek":
              time = startOfDate(
                this.year(),
                this.month(),
                this.date() - (this.isoWeekday() - 1) + 7
              ) - 1;
              break;
            case "day":
            case "date":
              time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
              break;
            case "hour":
              time = this._d.valueOf();
              time += MS_PER_HOUR - mod$1(
                time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                MS_PER_HOUR
              ) - 1;
              break;
            case "minute":
              time = this._d.valueOf();
              time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
              break;
            case "second":
              time = this._d.valueOf();
              time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
              break;
          }
          this._d.setTime(time);
          hooks.updateOffset(this, true);
          return this;
        }
        function valueOf() {
          return this._d.valueOf() - (this._offset || 0) * 6e4;
        }
        function unix() {
          return Math.floor(this.valueOf() / 1e3);
        }
        function toDate() {
          return new Date(this.valueOf());
        }
        function toArray() {
          var m = this;
          return [
            m.year(),
            m.month(),
            m.date(),
            m.hour(),
            m.minute(),
            m.second(),
            m.millisecond()
          ];
        }
        function toObject() {
          var m = this;
          return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
          };
        }
        function toJSON() {
          return this.isValid() ? this.toISOString() : null;
        }
        function isValid$2() {
          return isValid(this);
        }
        function parsingFlags() {
          return extend({}, getParsingFlags(this));
        }
        function invalidAt() {
          return getParsingFlags(this).overflow;
        }
        function creationData() {
          return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
          };
        }
        addFormatToken("N", 0, 0, "eraAbbr");
        addFormatToken("NN", 0, 0, "eraAbbr");
        addFormatToken("NNN", 0, 0, "eraAbbr");
        addFormatToken("NNNN", 0, 0, "eraName");
        addFormatToken("NNNNN", 0, 0, "eraNarrow");
        addFormatToken("y", ["y", 1], "yo", "eraYear");
        addFormatToken("y", ["yy", 2], 0, "eraYear");
        addFormatToken("y", ["yyy", 3], 0, "eraYear");
        addFormatToken("y", ["yyyy", 4], 0, "eraYear");
        addRegexToken("N", matchEraAbbr);
        addRegexToken("NN", matchEraAbbr);
        addRegexToken("NNN", matchEraAbbr);
        addRegexToken("NNNN", matchEraName);
        addRegexToken("NNNNN", matchEraNarrow);
        addParseToken(
          ["N", "NN", "NNN", "NNNN", "NNNNN"],
          function(input, array, config, token3) {
            var era = config._locale.erasParse(input, token3, config._strict);
            if (era) {
              getParsingFlags(config).era = era;
            } else {
              getParsingFlags(config).invalidEra = input;
            }
          }
        );
        addRegexToken("y", matchUnsigned);
        addRegexToken("yy", matchUnsigned);
        addRegexToken("yyy", matchUnsigned);
        addRegexToken("yyyy", matchUnsigned);
        addRegexToken("yo", matchEraYearOrdinal);
        addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
        addParseToken(["yo"], function(input, array, config, token3) {
          var match;
          if (config._locale._eraYearOrdinalRegex) {
            match = input.match(config._locale._eraYearOrdinalRegex);
          }
          if (config._locale.eraYearOrdinalParse) {
            array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
          } else {
            array[YEAR] = parseInt(input, 10);
          }
        });
        function localeEras(m, format2) {
          var i, l, date, eras = this._eras || getLocale("en")._eras;
          for (i = 0, l = eras.length; i < l; ++i) {
            switch (typeof eras[i].since) {
              case "string":
                date = hooks(eras[i].since).startOf("day");
                eras[i].since = date.valueOf();
                break;
            }
            switch (typeof eras[i].until) {
              case "undefined":
                eras[i].until = Infinity;
                break;
              case "string":
                date = hooks(eras[i].until).startOf("day").valueOf();
                eras[i].until = date.valueOf();
                break;
            }
          }
          return eras;
        }
        function localeErasParse(eraName, format2, strict) {
          var i, l, eras = this.eras(), name, abbr, narrow;
          eraName = eraName.toUpperCase();
          for (i = 0, l = eras.length; i < l; ++i) {
            name = eras[i].name.toUpperCase();
            abbr = eras[i].abbr.toUpperCase();
            narrow = eras[i].narrow.toUpperCase();
            if (strict) {
              switch (format2) {
                case "N":
                case "NN":
                case "NNN":
                  if (abbr === eraName) {
                    return eras[i];
                  }
                  break;
                case "NNNN":
                  if (name === eraName) {
                    return eras[i];
                  }
                  break;
                case "NNNNN":
                  if (narrow === eraName) {
                    return eras[i];
                  }
                  break;
              }
            } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
              return eras[i];
            }
          }
        }
        function localeErasConvertYear(era, year) {
          var dir = era.since <= era.until ? 1 : -1;
          if (year === void 0) {
            return hooks(era.since).year();
          } else {
            return hooks(era.since).year() + (year - era.offset) * dir;
          }
        }
        function getEraName() {
          var i, l, val, eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
            val = this.clone().startOf("day").valueOf();
            if (eras[i].since <= val && val <= eras[i].until) {
              return eras[i].name;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
              return eras[i].name;
            }
          }
          return "";
        }
        function getEraNarrow() {
          var i, l, val, eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
            val = this.clone().startOf("day").valueOf();
            if (eras[i].since <= val && val <= eras[i].until) {
              return eras[i].narrow;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
              return eras[i].narrow;
            }
          }
          return "";
        }
        function getEraAbbr() {
          var i, l, val, eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
            val = this.clone().startOf("day").valueOf();
            if (eras[i].since <= val && val <= eras[i].until) {
              return eras[i].abbr;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
              return eras[i].abbr;
            }
          }
          return "";
        }
        function getEraYear() {
          var i, l, dir, val, eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
            dir = eras[i].since <= eras[i].until ? 1 : -1;
            val = this.clone().startOf("day").valueOf();
            if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {
              return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
            }
          }
          return this.year();
        }
        function erasNameRegex(isStrict) {
          if (!hasOwnProp(this, "_erasNameRegex")) {
            computeErasParse.call(this);
          }
          return isStrict ? this._erasNameRegex : this._erasRegex;
        }
        function erasAbbrRegex(isStrict) {
          if (!hasOwnProp(this, "_erasAbbrRegex")) {
            computeErasParse.call(this);
          }
          return isStrict ? this._erasAbbrRegex : this._erasRegex;
        }
        function erasNarrowRegex(isStrict) {
          if (!hasOwnProp(this, "_erasNarrowRegex")) {
            computeErasParse.call(this);
          }
          return isStrict ? this._erasNarrowRegex : this._erasRegex;
        }
        function matchEraAbbr(isStrict, locale2) {
          return locale2.erasAbbrRegex(isStrict);
        }
        function matchEraName(isStrict, locale2) {
          return locale2.erasNameRegex(isStrict);
        }
        function matchEraNarrow(isStrict, locale2) {
          return locale2.erasNarrowRegex(isStrict);
        }
        function matchEraYearOrdinal(isStrict, locale2) {
          return locale2._eraYearOrdinalRegex || matchUnsigned;
        }
        function computeErasParse() {
          var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i, l, eras = this.eras();
          for (i = 0, l = eras.length; i < l; ++i) {
            namePieces.push(regexEscape(eras[i].name));
            abbrPieces.push(regexEscape(eras[i].abbr));
            narrowPieces.push(regexEscape(eras[i].narrow));
            mixedPieces.push(regexEscape(eras[i].name));
            mixedPieces.push(regexEscape(eras[i].abbr));
            mixedPieces.push(regexEscape(eras[i].narrow));
          }
          this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
          this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
          this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
          this._erasNarrowRegex = new RegExp(
            "^(" + narrowPieces.join("|") + ")",
            "i"
          );
        }
        addFormatToken(0, ["gg", 2], 0, function() {
          return this.weekYear() % 100;
        });
        addFormatToken(0, ["GG", 2], 0, function() {
          return this.isoWeekYear() % 100;
        });
        function addWeekYearFormatToken(token3, getter) {
          addFormatToken(0, [token3, token3.length], 0, getter);
        }
        addWeekYearFormatToken("gggg", "weekYear");
        addWeekYearFormatToken("ggggg", "weekYear");
        addWeekYearFormatToken("GGGG", "isoWeekYear");
        addWeekYearFormatToken("GGGGG", "isoWeekYear");
        addUnitAlias("weekYear", "gg");
        addUnitAlias("isoWeekYear", "GG");
        addUnitPriority("weekYear", 1);
        addUnitPriority("isoWeekYear", 1);
        addRegexToken("G", matchSigned);
        addRegexToken("g", matchSigned);
        addRegexToken("GG", match1to2, match2);
        addRegexToken("gg", match1to2, match2);
        addRegexToken("GGGG", match1to4, match4);
        addRegexToken("gggg", match1to4, match4);
        addRegexToken("GGGGG", match1to6, match6);
        addRegexToken("ggggg", match1to6, match6);
        addWeekParseToken(
          ["gggg", "ggggg", "GGGG", "GGGGG"],
          function(input, week, config, token3) {
            week[token3.substr(0, 2)] = toInt(input);
          }
        );
        addWeekParseToken(["gg", "GG"], function(input, week, config, token3) {
          week[token3] = hooks.parseTwoDigitYear(input);
        });
        function getSetWeekYear(input) {
          return getSetWeekYearHelper.call(
            this,
            input,
            this.week(),
            this.weekday(),
            this.localeData()._week.dow,
            this.localeData()._week.doy
          );
        }
        function getSetISOWeekYear(input) {
          return getSetWeekYearHelper.call(
            this,
            input,
            this.isoWeek(),
            this.isoWeekday(),
            1,
            4
          );
        }
        function getISOWeeksInYear() {
          return weeksInYear(this.year(), 1, 4);
        }
        function getISOWeeksInISOWeekYear() {
          return weeksInYear(this.isoWeekYear(), 1, 4);
        }
        function getWeeksInYear() {
          var weekInfo = this.localeData()._week;
          return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
        }
        function getWeeksInWeekYear() {
          var weekInfo = this.localeData()._week;
          return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
        }
        function getSetWeekYearHelper(input, week, weekday, dow, doy) {
          var weeksTarget;
          if (input == null) {
            return weekOfYear(this, dow, doy).year;
          } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
              week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
          }
        }
        function setWeekAll(weekYear, week, weekday, dow, doy) {
          var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
          this.year(date.getUTCFullYear());
          this.month(date.getUTCMonth());
          this.date(date.getUTCDate());
          return this;
        }
        addFormatToken("Q", 0, "Qo", "quarter");
        addUnitAlias("quarter", "Q");
        addUnitPriority("quarter", 7);
        addRegexToken("Q", match1);
        addParseToken("Q", function(input, array) {
          array[MONTH] = (toInt(input) - 1) * 3;
        });
        function getSetQuarter(input) {
          return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
        }
        addFormatToken("D", ["DD", 2], "Do", "date");
        addUnitAlias("date", "D");
        addUnitPriority("date", 9);
        addRegexToken("D", match1to2);
        addRegexToken("DD", match1to2, match2);
        addRegexToken("Do", function(isStrict, locale2) {
          return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
        });
        addParseToken(["D", "DD"], DATE);
        addParseToken("Do", function(input, array) {
          array[DATE] = toInt(input.match(match1to2)[0]);
        });
        var getSetDayOfMonth = makeGetSet("Date", true);
        addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
        addUnitAlias("dayOfYear", "DDD");
        addUnitPriority("dayOfYear", 4);
        addRegexToken("DDD", match1to3);
        addRegexToken("DDDD", match3);
        addParseToken(["DDD", "DDDD"], function(input, array, config) {
          config._dayOfYear = toInt(input);
        });
        function getSetDayOfYear(input) {
          var dayOfYear = Math.round(
            (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
          ) + 1;
          return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
        }
        addFormatToken("m", ["mm", 2], 0, "minute");
        addUnitAlias("minute", "m");
        addUnitPriority("minute", 14);
        addRegexToken("m", match1to2);
        addRegexToken("mm", match1to2, match2);
        addParseToken(["m", "mm"], MINUTE);
        var getSetMinute = makeGetSet("Minutes", false);
        addFormatToken("s", ["ss", 2], 0, "second");
        addUnitAlias("second", "s");
        addUnitPriority("second", 15);
        addRegexToken("s", match1to2);
        addRegexToken("ss", match1to2, match2);
        addParseToken(["s", "ss"], SECOND);
        var getSetSecond = makeGetSet("Seconds", false);
        addFormatToken("S", 0, 0, function() {
          return ~~(this.millisecond() / 100);
        });
        addFormatToken(0, ["SS", 2], 0, function() {
          return ~~(this.millisecond() / 10);
        });
        addFormatToken(0, ["SSS", 3], 0, "millisecond");
        addFormatToken(0, ["SSSS", 4], 0, function() {
          return this.millisecond() * 10;
        });
        addFormatToken(0, ["SSSSS", 5], 0, function() {
          return this.millisecond() * 100;
        });
        addFormatToken(0, ["SSSSSS", 6], 0, function() {
          return this.millisecond() * 1e3;
        });
        addFormatToken(0, ["SSSSSSS", 7], 0, function() {
          return this.millisecond() * 1e4;
        });
        addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
          return this.millisecond() * 1e5;
        });
        addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
          return this.millisecond() * 1e6;
        });
        addUnitAlias("millisecond", "ms");
        addUnitPriority("millisecond", 16);
        addRegexToken("S", match1to3, match1);
        addRegexToken("SS", match1to3, match2);
        addRegexToken("SSS", match1to3, match3);
        var token2, getSetMillisecond;
        for (token2 = "SSSS"; token2.length <= 9; token2 += "S") {
          addRegexToken(token2, matchUnsigned);
        }
        function parseMs(input, array) {
          array[MILLISECOND] = toInt(("0." + input) * 1e3);
        }
        for (token2 = "S"; token2.length <= 9; token2 += "S") {
          addParseToken(token2, parseMs);
        }
        getSetMillisecond = makeGetSet("Milliseconds", false);
        addFormatToken("z", 0, 0, "zoneAbbr");
        addFormatToken("zz", 0, 0, "zoneName");
        function getZoneAbbr() {
          return this._isUTC ? "UTC" : "";
        }
        function getZoneName() {
          return this._isUTC ? "Coordinated Universal Time" : "";
        }
        var proto = Moment.prototype;
        proto.add = add;
        proto.calendar = calendar$1;
        proto.clone = clone;
        proto.diff = diff;
        proto.endOf = endOf;
        proto.format = format;
        proto.from = from;
        proto.fromNow = fromNow;
        proto.to = to;
        proto.toNow = toNow;
        proto.get = stringGet;
        proto.invalidAt = invalidAt;
        proto.isAfter = isAfter;
        proto.isBefore = isBefore;
        proto.isBetween = isBetween;
        proto.isSame = isSame;
        proto.isSameOrAfter = isSameOrAfter;
        proto.isSameOrBefore = isSameOrBefore;
        proto.isValid = isValid$2;
        proto.lang = lang;
        proto.locale = locale;
        proto.localeData = localeData;
        proto.max = prototypeMax;
        proto.min = prototypeMin;
        proto.parsingFlags = parsingFlags;
        proto.set = stringSet;
        proto.startOf = startOf;
        proto.subtract = subtract;
        proto.toArray = toArray;
        proto.toObject = toObject;
        proto.toDate = toDate;
        proto.toISOString = toISOString;
        proto.inspect = inspect;
        if (typeof Symbol !== "undefined" && Symbol.for != null) {
          proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
            return "Moment<" + this.format() + ">";
          };
        }
        proto.toJSON = toJSON;
        proto.toString = toString;
        proto.unix = unix;
        proto.valueOf = valueOf;
        proto.creationData = creationData;
        proto.eraName = getEraName;
        proto.eraNarrow = getEraNarrow;
        proto.eraAbbr = getEraAbbr;
        proto.eraYear = getEraYear;
        proto.year = getSetYear;
        proto.isLeapYear = getIsLeapYear;
        proto.weekYear = getSetWeekYear;
        proto.isoWeekYear = getSetISOWeekYear;
        proto.quarter = proto.quarters = getSetQuarter;
        proto.month = getSetMonth;
        proto.daysInMonth = getDaysInMonth;
        proto.week = proto.weeks = getSetWeek;
        proto.isoWeek = proto.isoWeeks = getSetISOWeek;
        proto.weeksInYear = getWeeksInYear;
        proto.weeksInWeekYear = getWeeksInWeekYear;
        proto.isoWeeksInYear = getISOWeeksInYear;
        proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
        proto.date = getSetDayOfMonth;
        proto.day = proto.days = getSetDayOfWeek;
        proto.weekday = getSetLocaleDayOfWeek;
        proto.isoWeekday = getSetISODayOfWeek;
        proto.dayOfYear = getSetDayOfYear;
        proto.hour = proto.hours = getSetHour;
        proto.minute = proto.minutes = getSetMinute;
        proto.second = proto.seconds = getSetSecond;
        proto.millisecond = proto.milliseconds = getSetMillisecond;
        proto.utcOffset = getSetOffset;
        proto.utc = setOffsetToUTC;
        proto.local = setOffsetToLocal;
        proto.parseZone = setOffsetToParsedOffset;
        proto.hasAlignedHourOffset = hasAlignedHourOffset;
        proto.isDST = isDaylightSavingTime;
        proto.isLocal = isLocal;
        proto.isUtcOffset = isUtcOffset;
        proto.isUtc = isUtc;
        proto.isUTC = isUtc;
        proto.zoneAbbr = getZoneAbbr;
        proto.zoneName = getZoneName;
        proto.dates = deprecate(
          "dates accessor is deprecated. Use date instead.",
          getSetDayOfMonth
        );
        proto.months = deprecate(
          "months accessor is deprecated. Use month instead",
          getSetMonth
        );
        proto.years = deprecate(
          "years accessor is deprecated. Use year instead",
          getSetYear
        );
        proto.zone = deprecate(
          "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
          getSetZone
        );
        proto.isDSTShifted = deprecate(
          "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
          isDaylightSavingTimeShifted
        );
        function createUnix(input) {
          return createLocal(input * 1e3);
        }
        function createInZone() {
          return createLocal.apply(null, arguments).parseZone();
        }
        function preParsePostFormat(string) {
          return string;
        }
        var proto$1 = Locale.prototype;
        proto$1.calendar = calendar;
        proto$1.longDateFormat = longDateFormat;
        proto$1.invalidDate = invalidDate;
        proto$1.ordinal = ordinal;
        proto$1.preparse = preParsePostFormat;
        proto$1.postformat = preParsePostFormat;
        proto$1.relativeTime = relativeTime;
        proto$1.pastFuture = pastFuture;
        proto$1.set = set;
        proto$1.eras = localeEras;
        proto$1.erasParse = localeErasParse;
        proto$1.erasConvertYear = localeErasConvertYear;
        proto$1.erasAbbrRegex = erasAbbrRegex;
        proto$1.erasNameRegex = erasNameRegex;
        proto$1.erasNarrowRegex = erasNarrowRegex;
        proto$1.months = localeMonths;
        proto$1.monthsShort = localeMonthsShort;
        proto$1.monthsParse = localeMonthsParse;
        proto$1.monthsRegex = monthsRegex;
        proto$1.monthsShortRegex = monthsShortRegex;
        proto$1.week = localeWeek;
        proto$1.firstDayOfYear = localeFirstDayOfYear;
        proto$1.firstDayOfWeek = localeFirstDayOfWeek;
        proto$1.weekdays = localeWeekdays;
        proto$1.weekdaysMin = localeWeekdaysMin;
        proto$1.weekdaysShort = localeWeekdaysShort;
        proto$1.weekdaysParse = localeWeekdaysParse;
        proto$1.weekdaysRegex = weekdaysRegex;
        proto$1.weekdaysShortRegex = weekdaysShortRegex;
        proto$1.weekdaysMinRegex = weekdaysMinRegex;
        proto$1.isPM = localeIsPM;
        proto$1.meridiem = localeMeridiem;
        function get$1(format2, index, field, setter) {
          var locale2 = getLocale(), utc = createUTC().set(setter, index);
          return locale2[field](utc, format2);
        }
        function listMonthsImpl(format2, index, field) {
          if (isNumber(format2)) {
            index = format2;
            format2 = void 0;
          }
          format2 = format2 || "";
          if (index != null) {
            return get$1(format2, index, field, "month");
          }
          var i, out = [];
          for (i = 0; i < 12; i++) {
            out[i] = get$1(format2, i, field, "month");
          }
          return out;
        }
        function listWeekdaysImpl(localeSorted, format2, index, field) {
          if (typeof localeSorted === "boolean") {
            if (isNumber(format2)) {
              index = format2;
              format2 = void 0;
            }
            format2 = format2 || "";
          } else {
            format2 = localeSorted;
            index = format2;
            localeSorted = false;
            if (isNumber(format2)) {
              index = format2;
              format2 = void 0;
            }
            format2 = format2 || "";
          }
          var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i, out = [];
          if (index != null) {
            return get$1(format2, (index + shift) % 7, field, "day");
          }
          for (i = 0; i < 7; i++) {
            out[i] = get$1(format2, (i + shift) % 7, field, "day");
          }
          return out;
        }
        function listMonths(format2, index) {
          return listMonthsImpl(format2, index, "months");
        }
        function listMonthsShort(format2, index) {
          return listMonthsImpl(format2, index, "monthsShort");
        }
        function listWeekdays(localeSorted, format2, index) {
          return listWeekdaysImpl(localeSorted, format2, index, "weekdays");
        }
        function listWeekdaysShort(localeSorted, format2, index) {
          return listWeekdaysImpl(localeSorted, format2, index, "weekdaysShort");
        }
        function listWeekdaysMin(localeSorted, format2, index) {
          return listWeekdaysImpl(localeSorted, format2, index, "weekdaysMin");
        }
        getSetGlobalLocale("en", {
          eras: [
            {
              since: "0001-01-01",
              until: Infinity,
              offset: 1,
              name: "Anno Domini",
              narrow: "AD",
              abbr: "AD"
            },
            {
              since: "0000-12-31",
              until: -Infinity,
              offset: 1,
              name: "Before Christ",
              narrow: "BC",
              abbr: "BC"
            }
          ],
          dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
          ordinal: function(number) {
            var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
            return number + output;
          }
        });
        hooks.lang = deprecate(
          "moment.lang is deprecated. Use moment.locale instead.",
          getSetGlobalLocale
        );
        hooks.langData = deprecate(
          "moment.langData is deprecated. Use moment.localeData instead.",
          getLocale
        );
        var mathAbs = Math.abs;
        function abs() {
          var data = this._data;
          this._milliseconds = mathAbs(this._milliseconds);
          this._days = mathAbs(this._days);
          this._months = mathAbs(this._months);
          data.milliseconds = mathAbs(data.milliseconds);
          data.seconds = mathAbs(data.seconds);
          data.minutes = mathAbs(data.minutes);
          data.hours = mathAbs(data.hours);
          data.months = mathAbs(data.months);
          data.years = mathAbs(data.years);
          return this;
        }
        function addSubtract$1(duration, input, value, direction) {
          var other = createDuration(input, value);
          duration._milliseconds += direction * other._milliseconds;
          duration._days += direction * other._days;
          duration._months += direction * other._months;
          return duration._bubble();
        }
        function add$1(input, value) {
          return addSubtract$1(this, input, value, 1);
        }
        function subtract$1(input, value) {
          return addSubtract$1(this, input, value, -1);
        }
        function absCeil(number) {
          if (number < 0) {
            return Math.floor(number);
          } else {
            return Math.ceil(number);
          }
        }
        function bubble() {
          var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
          if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
            milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
            days2 = 0;
            months2 = 0;
          }
          data.milliseconds = milliseconds2 % 1e3;
          seconds2 = absFloor(milliseconds2 / 1e3);
          data.seconds = seconds2 % 60;
          minutes2 = absFloor(seconds2 / 60);
          data.minutes = minutes2 % 60;
          hours2 = absFloor(minutes2 / 60);
          data.hours = hours2 % 24;
          days2 += absFloor(hours2 / 24);
          monthsFromDays = absFloor(daysToMonths(days2));
          months2 += monthsFromDays;
          days2 -= absCeil(monthsToDays(monthsFromDays));
          years2 = absFloor(months2 / 12);
          months2 %= 12;
          data.days = days2;
          data.months = months2;
          data.years = years2;
          return this;
        }
        function daysToMonths(days2) {
          return days2 * 4800 / 146097;
        }
        function monthsToDays(months2) {
          return months2 * 146097 / 4800;
        }
        function as(units) {
          if (!this.isValid()) {
            return NaN;
          }
          var days2, months2, milliseconds2 = this._milliseconds;
          units = normalizeUnits(units);
          if (units === "month" || units === "quarter" || units === "year") {
            days2 = this._days + milliseconds2 / 864e5;
            months2 = this._months + daysToMonths(days2);
            switch (units) {
              case "month":
                return months2;
              case "quarter":
                return months2 / 3;
              case "year":
                return months2 / 12;
            }
          } else {
            days2 = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
              case "week":
                return days2 / 7 + milliseconds2 / 6048e5;
              case "day":
                return days2 + milliseconds2 / 864e5;
              case "hour":
                return days2 * 24 + milliseconds2 / 36e5;
              case "minute":
                return days2 * 1440 + milliseconds2 / 6e4;
              case "second":
                return days2 * 86400 + milliseconds2 / 1e3;
              case "millisecond":
                return Math.floor(days2 * 864e5) + milliseconds2;
              default:
                throw new Error("Unknown unit " + units);
            }
          }
        }
        function valueOf$1() {
          if (!this.isValid()) {
            return NaN;
          }
          return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
        }
        function makeAs(alias) {
          return function() {
            return this.as(alias);
          };
        }
        var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y");
        function clone$1() {
          return createDuration(this);
        }
        function get$2(units) {
          units = normalizeUnits(units);
          return this.isValid() ? this[units + "s"]() : NaN;
        }
        function makeGetter(name) {
          return function() {
            return this.isValid() ? this._data[name] : NaN;
          };
        }
        var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
        function weeks() {
          return absFloor(this.days() / 7);
        }
        var round = Math.round, thresholds = {
          ss: 44,
          // a few seconds to seconds
          s: 45,
          // seconds to minute
          m: 45,
          // minutes to hour
          h: 22,
          // hours to day
          d: 26,
          // days to month/week
          w: null,
          // weeks to month
          M: 11
          // months to year
        };
        function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale2) {
          return locale2.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
        }
        function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
          var duration = createDuration(posNegDuration).abs(), seconds2 = round(duration.as("s")), minutes2 = round(duration.as("m")), hours2 = round(duration.as("h")), days2 = round(duration.as("d")), months2 = round(duration.as("M")), weeks2 = round(duration.as("w")), years2 = round(duration.as("y")), a = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
          if (thresholds2.w != null) {
            a = a || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
          }
          a = a || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
          a[2] = withoutSuffix;
          a[3] = +posNegDuration > 0;
          a[4] = locale2;
          return substituteTimeAgo.apply(null, a);
        }
        function getSetRelativeTimeRounding(roundingFunction) {
          if (roundingFunction === void 0) {
            return round;
          }
          if (typeof roundingFunction === "function") {
            round = roundingFunction;
            return true;
          }
          return false;
        }
        function getSetRelativeTimeThreshold(threshold, limit) {
          if (thresholds[threshold] === void 0) {
            return false;
          }
          if (limit === void 0) {
            return thresholds[threshold];
          }
          thresholds[threshold] = limit;
          if (threshold === "s") {
            thresholds.ss = limit - 1;
          }
          return true;
        }
        function humanize(argWithSuffix, argThresholds) {
          if (!this.isValid()) {
            return this.localeData().invalidDate();
          }
          var withSuffix = false, th = thresholds, locale2, output;
          if (typeof argWithSuffix === "object") {
            argThresholds = argWithSuffix;
            argWithSuffix = false;
          }
          if (typeof argWithSuffix === "boolean") {
            withSuffix = argWithSuffix;
          }
          if (typeof argThresholds === "object") {
            th = Object.assign({}, thresholds, argThresholds);
            if (argThresholds.s != null && argThresholds.ss == null) {
              th.ss = argThresholds.s - 1;
            }
          }
          locale2 = this.localeData();
          output = relativeTime$1(this, !withSuffix, th, locale2);
          if (withSuffix) {
            output = locale2.pastFuture(+this, output);
          }
          return locale2.postformat(output);
        }
        var abs$1 = Math.abs;
        function sign(x) {
          return (x > 0) - (x < 0) || +x;
        }
        function toISOString$1() {
          if (!this.isValid()) {
            return this.localeData().invalidDate();
          }
          var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
          if (!total) {
            return "P0D";
          }
          minutes2 = absFloor(seconds2 / 60);
          hours2 = absFloor(minutes2 / 60);
          seconds2 %= 60;
          minutes2 %= 60;
          years2 = absFloor(months2 / 12);
          months2 %= 12;
          s = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
          totalSign = total < 0 ? "-" : "";
          ymSign = sign(this._months) !== sign(total) ? "-" : "";
          daysSign = sign(this._days) !== sign(total) ? "-" : "";
          hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
          return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s + "S" : "");
        }
        var proto$2 = Duration.prototype;
        proto$2.isValid = isValid$1;
        proto$2.abs = abs;
        proto$2.add = add$1;
        proto$2.subtract = subtract$1;
        proto$2.as = as;
        proto$2.asMilliseconds = asMilliseconds;
        proto$2.asSeconds = asSeconds;
        proto$2.asMinutes = asMinutes;
        proto$2.asHours = asHours;
        proto$2.asDays = asDays;
        proto$2.asWeeks = asWeeks;
        proto$2.asMonths = asMonths;
        proto$2.asQuarters = asQuarters;
        proto$2.asYears = asYears;
        proto$2.valueOf = valueOf$1;
        proto$2._bubble = bubble;
        proto$2.clone = clone$1;
        proto$2.get = get$2;
        proto$2.milliseconds = milliseconds;
        proto$2.seconds = seconds;
        proto$2.minutes = minutes;
        proto$2.hours = hours;
        proto$2.days = days;
        proto$2.weeks = weeks;
        proto$2.months = months;
        proto$2.years = years;
        proto$2.humanize = humanize;
        proto$2.toISOString = toISOString$1;
        proto$2.toString = toISOString$1;
        proto$2.toJSON = toISOString$1;
        proto$2.locale = locale;
        proto$2.localeData = localeData;
        proto$2.toIsoString = deprecate(
          "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
          toISOString$1
        );
        proto$2.lang = lang;
        addFormatToken("X", 0, 0, "unix");
        addFormatToken("x", 0, 0, "valueOf");
        addRegexToken("x", matchSigned);
        addRegexToken("X", matchTimestamp);
        addParseToken("X", function(input, array, config) {
          config._d = new Date(parseFloat(input) * 1e3);
        });
        addParseToken("x", function(input, array, config) {
          config._d = new Date(toInt(input));
        });
        hooks.version = "2.29.4";
        setHookCallback(createLocal);
        hooks.fn = proto;
        hooks.min = min;
        hooks.max = max;
        hooks.now = now;
        hooks.utc = createUTC;
        hooks.unix = createUnix;
        hooks.months = listMonths;
        hooks.isDate = isDate;
        hooks.locale = getSetGlobalLocale;
        hooks.invalid = createInvalid;
        hooks.duration = createDuration;
        hooks.isMoment = isMoment;
        hooks.weekdays = listWeekdays;
        hooks.parseZone = createInZone;
        hooks.localeData = getLocale;
        hooks.isDuration = isDuration;
        hooks.monthsShort = listMonthsShort;
        hooks.weekdaysMin = listWeekdaysMin;
        hooks.defineLocale = defineLocale;
        hooks.updateLocale = updateLocale;
        hooks.locales = listLocales;
        hooks.weekdaysShort = listWeekdaysShort;
        hooks.normalizeUnits = normalizeUnits;
        hooks.relativeTimeRounding = getSetRelativeTimeRounding;
        hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
        hooks.calendarFormat = getCalendarFormat;
        hooks.prototype = proto;
        hooks.HTML5_FMT = {
          DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
          // <input type="datetime-local" />
          DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
          // <input type="datetime-local" step="1" />
          DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
          // <input type="datetime-local" step="0.001" />
          DATE: "YYYY-MM-DD",
          // <input type="date" />
          TIME: "HH:mm",
          // <input type="time" />
          TIME_SECONDS: "HH:mm:ss",
          // <input type="time" step="1" />
          TIME_MS: "HH:mm:ss.SSS",
          // <input type="time" step="0.001" />
          WEEK: "GGGG-[W]WW",
          // <input type="week" />
          MONTH: "YYYY-MM"
          // <input type="month" />
        };
        return hooks;
      });
    }
  });

  // node_modules/@kurkle/color/dist/color.cjs
  var require_color = __commonJS({
    "node_modules/@kurkle/color/dist/color.cjs"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2["@kurkle/color"] = factory());
      })(exports, function() {
        "use strict";
        function round(v) {
          return v + 0.5 | 0;
        }
        const lim = (v, l, h) => Math.max(Math.min(v, h), l);
        function p2b(v) {
          return lim(round(v * 2.55), 0, 255);
        }
        function b2p(v) {
          return lim(round(v / 2.55), 0, 100);
        }
        function n2b(v) {
          return lim(round(v * 255), 0, 255);
        }
        function b2n(v) {
          return lim(round(v / 2.55) / 100, 0, 1);
        }
        function n2p(v) {
          return lim(round(v * 100), 0, 100);
        }
        const map$1 = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 };
        const hex = [..."0123456789ABCDEF"];
        const h1 = (b) => hex[b & 15];
        const h2 = (b) => hex[(b & 240) >> 4] + hex[b & 15];
        const eq = (b) => (b & 240) >> 4 === (b & 15);
        const isShort = (v) => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);
        function hexParse(str) {
          var len = str.length;
          var ret;
          if (str[0] === "#") {
            if (len === 4 || len === 5) {
              ret = {
                r: 255 & map$1[str[1]] * 17,
                g: 255 & map$1[str[2]] * 17,
                b: 255 & map$1[str[3]] * 17,
                a: len === 5 ? map$1[str[4]] * 17 : 255
              };
            } else if (len === 7 || len === 9) {
              ret = {
                r: map$1[str[1]] << 4 | map$1[str[2]],
                g: map$1[str[3]] << 4 | map$1[str[4]],
                b: map$1[str[5]] << 4 | map$1[str[6]],
                a: len === 9 ? map$1[str[7]] << 4 | map$1[str[8]] : 255
              };
            }
          }
          return ret;
        }
        const alpha = (a, f) => a < 255 ? f(a) : "";
        function hexString(v) {
          var f = isShort(v) ? h1 : h2;
          return v ? "#" + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f) : void 0;
        }
        const HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
        function hsl2rgbn(h, s, l) {
          const a = s * Math.min(l, 1 - l);
          const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
          return [f(0), f(8), f(4)];
        }
        function hsv2rgbn(h, s, v) {
          const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
          return [f(5), f(3), f(1)];
        }
        function hwb2rgbn(h, w, b) {
          const rgb = hsl2rgbn(h, 1, 0.5);
          let i;
          if (w + b > 1) {
            i = 1 / (w + b);
            w *= i;
            b *= i;
          }
          for (i = 0; i < 3; i++) {
            rgb[i] *= 1 - w - b;
            rgb[i] += w;
          }
          return rgb;
        }
        function hueValue(r, g, b, d, max) {
          if (r === max) {
            return (g - b) / d + (g < b ? 6 : 0);
          }
          if (g === max) {
            return (b - r) / d + 2;
          }
          return (r - g) / d + 4;
        }
        function rgb2hsl(v) {
          const range = 255;
          const r = v.r / range;
          const g = v.g / range;
          const b = v.b / range;
          const max = Math.max(r, g, b);
          const min = Math.min(r, g, b);
          const l = (max + min) / 2;
          let h, s, d;
          if (max !== min) {
            d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            h = hueValue(r, g, b, d, max);
            h = h * 60 + 0.5;
          }
          return [h | 0, s || 0, l];
        }
        function calln(f, a, b, c) {
          return (Array.isArray(a) ? f(a[0], a[1], a[2]) : f(a, b, c)).map(n2b);
        }
        function hsl2rgb(h, s, l) {
          return calln(hsl2rgbn, h, s, l);
        }
        function hwb2rgb(h, w, b) {
          return calln(hwb2rgbn, h, w, b);
        }
        function hsv2rgb(h, s, v) {
          return calln(hsv2rgbn, h, s, v);
        }
        function hue(h) {
          return (h % 360 + 360) % 360;
        }
        function hueParse(str) {
          const m = HUE_RE.exec(str);
          let a = 255;
          let v;
          if (!m) {
            return;
          }
          if (m[5] !== v) {
            a = m[6] ? p2b(+m[5]) : n2b(+m[5]);
          }
          const h = hue(+m[2]);
          const p1 = +m[3] / 100;
          const p2 = +m[4] / 100;
          if (m[1] === "hwb") {
            v = hwb2rgb(h, p1, p2);
          } else if (m[1] === "hsv") {
            v = hsv2rgb(h, p1, p2);
          } else {
            v = hsl2rgb(h, p1, p2);
          }
          return {
            r: v[0],
            g: v[1],
            b: v[2],
            a
          };
        }
        function rotate(v, deg) {
          var h = rgb2hsl(v);
          h[0] = hue(h[0] + deg);
          h = hsl2rgb(h);
          v.r = h[0];
          v.g = h[1];
          v.b = h[2];
        }
        function hslString(v) {
          if (!v) {
            return;
          }
          const a = rgb2hsl(v);
          const h = a[0];
          const s = n2p(a[1]);
          const l = n2p(a[2]);
          return v.a < 255 ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})` : `hsl(${h}, ${s}%, ${l}%)`;
        }
        const map = {
          x: "dark",
          Z: "light",
          Y: "re",
          X: "blu",
          W: "gr",
          V: "medium",
          U: "slate",
          A: "ee",
          T: "ol",
          S: "or",
          B: "ra",
          C: "lateg",
          D: "ights",
          R: "in",
          Q: "turquois",
          E: "hi",
          P: "ro",
          O: "al",
          N: "le",
          M: "de",
          L: "yello",
          F: "en",
          K: "ch",
          G: "arks",
          H: "ea",
          I: "ightg",
          J: "wh"
        };
        const names$1 = {
          OiceXe: "f0f8ff",
          antiquewEte: "faebd7",
          aqua: "ffff",
          aquamarRe: "7fffd4",
          azuY: "f0ffff",
          beige: "f5f5dc",
          bisque: "ffe4c4",
          black: "0",
          blanKedOmond: "ffebcd",
          Xe: "ff",
          XeviTet: "8a2be2",
          bPwn: "a52a2a",
          burlywood: "deb887",
          caMtXe: "5f9ea0",
          KartYuse: "7fff00",
          KocTate: "d2691e",
          cSO: "ff7f50",
          cSnflowerXe: "6495ed",
          cSnsilk: "fff8dc",
          crimson: "dc143c",
          cyan: "ffff",
          xXe: "8b",
          xcyan: "8b8b",
          xgTMnPd: "b8860b",
          xWay: "a9a9a9",
          xgYF: "6400",
          xgYy: "a9a9a9",
          xkhaki: "bdb76b",
          xmagFta: "8b008b",
          xTivegYF: "556b2f",
          xSange: "ff8c00",
          xScEd: "9932cc",
          xYd: "8b0000",
          xsOmon: "e9967a",
          xsHgYF: "8fbc8f",
          xUXe: "483d8b",
          xUWay: "2f4f4f",
          xUgYy: "2f4f4f",
          xQe: "ced1",
          xviTet: "9400d3",
          dAppRk: "ff1493",
          dApskyXe: "bfff",
          dimWay: "696969",
          dimgYy: "696969",
          dodgerXe: "1e90ff",
          fiYbrick: "b22222",
          flSOwEte: "fffaf0",
          foYstWAn: "228b22",
          fuKsia: "ff00ff",
          gaRsbSo: "dcdcdc",
          ghostwEte: "f8f8ff",
          gTd: "ffd700",
          gTMnPd: "daa520",
          Way: "808080",
          gYF: "8000",
          gYFLw: "adff2f",
          gYy: "808080",
          honeyMw: "f0fff0",
          hotpRk: "ff69b4",
          RdianYd: "cd5c5c",
          Rdigo: "4b0082",
          ivSy: "fffff0",
          khaki: "f0e68c",
          lavFMr: "e6e6fa",
          lavFMrXsh: "fff0f5",
          lawngYF: "7cfc00",
          NmoncEffon: "fffacd",
          ZXe: "add8e6",
          ZcSO: "f08080",
          Zcyan: "e0ffff",
          ZgTMnPdLw: "fafad2",
          ZWay: "d3d3d3",
          ZgYF: "90ee90",
          ZgYy: "d3d3d3",
          ZpRk: "ffb6c1",
          ZsOmon: "ffa07a",
          ZsHgYF: "20b2aa",
          ZskyXe: "87cefa",
          ZUWay: "778899",
          ZUgYy: "778899",
          ZstAlXe: "b0c4de",
          ZLw: "ffffe0",
          lime: "ff00",
          limegYF: "32cd32",
          lRF: "faf0e6",
          magFta: "ff00ff",
          maPon: "800000",
          VaquamarRe: "66cdaa",
          VXe: "cd",
          VScEd: "ba55d3",
          VpurpN: "9370db",
          VsHgYF: "3cb371",
          VUXe: "7b68ee",
          VsprRggYF: "fa9a",
          VQe: "48d1cc",
          VviTetYd: "c71585",
          midnightXe: "191970",
          mRtcYam: "f5fffa",
          mistyPse: "ffe4e1",
          moccasR: "ffe4b5",
          navajowEte: "ffdead",
          navy: "80",
          Tdlace: "fdf5e6",
          Tive: "808000",
          TivedBb: "6b8e23",
          Sange: "ffa500",
          SangeYd: "ff4500",
          ScEd: "da70d6",
          pOegTMnPd: "eee8aa",
          pOegYF: "98fb98",
          pOeQe: "afeeee",
          pOeviTetYd: "db7093",
          papayawEp: "ffefd5",
          pHKpuff: "ffdab9",
          peru: "cd853f",
          pRk: "ffc0cb",
          plum: "dda0dd",
          powMrXe: "b0e0e6",
          purpN: "800080",
          YbeccapurpN: "663399",
          Yd: "ff0000",
          Psybrown: "bc8f8f",
          PyOXe: "4169e1",
          saddNbPwn: "8b4513",
          sOmon: "fa8072",
          sandybPwn: "f4a460",
          sHgYF: "2e8b57",
          sHshell: "fff5ee",
          siFna: "a0522d",
          silver: "c0c0c0",
          skyXe: "87ceeb",
          UXe: "6a5acd",
          UWay: "708090",
          UgYy: "708090",
          snow: "fffafa",
          sprRggYF: "ff7f",
          stAlXe: "4682b4",
          tan: "d2b48c",
          teO: "8080",
          tEstN: "d8bfd8",
          tomato: "ff6347",
          Qe: "40e0d0",
          viTet: "ee82ee",
          JHt: "f5deb3",
          wEte: "ffffff",
          wEtesmoke: "f5f5f5",
          Lw: "ffff00",
          LwgYF: "9acd32"
        };
        function unpack() {
          const unpacked = {};
          const keys = Object.keys(names$1);
          const tkeys = Object.keys(map);
          let i, j, k, ok, nk;
          for (i = 0; i < keys.length; i++) {
            ok = nk = keys[i];
            for (j = 0; j < tkeys.length; j++) {
              k = tkeys[j];
              nk = nk.replace(k, map[k]);
            }
            k = parseInt(names$1[ok], 16);
            unpacked[nk] = [k >> 16 & 255, k >> 8 & 255, k & 255];
          }
          return unpacked;
        }
        let names;
        function nameParse(str) {
          if (!names) {
            names = unpack();
            names.transparent = [0, 0, 0, 0];
          }
          const a = names[str.toLowerCase()];
          return a && {
            r: a[0],
            g: a[1],
            b: a[2],
            a: a.length === 4 ? a[3] : 255
          };
        }
        const RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
        function rgbParse(str) {
          const m = RGB_RE.exec(str);
          let a = 255;
          let r, g, b;
          if (!m) {
            return;
          }
          if (m[7] !== r) {
            const v = +m[7];
            a = m[8] ? p2b(v) : lim(v * 255, 0, 255);
          }
          r = +m[1];
          g = +m[3];
          b = +m[5];
          r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));
          g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));
          b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));
          return {
            r,
            g,
            b,
            a
          };
        }
        function rgbString(v) {
          return v && (v.a < 255 ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})` : `rgb(${v.r}, ${v.g}, ${v.b})`);
        }
        const to = (v) => v <= 31308e-7 ? v * 12.92 : Math.pow(v, 1 / 2.4) * 1.055 - 0.055;
        const from = (v) => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
        function interpolate(rgb1, rgb2, t) {
          const r = from(b2n(rgb1.r));
          const g = from(b2n(rgb1.g));
          const b = from(b2n(rgb1.b));
          return {
            r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),
            g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),
            b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),
            a: rgb1.a + t * (rgb2.a - rgb1.a)
          };
        }
        function modHSL(v, i, ratio) {
          if (v) {
            let tmp = rgb2hsl(v);
            tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));
            tmp = hsl2rgb(tmp);
            v.r = tmp[0];
            v.g = tmp[1];
            v.b = tmp[2];
          }
        }
        function clone(v, proto) {
          return v ? Object.assign(proto || {}, v) : v;
        }
        function fromObject(input) {
          var v = { r: 0, g: 0, b: 0, a: 255 };
          if (Array.isArray(input)) {
            if (input.length >= 3) {
              v = { r: input[0], g: input[1], b: input[2], a: 255 };
              if (input.length > 3) {
                v.a = n2b(input[3]);
              }
            }
          } else {
            v = clone(input, { r: 0, g: 0, b: 0, a: 1 });
            v.a = n2b(v.a);
          }
          return v;
        }
        function functionParse(str) {
          if (str.charAt(0) === "r") {
            return rgbParse(str);
          }
          return hueParse(str);
        }
        class Color {
          constructor(input) {
            if (input instanceof Color) {
              return input;
            }
            const type = typeof input;
            let v;
            if (type === "object") {
              v = fromObject(input);
            } else if (type === "string") {
              v = hexParse(input) || nameParse(input) || functionParse(input);
            }
            this._rgb = v;
            this._valid = !!v;
          }
          get valid() {
            return this._valid;
          }
          get rgb() {
            var v = clone(this._rgb);
            if (v) {
              v.a = b2n(v.a);
            }
            return v;
          }
          set rgb(obj) {
            this._rgb = fromObject(obj);
          }
          rgbString() {
            return this._valid ? rgbString(this._rgb) : void 0;
          }
          hexString() {
            return this._valid ? hexString(this._rgb) : void 0;
          }
          hslString() {
            return this._valid ? hslString(this._rgb) : void 0;
          }
          mix(color2, weight) {
            if (color2) {
              const c1 = this.rgb;
              const c2 = color2.rgb;
              let w2;
              const p = weight === w2 ? 0.5 : weight;
              const w = 2 * p - 1;
              const a = c1.a - c2.a;
              const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
              w2 = 1 - w1;
              c1.r = 255 & w1 * c1.r + w2 * c2.r + 0.5;
              c1.g = 255 & w1 * c1.g + w2 * c2.g + 0.5;
              c1.b = 255 & w1 * c1.b + w2 * c2.b + 0.5;
              c1.a = p * c1.a + (1 - p) * c2.a;
              this.rgb = c1;
            }
            return this;
          }
          interpolate(color2, t) {
            if (color2) {
              this._rgb = interpolate(this._rgb, color2._rgb, t);
            }
            return this;
          }
          clone() {
            return new Color(this.rgb);
          }
          alpha(a) {
            this._rgb.a = n2b(a);
            return this;
          }
          clearer(ratio) {
            const rgb = this._rgb;
            rgb.a *= 1 - ratio;
            return this;
          }
          greyscale() {
            const rgb = this._rgb;
            const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
            rgb.r = rgb.g = rgb.b = val;
            return this;
          }
          opaquer(ratio) {
            const rgb = this._rgb;
            rgb.a *= 1 + ratio;
            return this;
          }
          negate() {
            const v = this._rgb;
            v.r = 255 - v.r;
            v.g = 255 - v.g;
            v.b = 255 - v.b;
            return this;
          }
          lighten(ratio) {
            modHSL(this._rgb, 2, ratio);
            return this;
          }
          darken(ratio) {
            modHSL(this._rgb, 2, -ratio);
            return this;
          }
          saturate(ratio) {
            modHSL(this._rgb, 1, ratio);
            return this;
          }
          desaturate(ratio) {
            modHSL(this._rgb, 1, -ratio);
            return this;
          }
          rotate(deg) {
            rotate(this._rgb, deg);
            return this;
          }
        }
        function index_esm(input) {
          return new Color(input);
        }
        var color = /* @__PURE__ */ Object.freeze({
          __proto__: null,
          Color,
          default: index_esm,
          round,
          lim,
          p2b,
          b2p,
          n2b,
          b2n,
          n2p,
          hexParse,
          hexString,
          rgb2hsl,
          hsl2rgb,
          hwb2rgb,
          hsv2rgb,
          hueParse,
          rotate,
          hslString,
          nameParse,
          rgbParse,
          rgbString
        });
        var index = Object.assign(index_esm, color);
        return index;
      });
    }
  });

  // node_modules/chart.js/dist/chunks/helpers.segment.cjs
  var require_helpers_segment = __commonJS({
    "node_modules/chart.js/dist/chunks/helpers.segment.cjs"(exports) {
      "use strict";
      var color$1 = require_color();
      function noop() {
      }
      var uid = (() => {
        let id = 0;
        return () => id++;
      })();
      function isNullOrUndef(value) {
        return value === null || typeof value === "undefined";
      }
      function isArray(value) {
        if (Array.isArray && Array.isArray(value)) {
          return true;
        }
        const type = Object.prototype.toString.call(value);
        if (type.slice(0, 7) === "[object" && type.slice(-6) === "Array]") {
          return true;
        }
        return false;
      }
      function isObject(value) {
        return value !== null && Object.prototype.toString.call(value) === "[object Object]";
      }
      function isNumberFinite(value) {
        return (typeof value === "number" || value instanceof Number) && isFinite(+value);
      }
      function finiteOrDefault(value, defaultValue) {
        return isNumberFinite(value) ? value : defaultValue;
      }
      function valueOrDefault(value, defaultValue) {
        return typeof value === "undefined" ? defaultValue : value;
      }
      var toPercentage = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 : +value / dimension;
      var toDimension = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 * dimension : +value;
      function callback(fn, args, thisArg) {
        if (fn && typeof fn.call === "function") {
          return fn.apply(thisArg, args);
        }
      }
      function each(loopable, fn, thisArg, reverse) {
        let i, len, keys;
        if (isArray(loopable)) {
          len = loopable.length;
          if (reverse) {
            for (i = len - 1; i >= 0; i--) {
              fn.call(thisArg, loopable[i], i);
            }
          } else {
            for (i = 0; i < len; i++) {
              fn.call(thisArg, loopable[i], i);
            }
          }
        } else if (isObject(loopable)) {
          keys = Object.keys(loopable);
          len = keys.length;
          for (i = 0; i < len; i++) {
            fn.call(thisArg, loopable[keys[i]], keys[i]);
          }
        }
      }
      function _elementsEqual(a0, a1) {
        let i, ilen, v0, v1;
        if (!a0 || !a1 || a0.length !== a1.length) {
          return false;
        }
        for (i = 0, ilen = a0.length; i < ilen; ++i) {
          v0 = a0[i];
          v1 = a1[i];
          if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
            return false;
          }
        }
        return true;
      }
      function clone(source) {
        if (isArray(source)) {
          return source.map(clone);
        }
        if (isObject(source)) {
          const target = /* @__PURE__ */ Object.create(null);
          const keys = Object.keys(source);
          const klen = keys.length;
          let k = 0;
          for (; k < klen; ++k) {
            target[keys[k]] = clone(source[keys[k]]);
          }
          return target;
        }
        return source;
      }
      function isValidKey(key) {
        return [
          "__proto__",
          "prototype",
          "constructor"
        ].indexOf(key) === -1;
      }
      function _merger(key, target, source, options) {
        if (!isValidKey(key)) {
          return;
        }
        const tval = target[key];
        const sval = source[key];
        if (isObject(tval) && isObject(sval)) {
          merge(tval, sval, options);
        } else {
          target[key] = clone(sval);
        }
      }
      function merge(target, source, options) {
        const sources = isArray(source) ? source : [
          source
        ];
        const ilen = sources.length;
        if (!isObject(target)) {
          return target;
        }
        options = options || {};
        const merger = options.merger || _merger;
        let current;
        for (let i = 0; i < ilen; ++i) {
          current = sources[i];
          if (!isObject(current)) {
            continue;
          }
          const keys = Object.keys(current);
          for (let k = 0, klen = keys.length; k < klen; ++k) {
            merger(keys[k], target, current, options);
          }
        }
        return target;
      }
      function mergeIf(target, source) {
        return merge(target, source, {
          merger: _mergerIf
        });
      }
      function _mergerIf(key, target, source) {
        if (!isValidKey(key)) {
          return;
        }
        const tval = target[key];
        const sval = source[key];
        if (isObject(tval) && isObject(sval)) {
          mergeIf(tval, sval);
        } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
          target[key] = clone(sval);
        }
      }
      function _deprecated(scope, value, previous, current) {
        if (value !== void 0) {
          console.warn(scope + ': "' + previous + '" is deprecated. Please use "' + current + '" instead');
        }
      }
      var keyResolvers = {
        // Chart.helpers.core resolveObjectKey should resolve empty key to root object
        "": (v) => v,
        // default resolvers
        x: (o) => o.x,
        y: (o) => o.y
      };
      function _splitKey(key) {
        const parts = key.split(".");
        const keys = [];
        let tmp = "";
        for (const part of parts) {
          tmp += part;
          if (tmp.endsWith("\\")) {
            tmp = tmp.slice(0, -1) + ".";
          } else {
            keys.push(tmp);
            tmp = "";
          }
        }
        return keys;
      }
      function _getKeyResolver(key) {
        const keys = _splitKey(key);
        return (obj) => {
          for (const k of keys) {
            if (k === "") {
              break;
            }
            obj = obj && obj[k];
          }
          return obj;
        };
      }
      function resolveObjectKey(obj, key) {
        const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));
        return resolver(obj);
      }
      function _capitalize(str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
      }
      var defined = (value) => typeof value !== "undefined";
      var isFunction = (value) => typeof value === "function";
      var setsEqual = (a, b) => {
        if (a.size !== b.size) {
          return false;
        }
        for (const item of a) {
          if (!b.has(item)) {
            return false;
          }
        }
        return true;
      };
      function _isClickEvent(e) {
        return e.type === "mouseup" || e.type === "click" || e.type === "contextmenu";
      }
      var PI = Math.PI;
      var TAU = 2 * PI;
      var PITAU = TAU + PI;
      var INFINITY = Number.POSITIVE_INFINITY;
      var RAD_PER_DEG = PI / 180;
      var HALF_PI = PI / 2;
      var QUARTER_PI = PI / 4;
      var TWO_THIRDS_PI = PI * 2 / 3;
      var log10 = Math.log10;
      var sign = Math.sign;
      function almostEquals(x, y, epsilon) {
        return Math.abs(x - y) < epsilon;
      }
      function niceNum(range) {
        const roundedRange = Math.round(range);
        range = almostEquals(range, roundedRange, range / 1e3) ? roundedRange : range;
        const niceRange = Math.pow(10, Math.floor(log10(range)));
        const fraction = range / niceRange;
        const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
        return niceFraction * niceRange;
      }
      function _factorize(value) {
        const result = [];
        const sqrt = Math.sqrt(value);
        let i;
        for (i = 1; i < sqrt; i++) {
          if (value % i === 0) {
            result.push(i);
            result.push(value / i);
          }
        }
        if (sqrt === (sqrt | 0)) {
          result.push(sqrt);
        }
        result.sort((a, b) => a - b).pop();
        return result;
      }
      function isNumber(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
      }
      function almostWhole(x, epsilon) {
        const rounded = Math.round(x);
        return rounded - epsilon <= x && rounded + epsilon >= x;
      }
      function _setMinAndMaxByKey(array, target, property) {
        let i, ilen, value;
        for (i = 0, ilen = array.length; i < ilen; i++) {
          value = array[i][property];
          if (!isNaN(value)) {
            target.min = Math.min(target.min, value);
            target.max = Math.max(target.max, value);
          }
        }
      }
      function toRadians(degrees) {
        return degrees * (PI / 180);
      }
      function toDegrees(radians) {
        return radians * (180 / PI);
      }
      function _decimalPlaces(x) {
        if (!isNumberFinite(x)) {
          return;
        }
        let e = 1;
        let p = 0;
        while (Math.round(x * e) / e !== x) {
          e *= 10;
          p++;
        }
        return p;
      }
      function getAngleFromPoint(centrePoint, anglePoint) {
        const distanceFromXCenter = anglePoint.x - centrePoint.x;
        const distanceFromYCenter = anglePoint.y - centrePoint.y;
        const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
        let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
        if (angle < -0.5 * PI) {
          angle += TAU;
        }
        return {
          angle,
          distance: radialDistanceFromCenter
        };
      }
      function distanceBetweenPoints(pt1, pt2) {
        return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
      }
      function _angleDiff(a, b) {
        return (a - b + PITAU) % TAU - PI;
      }
      function _normalizeAngle(a) {
        return (a % TAU + TAU) % TAU;
      }
      function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
        const a = _normalizeAngle(angle);
        const s = _normalizeAngle(start);
        const e = _normalizeAngle(end);
        const angleToStart = _normalizeAngle(s - a);
        const angleToEnd = _normalizeAngle(e - a);
        const startToAngle = _normalizeAngle(a - s);
        const endToAngle = _normalizeAngle(a - e);
        return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;
      }
      function _limitValue(value, min, max) {
        return Math.max(min, Math.min(max, value));
      }
      function _int16Range(value) {
        return _limitValue(value, -32768, 32767);
      }
      function _isBetween(value, start, end, epsilon = 1e-6) {
        return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;
      }
      function _lookup(table, value, cmp) {
        cmp = cmp || ((index) => table[index] < value);
        let hi = table.length - 1;
        let lo = 0;
        let mid;
        while (hi - lo > 1) {
          mid = lo + hi >> 1;
          if (cmp(mid)) {
            lo = mid;
          } else {
            hi = mid;
          }
        }
        return {
          lo,
          hi
        };
      }
      var _lookupByKey = (table, key, value, last) => _lookup(table, value, last ? (index) => {
        const ti = table[index][key];
        return ti < value || ti === value && table[index + 1][key] === value;
      } : (index) => table[index][key] < value);
      var _rlookupByKey = (table, key, value) => _lookup(table, value, (index) => table[index][key] >= value);
      function _filterBetween(values, min, max) {
        let start = 0;
        let end = values.length;
        while (start < end && values[start] < min) {
          start++;
        }
        while (end > start && values[end - 1] > max) {
          end--;
        }
        return start > 0 || end < values.length ? values.slice(start, end) : values;
      }
      var arrayEvents = [
        "push",
        "pop",
        "shift",
        "splice",
        "unshift"
      ];
      function listenArrayEvents(array, listener) {
        if (array._chartjs) {
          array._chartjs.listeners.push(listener);
          return;
        }
        Object.defineProperty(array, "_chartjs", {
          configurable: true,
          enumerable: false,
          value: {
            listeners: [
              listener
            ]
          }
        });
        arrayEvents.forEach((key) => {
          const method = "_onData" + _capitalize(key);
          const base = array[key];
          Object.defineProperty(array, key, {
            configurable: true,
            enumerable: false,
            value(...args) {
              const res = base.apply(this, args);
              array._chartjs.listeners.forEach((object) => {
                if (typeof object[method] === "function") {
                  object[method](...args);
                }
              });
              return res;
            }
          });
        });
      }
      function unlistenArrayEvents(array, listener) {
        const stub = array._chartjs;
        if (!stub) {
          return;
        }
        const listeners = stub.listeners;
        const index = listeners.indexOf(listener);
        if (index !== -1) {
          listeners.splice(index, 1);
        }
        if (listeners.length > 0) {
          return;
        }
        arrayEvents.forEach((key) => {
          delete array[key];
        });
        delete array._chartjs;
      }
      function _arrayUnique(items) {
        const set2 = new Set(items);
        if (set2.size === items.length) {
          return items;
        }
        return Array.from(set2);
      }
      function fontString(pixelSize, fontStyle, fontFamily) {
        return fontStyle + " " + pixelSize + "px " + fontFamily;
      }
      var requestAnimFrame = function() {
        if (typeof window === "undefined") {
          return function(callback2) {
            return callback2();
          };
        }
        return window.requestAnimationFrame;
      }();
      function throttled(fn, thisArg) {
        let argsToUse = [];
        let ticking = false;
        return function(...args) {
          argsToUse = args;
          if (!ticking) {
            ticking = true;
            requestAnimFrame.call(window, () => {
              ticking = false;
              fn.apply(thisArg, argsToUse);
            });
          }
        };
      }
      function debounce(fn, delay) {
        let timeout;
        return function(...args) {
          if (delay) {
            clearTimeout(timeout);
            timeout = setTimeout(fn, delay, args);
          } else {
            fn.apply(this, args);
          }
          return delay;
        };
      }
      var _toLeftRightCenter = (align) => align === "start" ? "left" : align === "end" ? "right" : "center";
      var _alignStartEnd = (align, start, end) => align === "start" ? start : align === "end" ? end : (start + end) / 2;
      var _textX = (align, left, right, rtl) => {
        const check = rtl ? "left" : "right";
        return align === check ? right : align === "center" ? (left + right) / 2 : left;
      };
      function _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
        const pointCount = points.length;
        let start = 0;
        let count = pointCount;
        if (meta._sorted) {
          const { iScale, _parsed } = meta;
          const axis = iScale.axis;
          const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
          if (minDefined) {
            start = _limitValue(Math.min(
              // @ts-expect-error Need to type _parsed
              _lookupByKey(_parsed, iScale.axis, min).lo,
              // @ts-expect-error Need to fix types on _lookupByKey
              animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo
            ), 0, pointCount - 1);
          }
          if (maxDefined) {
            count = _limitValue(Math.max(
              // @ts-expect-error Need to type _parsed
              _lookupByKey(_parsed, iScale.axis, max, true).hi + 1,
              // @ts-expect-error Need to fix types on _lookupByKey
              animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1
            ), start, pointCount) - start;
          } else {
            count = pointCount - start;
          }
        }
        return {
          start,
          count
        };
      }
      function _scaleRangesChanged(meta) {
        const { xScale, yScale, _scaleRanges } = meta;
        const newRanges = {
          xmin: xScale.min,
          xmax: xScale.max,
          ymin: yScale.min,
          ymax: yScale.max
        };
        if (!_scaleRanges) {
          meta._scaleRanges = newRanges;
          return true;
        }
        const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
        Object.assign(_scaleRanges, newRanges);
        return changed;
      }
      var atEdge = (t) => t === 0 || t === 1;
      var elasticIn = (t, s, p) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));
      var elasticOut = (t, s, p) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;
      var effects = {
        linear: (t) => t,
        easeInQuad: (t) => t * t,
        easeOutQuad: (t) => -t * (t - 2),
        easeInOutQuad: (t) => (t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),
        easeInCubic: (t) => t * t * t,
        easeOutCubic: (t) => (t -= 1) * t * t + 1,
        easeInOutCubic: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),
        easeInQuart: (t) => t * t * t * t,
        easeOutQuart: (t) => -((t -= 1) * t * t * t - 1),
        easeInOutQuart: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),
        easeInQuint: (t) => t * t * t * t * t,
        easeOutQuint: (t) => (t -= 1) * t * t * t * t + 1,
        easeInOutQuint: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),
        easeInSine: (t) => -Math.cos(t * HALF_PI) + 1,
        easeOutSine: (t) => Math.sin(t * HALF_PI),
        easeInOutSine: (t) => -0.5 * (Math.cos(PI * t) - 1),
        easeInExpo: (t) => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
        easeOutExpo: (t) => t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,
        easeInOutExpo: (t) => atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),
        easeInCirc: (t) => t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),
        easeOutCirc: (t) => Math.sqrt(1 - (t -= 1) * t),
        easeInOutCirc: (t) => (t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
        easeInElastic: (t) => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),
        easeOutElastic: (t) => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),
        easeInOutElastic(t) {
          const s = 0.1125;
          const p = 0.45;
          return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);
        },
        easeInBack(t) {
          const s = 1.70158;
          return t * t * ((s + 1) * t - s);
        },
        easeOutBack(t) {
          const s = 1.70158;
          return (t -= 1) * t * ((s + 1) * t + s) + 1;
        },
        easeInOutBack(t) {
          let s = 1.70158;
          if ((t /= 0.5) < 1) {
            return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
          }
          return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
        },
        easeInBounce: (t) => 1 - effects.easeOutBounce(1 - t),
        easeOutBounce(t) {
          const m = 7.5625;
          const d = 2.75;
          if (t < 1 / d) {
            return m * t * t;
          }
          if (t < 2 / d) {
            return m * (t -= 1.5 / d) * t + 0.75;
          }
          if (t < 2.5 / d) {
            return m * (t -= 2.25 / d) * t + 0.9375;
          }
          return m * (t -= 2.625 / d) * t + 0.984375;
        },
        easeInOutBounce: (t) => t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5
      };
      function isPatternOrGradient(value) {
        if (value && typeof value === "object") {
          const type = value.toString();
          return type === "[object CanvasPattern]" || type === "[object CanvasGradient]";
        }
        return false;
      }
      function color(value) {
        return isPatternOrGradient(value) ? value : new color$1.Color(value);
      }
      function getHoverColor(value) {
        return isPatternOrGradient(value) ? value : new color$1.Color(value).saturate(0.5).darken(0.1).hexString();
      }
      var numbers = [
        "x",
        "y",
        "borderWidth",
        "radius",
        "tension"
      ];
      var colors = [
        "color",
        "borderColor",
        "backgroundColor"
      ];
      function applyAnimationsDefaults(defaults2) {
        defaults2.set("animation", {
          delay: void 0,
          duration: 1e3,
          easing: "easeOutQuart",
          fn: void 0,
          from: void 0,
          loop: void 0,
          to: void 0,
          type: void 0
        });
        defaults2.describe("animation", {
          _fallback: false,
          _indexable: false,
          _scriptable: (name) => name !== "onProgress" && name !== "onComplete" && name !== "fn"
        });
        defaults2.set("animations", {
          colors: {
            type: "color",
            properties: colors
          },
          numbers: {
            type: "number",
            properties: numbers
          }
        });
        defaults2.describe("animations", {
          _fallback: "animation"
        });
        defaults2.set("transitions", {
          active: {
            animation: {
              duration: 400
            }
          },
          resize: {
            animation: {
              duration: 0
            }
          },
          show: {
            animations: {
              colors: {
                from: "transparent"
              },
              visible: {
                type: "boolean",
                duration: 0
              }
            }
          },
          hide: {
            animations: {
              colors: {
                to: "transparent"
              },
              visible: {
                type: "boolean",
                easing: "linear",
                fn: (v) => v | 0
              }
            }
          }
        });
      }
      function applyLayoutsDefaults(defaults2) {
        defaults2.set("layout", {
          autoPadding: true,
          padding: {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
          }
        });
      }
      var intlCache = /* @__PURE__ */ new Map();
      function getNumberFormat(locale, options) {
        options = options || {};
        const cacheKey = locale + JSON.stringify(options);
        let formatter = intlCache.get(cacheKey);
        if (!formatter) {
          formatter = new Intl.NumberFormat(locale, options);
          intlCache.set(cacheKey, formatter);
        }
        return formatter;
      }
      function formatNumber(num, locale, options) {
        return getNumberFormat(locale, options).format(num);
      }
      var formatters = {
        values(value) {
          return isArray(value) ? value : "" + value;
        },
        numeric(tickValue, index, ticks) {
          if (tickValue === 0) {
            return "0";
          }
          const locale = this.chart.options.locale;
          let notation;
          let delta = tickValue;
          if (ticks.length > 1) {
            const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
            if (maxTick < 1e-4 || maxTick > 1e15) {
              notation = "scientific";
            }
            delta = calculateDelta(tickValue, ticks);
          }
          const logDelta = log10(Math.abs(delta));
          const numDecimal = isNaN(logDelta) ? 1 : Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
          const options = {
            notation,
            minimumFractionDigits: numDecimal,
            maximumFractionDigits: numDecimal
          };
          Object.assign(options, this.options.ticks.format);
          return formatNumber(tickValue, locale, options);
        },
        logarithmic(tickValue, index, ticks) {
          if (tickValue === 0) {
            return "0";
          }
          const remain = ticks[index].significand || tickValue / Math.pow(10, Math.floor(log10(tickValue)));
          if ([
            1,
            2,
            3,
            5,
            10,
            15
          ].includes(remain) || index > 0.8 * ticks.length) {
            return formatters.numeric.call(this, tickValue, index, ticks);
          }
          return "";
        }
      };
      function calculateDelta(tickValue, ticks) {
        let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
        if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
          delta = tickValue - Math.floor(tickValue);
        }
        return delta;
      }
      var Ticks = {
        formatters
      };
      function applyScaleDefaults(defaults2) {
        defaults2.set("scale", {
          display: true,
          offset: false,
          reverse: false,
          beginAtZero: false,
          bounds: "ticks",
          grace: 0,
          grid: {
            display: true,
            lineWidth: 1,
            drawOnChartArea: true,
            drawTicks: true,
            tickLength: 8,
            tickWidth: (_ctx, options) => options.lineWidth,
            tickColor: (_ctx, options) => options.color,
            offset: false
          },
          border: {
            display: true,
            dash: [],
            dashOffset: 0,
            width: 1
          },
          title: {
            display: false,
            text: "",
            padding: {
              top: 4,
              bottom: 4
            }
          },
          ticks: {
            minRotation: 0,
            maxRotation: 50,
            mirror: false,
            textStrokeWidth: 0,
            textStrokeColor: "",
            padding: 3,
            display: true,
            autoSkip: true,
            autoSkipPadding: 3,
            labelOffset: 0,
            callback: Ticks.formatters.values,
            minor: {},
            major: {},
            align: "center",
            crossAlign: "near",
            showLabelBackdrop: false,
            backdropColor: "rgba(255, 255, 255, 0.75)",
            backdropPadding: 2
          }
        });
        defaults2.route("scale.ticks", "color", "", "color");
        defaults2.route("scale.grid", "color", "", "borderColor");
        defaults2.route("scale.border", "color", "", "borderColor");
        defaults2.route("scale.title", "color", "", "color");
        defaults2.describe("scale", {
          _fallback: false,
          _scriptable: (name) => !name.startsWith("before") && !name.startsWith("after") && name !== "callback" && name !== "parser",
          _indexable: (name) => name !== "borderDash" && name !== "tickBorderDash" && name !== "dash"
        });
        defaults2.describe("scales", {
          _fallback: "scale"
        });
        defaults2.describe("scale.ticks", {
          _scriptable: (name) => name !== "backdropPadding" && name !== "callback",
          _indexable: (name) => name !== "backdropPadding"
        });
      }
      var overrides = /* @__PURE__ */ Object.create(null);
      var descriptors = /* @__PURE__ */ Object.create(null);
      function getScope$1(node, key) {
        if (!key) {
          return node;
        }
        const keys = key.split(".");
        for (let i = 0, n = keys.length; i < n; ++i) {
          const k = keys[i];
          node = node[k] || (node[k] = /* @__PURE__ */ Object.create(null));
        }
        return node;
      }
      function set(root, scope, values) {
        if (typeof scope === "string") {
          return merge(getScope$1(root, scope), values);
        }
        return merge(getScope$1(root, ""), scope);
      }
      var Defaults = class {
        constructor(_descriptors2, _appliers) {
          this.animation = void 0;
          this.backgroundColor = "rgba(0,0,0,0.1)";
          this.borderColor = "rgba(0,0,0,0.1)";
          this.color = "#666";
          this.datasets = {};
          this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();
          this.elements = {};
          this.events = [
            "mousemove",
            "mouseout",
            "click",
            "touchstart",
            "touchmove"
          ];
          this.font = {
            family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
            size: 12,
            style: "normal",
            lineHeight: 1.2,
            weight: null
          };
          this.hover = {};
          this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);
          this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);
          this.hoverColor = (ctx, options) => getHoverColor(options.color);
          this.indexAxis = "x";
          this.interaction = {
            mode: "nearest",
            intersect: true,
            includeInvisible: false
          };
          this.maintainAspectRatio = true;
          this.onHover = null;
          this.onClick = null;
          this.parsing = true;
          this.plugins = {};
          this.responsive = true;
          this.scale = void 0;
          this.scales = {};
          this.showLine = true;
          this.drawActiveElementsOnTop = true;
          this.describe(_descriptors2);
          this.apply(_appliers);
        }
        set(scope, values) {
          return set(this, scope, values);
        }
        get(scope) {
          return getScope$1(this, scope);
        }
        describe(scope, values) {
          return set(descriptors, scope, values);
        }
        override(scope, values) {
          return set(overrides, scope, values);
        }
        route(scope, name, targetScope, targetName) {
          const scopeObject = getScope$1(this, scope);
          const targetScopeObject = getScope$1(this, targetScope);
          const privateName = "_" + name;
          Object.defineProperties(scopeObject, {
            [privateName]: {
              value: scopeObject[name],
              writable: true
            },
            [name]: {
              enumerable: true,
              get() {
                const local = this[privateName];
                const target = targetScopeObject[targetName];
                if (isObject(local)) {
                  return Object.assign({}, target, local);
                }
                return valueOrDefault(local, target);
              },
              set(value) {
                this[privateName] = value;
              }
            }
          });
        }
        apply(appliers) {
          appliers.forEach((apply) => apply(this));
        }
      };
      var defaults = /* @__PURE__ */ new Defaults({
        _scriptable: (name) => !name.startsWith("on"),
        _indexable: (name) => name !== "events",
        hover: {
          _fallback: "interaction"
        },
        interaction: {
          _scriptable: false,
          _indexable: false
        }
      }, [
        applyAnimationsDefaults,
        applyLayoutsDefaults,
        applyScaleDefaults
      ]);
      function toFontString(font) {
        if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
          return null;
        }
        return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
      }
      function _measureText(ctx, data, gc, longest, string) {
        let textWidth = data[string];
        if (!textWidth) {
          textWidth = data[string] = ctx.measureText(string).width;
          gc.push(string);
        }
        if (textWidth > longest) {
          longest = textWidth;
        }
        return longest;
      }
      function _longestText(ctx, font, arrayOfThings, cache) {
        cache = cache || {};
        let data = cache.data = cache.data || {};
        let gc = cache.garbageCollect = cache.garbageCollect || [];
        if (cache.font !== font) {
          data = cache.data = {};
          gc = cache.garbageCollect = [];
          cache.font = font;
        }
        ctx.save();
        ctx.font = font;
        let longest = 0;
        const ilen = arrayOfThings.length;
        let i, j, jlen, thing, nestedThing;
        for (i = 0; i < ilen; i++) {
          thing = arrayOfThings[i];
          if (thing !== void 0 && thing !== null && !isArray(thing)) {
            longest = _measureText(ctx, data, gc, longest, thing);
          } else if (isArray(thing)) {
            for (j = 0, jlen = thing.length; j < jlen; j++) {
              nestedThing = thing[j];
              if (nestedThing !== void 0 && nestedThing !== null && !isArray(nestedThing)) {
                longest = _measureText(ctx, data, gc, longest, nestedThing);
              }
            }
          }
        }
        ctx.restore();
        const gcLen = gc.length / 2;
        if (gcLen > arrayOfThings.length) {
          for (i = 0; i < gcLen; i++) {
            delete data[gc[i]];
          }
          gc.splice(0, gcLen);
        }
        return longest;
      }
      function _alignPixel(chart, pixel, width) {
        const devicePixelRatio = chart.currentDevicePixelRatio;
        const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
        return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
      }
      function clearCanvas(canvas, ctx) {
        ctx = ctx || canvas.getContext("2d");
        ctx.save();
        ctx.resetTransform();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.restore();
      }
      function drawPoint(ctx, options, x, y) {
        drawPointLegend(ctx, options, x, y, null);
      }
      function drawPointLegend(ctx, options, x, y, w) {
        let type, xOffset, yOffset, size, cornerRadius, width, xOffsetW, yOffsetW;
        const style = options.pointStyle;
        const rotation = options.rotation;
        const radius = options.radius;
        let rad = (rotation || 0) * RAD_PER_DEG;
        if (style && typeof style === "object") {
          type = style.toString();
          if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rad);
            ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
            ctx.restore();
            return;
          }
        }
        if (isNaN(radius) || radius <= 0) {
          return;
        }
        ctx.beginPath();
        switch (style) {
          default:
            if (w) {
              ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);
            } else {
              ctx.arc(x, y, radius, 0, TAU);
            }
            ctx.closePath();
            break;
          case "triangle":
            width = w ? w / 2 : radius;
            ctx.moveTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
            rad += TWO_THIRDS_PI;
            ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
            rad += TWO_THIRDS_PI;
            ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
            ctx.closePath();
            break;
          case "rectRounded":
            cornerRadius = radius * 0.516;
            size = radius - cornerRadius;
            xOffset = Math.cos(rad + QUARTER_PI) * size;
            xOffsetW = Math.cos(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
            yOffset = Math.sin(rad + QUARTER_PI) * size;
            yOffsetW = Math.sin(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
            ctx.arc(x - xOffsetW, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
            ctx.arc(x + yOffsetW, y - xOffset, cornerRadius, rad - HALF_PI, rad);
            ctx.arc(x + xOffsetW, y + yOffset, cornerRadius, rad, rad + HALF_PI);
            ctx.arc(x - yOffsetW, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
            ctx.closePath();
            break;
          case "rect":
            if (!rotation) {
              size = Math.SQRT1_2 * radius;
              width = w ? w / 2 : size;
              ctx.rect(x - width, y - size, 2 * width, 2 * size);
              break;
            }
            rad += QUARTER_PI;
          case "rectRot":
            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
            ctx.moveTo(x - xOffsetW, y - yOffset);
            ctx.lineTo(x + yOffsetW, y - xOffset);
            ctx.lineTo(x + xOffsetW, y + yOffset);
            ctx.lineTo(x - yOffsetW, y + xOffset);
            ctx.closePath();
            break;
          case "crossRot":
            rad += QUARTER_PI;
          case "cross":
            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
            ctx.moveTo(x - xOffsetW, y - yOffset);
            ctx.lineTo(x + xOffsetW, y + yOffset);
            ctx.moveTo(x + yOffsetW, y - xOffset);
            ctx.lineTo(x - yOffsetW, y + xOffset);
            break;
          case "star":
            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
            ctx.moveTo(x - xOffsetW, y - yOffset);
            ctx.lineTo(x + xOffsetW, y + yOffset);
            ctx.moveTo(x + yOffsetW, y - xOffset);
            ctx.lineTo(x - yOffsetW, y + xOffset);
            rad += QUARTER_PI;
            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
            ctx.moveTo(x - xOffsetW, y - yOffset);
            ctx.lineTo(x + xOffsetW, y + yOffset);
            ctx.moveTo(x + yOffsetW, y - xOffset);
            ctx.lineTo(x - yOffsetW, y + xOffset);
            break;
          case "line":
            xOffset = w ? w / 2 : Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            break;
          case "dash":
            ctx.moveTo(x, y);
            ctx.lineTo(x + Math.cos(rad) * (w ? w / 2 : radius), y + Math.sin(rad) * radius);
            break;
          case false:
            ctx.closePath();
            break;
        }
        ctx.fill();
        if (options.borderWidth > 0) {
          ctx.stroke();
        }
      }
      function _isPointInArea(point, area, margin) {
        margin = margin || 0.5;
        return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
      }
      function clipArea(ctx, area) {
        ctx.save();
        ctx.beginPath();
        ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
        ctx.clip();
      }
      function unclipArea(ctx) {
        ctx.restore();
      }
      function _steppedLineTo(ctx, previous, target, flip, mode) {
        if (!previous) {
          return ctx.lineTo(target.x, target.y);
        }
        if (mode === "middle") {
          const midpoint = (previous.x + target.x) / 2;
          ctx.lineTo(midpoint, previous.y);
          ctx.lineTo(midpoint, target.y);
        } else if (mode === "after" !== !!flip) {
          ctx.lineTo(previous.x, target.y);
        } else {
          ctx.lineTo(target.x, previous.y);
        }
        ctx.lineTo(target.x, target.y);
      }
      function _bezierCurveTo(ctx, previous, target, flip) {
        if (!previous) {
          return ctx.lineTo(target.x, target.y);
        }
        ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);
      }
      function setRenderOpts(ctx, opts) {
        if (opts.translation) {
          ctx.translate(opts.translation[0], opts.translation[1]);
        }
        if (!isNullOrUndef(opts.rotation)) {
          ctx.rotate(opts.rotation);
        }
        if (opts.color) {
          ctx.fillStyle = opts.color;
        }
        if (opts.textAlign) {
          ctx.textAlign = opts.textAlign;
        }
        if (opts.textBaseline) {
          ctx.textBaseline = opts.textBaseline;
        }
      }
      function decorateText(ctx, x, y, line, opts) {
        if (opts.strikethrough || opts.underline) {
          const metrics = ctx.measureText(line);
          const left = x - metrics.actualBoundingBoxLeft;
          const right = x + metrics.actualBoundingBoxRight;
          const top = y - metrics.actualBoundingBoxAscent;
          const bottom = y + metrics.actualBoundingBoxDescent;
          const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;
          ctx.strokeStyle = ctx.fillStyle;
          ctx.beginPath();
          ctx.lineWidth = opts.decorationWidth || 2;
          ctx.moveTo(left, yDecoration);
          ctx.lineTo(right, yDecoration);
          ctx.stroke();
        }
      }
      function drawBackdrop(ctx, opts) {
        const oldColor = ctx.fillStyle;
        ctx.fillStyle = opts.color;
        ctx.fillRect(opts.left, opts.top, opts.width, opts.height);
        ctx.fillStyle = oldColor;
      }
      function renderText(ctx, text, x, y, font, opts = {}) {
        const lines = isArray(text) ? text : [
          text
        ];
        const stroke = opts.strokeWidth > 0 && opts.strokeColor !== "";
        let i, line;
        ctx.save();
        ctx.font = font.string;
        setRenderOpts(ctx, opts);
        for (i = 0; i < lines.length; ++i) {
          line = lines[i];
          if (opts.backdrop) {
            drawBackdrop(ctx, opts.backdrop);
          }
          if (stroke) {
            if (opts.strokeColor) {
              ctx.strokeStyle = opts.strokeColor;
            }
            if (!isNullOrUndef(opts.strokeWidth)) {
              ctx.lineWidth = opts.strokeWidth;
            }
            ctx.strokeText(line, x, y, opts.maxWidth);
          }
          ctx.fillText(line, x, y, opts.maxWidth);
          decorateText(ctx, x, y, line, opts);
          y += Number(font.lineHeight);
        }
        ctx.restore();
      }
      function addRoundedRectPath(ctx, rect) {
        const { x, y, w, h, radius } = rect;
        ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, -HALF_PI, PI, true);
        ctx.lineTo(x, y + h - radius.bottomLeft);
        ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
        ctx.lineTo(x + w - radius.bottomRight, y + h);
        ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
        ctx.lineTo(x + w, y + radius.topRight);
        ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);
        ctx.lineTo(x + radius.topLeft, y);
      }
      var LINE_HEIGHT = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/;
      var FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
      function toLineHeight(value, size) {
        const matches = ("" + value).match(LINE_HEIGHT);
        if (!matches || matches[1] === "normal") {
          return size * 1.2;
        }
        value = +matches[2];
        switch (matches[3]) {
          case "px":
            return value;
          case "%":
            value /= 100;
            break;
        }
        return size * value;
      }
      var numberOrZero = (v) => +v || 0;
      function _readValueToProps(value, props) {
        const ret = {};
        const objProps = isObject(props);
        const keys = objProps ? Object.keys(props) : props;
        const read = isObject(value) ? objProps ? (prop) => valueOrDefault(value[prop], value[props[prop]]) : (prop) => value[prop] : () => value;
        for (const prop of keys) {
          ret[prop] = numberOrZero(read(prop));
        }
        return ret;
      }
      function toTRBL(value) {
        return _readValueToProps(value, {
          top: "y",
          right: "x",
          bottom: "y",
          left: "x"
        });
      }
      function toTRBLCorners(value) {
        return _readValueToProps(value, [
          "topLeft",
          "topRight",
          "bottomLeft",
          "bottomRight"
        ]);
      }
      function toPadding(value) {
        const obj = toTRBL(value);
        obj.width = obj.left + obj.right;
        obj.height = obj.top + obj.bottom;
        return obj;
      }
      function toFont(options, fallback) {
        options = options || {};
        fallback = fallback || defaults.font;
        let size = valueOrDefault(options.size, fallback.size);
        if (typeof size === "string") {
          size = parseInt(size, 10);
        }
        let style = valueOrDefault(options.style, fallback.style);
        if (style && !("" + style).match(FONT_STYLE)) {
          console.warn('Invalid font style specified: "' + style + '"');
          style = void 0;
        }
        const font = {
          family: valueOrDefault(options.family, fallback.family),
          lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
          size,
          style,
          weight: valueOrDefault(options.weight, fallback.weight),
          string: ""
        };
        font.string = toFontString(font);
        return font;
      }
      function resolve(inputs, context, index, info) {
        let cacheable = true;
        let i, ilen, value;
        for (i = 0, ilen = inputs.length; i < ilen; ++i) {
          value = inputs[i];
          if (value === void 0) {
            continue;
          }
          if (context !== void 0 && typeof value === "function") {
            value = value(context);
            cacheable = false;
          }
          if (index !== void 0 && isArray(value)) {
            value = value[index % value.length];
            cacheable = false;
          }
          if (value !== void 0) {
            if (info && !cacheable) {
              info.cacheable = false;
            }
            return value;
          }
        }
      }
      function _addGrace(minmax, grace, beginAtZero) {
        const { min, max } = minmax;
        const change = toDimension(grace, (max - min) / 2);
        const keepZero = (value, add) => beginAtZero && value === 0 ? 0 : value + add;
        return {
          min: keepZero(min, -Math.abs(change)),
          max: keepZero(max, change)
        };
      }
      function createContext(parentContext, context) {
        return Object.assign(Object.create(parentContext), context);
      }
      function _createResolver(scopes, prefixes = [
        ""
      ], rootScopes, fallback, getTarget = () => scopes[0]) {
        const finalRootScopes = rootScopes || scopes;
        if (typeof fallback === "undefined") {
          fallback = _resolve("_fallback", scopes);
        }
        const cache = {
          [Symbol.toStringTag]: "Object",
          _cacheable: true,
          _scopes: scopes,
          _rootScopes: finalRootScopes,
          _fallback: fallback,
          _getTarget: getTarget,
          override: (scope) => _createResolver([
            scope,
            ...scopes
          ], prefixes, finalRootScopes, fallback)
        };
        return new Proxy(cache, {
          /**
          * A trap for the delete operator.
          */
          deleteProperty(target, prop) {
            delete target[prop];
            delete target._keys;
            delete scopes[0][prop];
            return true;
          },
          /**
          * A trap for getting property values.
          */
          get(target, prop) {
            return _cached(target, prop, () => _resolveWithPrefixes(prop, prefixes, scopes, target));
          },
          /**
          * A trap for Object.getOwnPropertyDescriptor.
          * Also used by Object.hasOwnProperty.
          */
          getOwnPropertyDescriptor(target, prop) {
            return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
          },
          /**
          * A trap for Object.getPrototypeOf.
          */
          getPrototypeOf() {
            return Reflect.getPrototypeOf(scopes[0]);
          },
          /**
          * A trap for the in operator.
          */
          has(target, prop) {
            return getKeysFromAllScopes(target).includes(prop);
          },
          /**
          * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
          */
          ownKeys(target) {
            return getKeysFromAllScopes(target);
          },
          /**
          * A trap for setting property values.
          */
          set(target, prop, value) {
            const storage = target._storage || (target._storage = getTarget());
            target[prop] = storage[prop] = value;
            delete target._keys;
            return true;
          }
        });
      }
      function _attachContext(proxy, context, subProxy, descriptorDefaults) {
        const cache = {
          _cacheable: false,
          _proxy: proxy,
          _context: context,
          _subProxy: subProxy,
          _stack: /* @__PURE__ */ new Set(),
          _descriptors: _descriptors(proxy, descriptorDefaults),
          setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),
          override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
        };
        return new Proxy(cache, {
          /**
          * A trap for the delete operator.
          */
          deleteProperty(target, prop) {
            delete target[prop];
            delete proxy[prop];
            return true;
          },
          /**
          * A trap for getting property values.
          */
          get(target, prop, receiver) {
            return _cached(target, prop, () => _resolveWithContext(target, prop, receiver));
          },
          /**
          * A trap for Object.getOwnPropertyDescriptor.
          * Also used by Object.hasOwnProperty.
          */
          getOwnPropertyDescriptor(target, prop) {
            return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {
              enumerable: true,
              configurable: true
            } : void 0 : Reflect.getOwnPropertyDescriptor(proxy, prop);
          },
          /**
          * A trap for Object.getPrototypeOf.
          */
          getPrototypeOf() {
            return Reflect.getPrototypeOf(proxy);
          },
          /**
          * A trap for the in operator.
          */
          has(target, prop) {
            return Reflect.has(proxy, prop);
          },
          /**
          * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
          */
          ownKeys() {
            return Reflect.ownKeys(proxy);
          },
          /**
          * A trap for setting property values.
          */
          set(target, prop, value) {
            proxy[prop] = value;
            delete target[prop];
            return true;
          }
        });
      }
      function _descriptors(proxy, defaults2 = {
        scriptable: true,
        indexable: true
      }) {
        const { _scriptable = defaults2.scriptable, _indexable = defaults2.indexable, _allKeys = defaults2.allKeys } = proxy;
        return {
          allKeys: _allKeys,
          scriptable: _scriptable,
          indexable: _indexable,
          isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,
          isIndexable: isFunction(_indexable) ? _indexable : () => _indexable
        };
      }
      var readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name;
      var needsSubResolver = (prop, value) => isObject(value) && prop !== "adapters" && (Object.getPrototypeOf(value) === null || value.constructor === Object);
      function _cached(target, prop, resolve2) {
        if (Object.prototype.hasOwnProperty.call(target, prop)) {
          return target[prop];
        }
        const value = resolve2();
        target[prop] = value;
        return value;
      }
      function _resolveWithContext(target, prop, receiver) {
        const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
        let value = _proxy[prop];
        if (isFunction(value) && descriptors2.isScriptable(prop)) {
          value = _resolveScriptable(prop, value, target, receiver);
        }
        if (isArray(value) && value.length) {
          value = _resolveArray(prop, value, target, descriptors2.isIndexable);
        }
        if (needsSubResolver(prop, value)) {
          value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors2);
        }
        return value;
      }
      function _resolveScriptable(prop, getValue, target, receiver) {
        const { _proxy, _context, _subProxy, _stack } = target;
        if (_stack.has(prop)) {
          throw new Error("Recursion detected: " + Array.from(_stack).join("->") + "->" + prop);
        }
        _stack.add(prop);
        let value = getValue(_context, _subProxy || receiver);
        _stack.delete(prop);
        if (needsSubResolver(prop, value)) {
          value = createSubResolver(_proxy._scopes, _proxy, prop, value);
        }
        return value;
      }
      function _resolveArray(prop, value, target, isIndexable) {
        const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
        if (typeof _context.index !== "undefined" && isIndexable(prop)) {
          return value[_context.index % value.length];
        } else if (isObject(value[0])) {
          const arr = value;
          const scopes = _proxy._scopes.filter((s) => s !== arr);
          value = [];
          for (const item of arr) {
            const resolver = createSubResolver(scopes, _proxy, prop, item);
            value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors2));
          }
        }
        return value;
      }
      function resolveFallback(fallback, prop, value) {
        return isFunction(fallback) ? fallback(prop, value) : fallback;
      }
      var getScope = (key, parent) => key === true ? parent : typeof key === "string" ? resolveObjectKey(parent, key) : void 0;
      function addScopes(set2, parentScopes, key, parentFallback, value) {
        for (const parent of parentScopes) {
          const scope = getScope(key, parent);
          if (scope) {
            set2.add(scope);
            const fallback = resolveFallback(scope._fallback, key, value);
            if (typeof fallback !== "undefined" && fallback !== key && fallback !== parentFallback) {
              return fallback;
            }
          } else if (scope === false && typeof parentFallback !== "undefined" && key !== parentFallback) {
            return null;
          }
        }
        return false;
      }
      function createSubResolver(parentScopes, resolver, prop, value) {
        const rootScopes = resolver._rootScopes;
        const fallback = resolveFallback(resolver._fallback, prop, value);
        const allScopes = [
          ...parentScopes,
          ...rootScopes
        ];
        const set2 = /* @__PURE__ */ new Set();
        set2.add(value);
        let key = addScopesFromKey(set2, allScopes, prop, fallback || prop, value);
        if (key === null) {
          return false;
        }
        if (typeof fallback !== "undefined" && fallback !== prop) {
          key = addScopesFromKey(set2, allScopes, fallback, key, value);
          if (key === null) {
            return false;
          }
        }
        return _createResolver(Array.from(set2), [
          ""
        ], rootScopes, fallback, () => subGetTarget(resolver, prop, value));
      }
      function addScopesFromKey(set2, allScopes, key, fallback, item) {
        while (key) {
          key = addScopes(set2, allScopes, key, fallback, item);
        }
        return key;
      }
      function subGetTarget(resolver, prop, value) {
        const parent = resolver._getTarget();
        if (!(prop in parent)) {
          parent[prop] = {};
        }
        const target = parent[prop];
        if (isArray(target) && isObject(value)) {
          return value;
        }
        return target || {};
      }
      function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
        let value;
        for (const prefix of prefixes) {
          value = _resolve(readKey(prefix, prop), scopes);
          if (typeof value !== "undefined") {
            return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
          }
        }
      }
      function _resolve(key, scopes) {
        for (const scope of scopes) {
          if (!scope) {
            continue;
          }
          const value = scope[key];
          if (typeof value !== "undefined") {
            return value;
          }
        }
      }
      function getKeysFromAllScopes(target) {
        let keys = target._keys;
        if (!keys) {
          keys = target._keys = resolveKeysFromAllScopes(target._scopes);
        }
        return keys;
      }
      function resolveKeysFromAllScopes(scopes) {
        const set2 = /* @__PURE__ */ new Set();
        for (const scope of scopes) {
          for (const key of Object.keys(scope).filter((k) => !k.startsWith("_"))) {
            set2.add(key);
          }
        }
        return Array.from(set2);
      }
      function _parseObjectDataRadialScale(meta, data, start, count) {
        const { iScale } = meta;
        const { key = "r" } = this._parsing;
        const parsed = new Array(count);
        let i, ilen, index, item;
        for (i = 0, ilen = count; i < ilen; ++i) {
          index = i + start;
          item = data[index];
          parsed[i] = {
            r: iScale.parse(resolveObjectKey(item, key), index)
          };
        }
        return parsed;
      }
      var EPSILON = Number.EPSILON || 1e-14;
      var getPoint = (points, i) => i < points.length && !points[i].skip && points[i];
      var getValueAxis = (indexAxis) => indexAxis === "x" ? "y" : "x";
      function splineCurve(firstPoint, middlePoint, afterPoint, t) {
        const previous = firstPoint.skip ? middlePoint : firstPoint;
        const current = middlePoint;
        const next = afterPoint.skip ? middlePoint : afterPoint;
        const d01 = distanceBetweenPoints(current, previous);
        const d12 = distanceBetweenPoints(next, current);
        let s01 = d01 / (d01 + d12);
        let s12 = d12 / (d01 + d12);
        s01 = isNaN(s01) ? 0 : s01;
        s12 = isNaN(s12) ? 0 : s12;
        const fa = t * s01;
        const fb = t * s12;
        return {
          previous: {
            x: current.x - fa * (next.x - previous.x),
            y: current.y - fa * (next.y - previous.y)
          },
          next: {
            x: current.x + fb * (next.x - previous.x),
            y: current.y + fb * (next.y - previous.y)
          }
        };
      }
      function monotoneAdjust(points, deltaK, mK) {
        const pointsLen = points.length;
        let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
        let pointAfter = getPoint(points, 0);
        for (let i = 0; i < pointsLen - 1; ++i) {
          pointCurrent = pointAfter;
          pointAfter = getPoint(points, i + 1);
          if (!pointCurrent || !pointAfter) {
            continue;
          }
          if (almostEquals(deltaK[i], 0, EPSILON)) {
            mK[i] = mK[i + 1] = 0;
            continue;
          }
          alphaK = mK[i] / deltaK[i];
          betaK = mK[i + 1] / deltaK[i];
          squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
          if (squaredMagnitude <= 9) {
            continue;
          }
          tauK = 3 / Math.sqrt(squaredMagnitude);
          mK[i] = alphaK * tauK * deltaK[i];
          mK[i + 1] = betaK * tauK * deltaK[i];
        }
      }
      function monotoneCompute(points, mK, indexAxis = "x") {
        const valueAxis = getValueAxis(indexAxis);
        const pointsLen = points.length;
        let delta, pointBefore, pointCurrent;
        let pointAfter = getPoint(points, 0);
        for (let i = 0; i < pointsLen; ++i) {
          pointBefore = pointCurrent;
          pointCurrent = pointAfter;
          pointAfter = getPoint(points, i + 1);
          if (!pointCurrent) {
            continue;
          }
          const iPixel = pointCurrent[indexAxis];
          const vPixel = pointCurrent[valueAxis];
          if (pointBefore) {
            delta = (iPixel - pointBefore[indexAxis]) / 3;
            pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
            pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];
          }
          if (pointAfter) {
            delta = (pointAfter[indexAxis] - iPixel) / 3;
            pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
            pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];
          }
        }
      }
      function splineCurveMonotone(points, indexAxis = "x") {
        const valueAxis = getValueAxis(indexAxis);
        const pointsLen = points.length;
        const deltaK = Array(pointsLen).fill(0);
        const mK = Array(pointsLen);
        let i, pointBefore, pointCurrent;
        let pointAfter = getPoint(points, 0);
        for (i = 0; i < pointsLen; ++i) {
          pointBefore = pointCurrent;
          pointCurrent = pointAfter;
          pointAfter = getPoint(points, i + 1);
          if (!pointCurrent) {
            continue;
          }
          if (pointAfter) {
            const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
            deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
          }
          mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;
        }
        monotoneAdjust(points, deltaK, mK);
        monotoneCompute(points, mK, indexAxis);
      }
      function capControlPoint(pt, min, max) {
        return Math.max(Math.min(pt, max), min);
      }
      function capBezierPoints(points, area) {
        let i, ilen, point, inArea, inAreaPrev;
        let inAreaNext = _isPointInArea(points[0], area);
        for (i = 0, ilen = points.length; i < ilen; ++i) {
          inAreaPrev = inArea;
          inArea = inAreaNext;
          inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);
          if (!inArea) {
            continue;
          }
          point = points[i];
          if (inAreaPrev) {
            point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
            point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
          }
          if (inAreaNext) {
            point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
            point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
          }
        }
      }
      function _updateBezierControlPoints(points, options, area, loop, indexAxis) {
        let i, ilen, point, controlPoints;
        if (options.spanGaps) {
          points = points.filter((pt) => !pt.skip);
        }
        if (options.cubicInterpolationMode === "monotone") {
          splineCurveMonotone(points, indexAxis);
        } else {
          let prev = loop ? points[points.length - 1] : points[0];
          for (i = 0, ilen = points.length; i < ilen; ++i) {
            point = points[i];
            controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);
            point.cp1x = controlPoints.previous.x;
            point.cp1y = controlPoints.previous.y;
            point.cp2x = controlPoints.next.x;
            point.cp2y = controlPoints.next.y;
            prev = point;
          }
        }
        if (options.capBezierPoints) {
          capBezierPoints(points, area);
        }
      }
      function _isDomSupported() {
        return typeof window !== "undefined" && typeof document !== "undefined";
      }
      function _getParentNode(domNode) {
        let parent = domNode.parentNode;
        if (parent && parent.toString() === "[object ShadowRoot]") {
          parent = parent.host;
        }
        return parent;
      }
      function parseMaxStyle(styleValue, node, parentProperty) {
        let valueInPixels;
        if (typeof styleValue === "string") {
          valueInPixels = parseInt(styleValue, 10);
          if (styleValue.indexOf("%") !== -1) {
            valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
          }
        } else {
          valueInPixels = styleValue;
        }
        return valueInPixels;
      }
      var getComputedStyle = (element) => element.ownerDocument.defaultView.getComputedStyle(element, null);
      function getStyle(el, property) {
        return getComputedStyle(el).getPropertyValue(property);
      }
      var positions = [
        "top",
        "right",
        "bottom",
        "left"
      ];
      function getPositionedStyle(styles, style, suffix) {
        const result = {};
        suffix = suffix ? "-" + suffix : "";
        for (let i = 0; i < 4; i++) {
          const pos = positions[i];
          result[pos] = parseFloat(styles[style + "-" + pos + suffix]) || 0;
        }
        result.width = result.left + result.right;
        result.height = result.top + result.bottom;
        return result;
      }
      var useOffsetPos = (x, y, target) => (x > 0 || y > 0) && (!target || !target.shadowRoot);
      function getCanvasPosition(e, canvas) {
        const touches = e.touches;
        const source = touches && touches.length ? touches[0] : e;
        const { offsetX, offsetY } = source;
        let box = false;
        let x, y;
        if (useOffsetPos(offsetX, offsetY, e.target)) {
          x = offsetX;
          y = offsetY;
        } else {
          const rect = canvas.getBoundingClientRect();
          x = source.clientX - rect.left;
          y = source.clientY - rect.top;
          box = true;
        }
        return {
          x,
          y,
          box
        };
      }
      function getRelativePosition(event, chart) {
        if ("native" in event) {
          return event;
        }
        const { canvas, currentDevicePixelRatio } = chart;
        const style = getComputedStyle(canvas);
        const borderBox = style.boxSizing === "border-box";
        const paddings = getPositionedStyle(style, "padding");
        const borders = getPositionedStyle(style, "border", "width");
        const { x, y, box } = getCanvasPosition(event, canvas);
        const xOffset = paddings.left + (box && borders.left);
        const yOffset = paddings.top + (box && borders.top);
        let { width, height } = chart;
        if (borderBox) {
          width -= paddings.width + borders.width;
          height -= paddings.height + borders.height;
        }
        return {
          x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),
          y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)
        };
      }
      function getContainerSize(canvas, width, height) {
        let maxWidth, maxHeight;
        if (width === void 0 || height === void 0) {
          const container = _getParentNode(canvas);
          if (!container) {
            width = canvas.clientWidth;
            height = canvas.clientHeight;
          } else {
            const rect = container.getBoundingClientRect();
            const containerStyle = getComputedStyle(container);
            const containerBorder = getPositionedStyle(containerStyle, "border", "width");
            const containerPadding = getPositionedStyle(containerStyle, "padding");
            width = rect.width - containerPadding.width - containerBorder.width;
            height = rect.height - containerPadding.height - containerBorder.height;
            maxWidth = parseMaxStyle(containerStyle.maxWidth, container, "clientWidth");
            maxHeight = parseMaxStyle(containerStyle.maxHeight, container, "clientHeight");
          }
        }
        return {
          width,
          height,
          maxWidth: maxWidth || INFINITY,
          maxHeight: maxHeight || INFINITY
        };
      }
      var round1 = (v) => Math.round(v * 10) / 10;
      function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
        const style = getComputedStyle(canvas);
        const margins = getPositionedStyle(style, "margin");
        const maxWidth = parseMaxStyle(style.maxWidth, canvas, "clientWidth") || INFINITY;
        const maxHeight = parseMaxStyle(style.maxHeight, canvas, "clientHeight") || INFINITY;
        const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
        let { width, height } = containerSize;
        if (style.boxSizing === "content-box") {
          const borders = getPositionedStyle(style, "border", "width");
          const paddings = getPositionedStyle(style, "padding");
          width -= paddings.width + borders.width;
          height -= paddings.height + borders.height;
        }
        width = Math.max(0, width - margins.width);
        height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);
        width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
        height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
        if (width && !height) {
          height = round1(width / 2);
        }
        const maintainHeight = bbWidth !== void 0 || bbHeight !== void 0;
        if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {
          height = containerSize.height;
          width = round1(Math.floor(height * aspectRatio));
        }
        return {
          width,
          height
        };
      }
      function retinaScale(chart, forceRatio, forceStyle) {
        const pixelRatio = forceRatio || 1;
        const deviceHeight = Math.floor(chart.height * pixelRatio);
        const deviceWidth = Math.floor(chart.width * pixelRatio);
        chart.height = Math.floor(chart.height);
        chart.width = Math.floor(chart.width);
        const canvas = chart.canvas;
        if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
          canvas.style.height = `${chart.height}px`;
          canvas.style.width = `${chart.width}px`;
        }
        if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
          chart.currentDevicePixelRatio = pixelRatio;
          canvas.height = deviceHeight;
          canvas.width = deviceWidth;
          chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
          return true;
        }
        return false;
      }
      var supportsEventListenerOptions = function() {
        let passiveSupported = false;
        try {
          const options = {
            get passive() {
              passiveSupported = true;
              return false;
            }
          };
          window.addEventListener("test", null, options);
          window.removeEventListener("test", null, options);
        } catch (e) {
        }
        return passiveSupported;
      }();
      function readUsedSize(element, property) {
        const value = getStyle(element, property);
        const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
        return matches ? +matches[1] : void 0;
      }
      function _pointInLine(p1, p2, t, mode) {
        return {
          x: p1.x + t * (p2.x - p1.x),
          y: p1.y + t * (p2.y - p1.y)
        };
      }
      function _steppedInterpolation(p1, p2, t, mode) {
        return {
          x: p1.x + t * (p2.x - p1.x),
          y: mode === "middle" ? t < 0.5 ? p1.y : p2.y : mode === "after" ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y
        };
      }
      function _bezierInterpolation(p1, p2, t, mode) {
        const cp1 = {
          x: p1.cp2x,
          y: p1.cp2y
        };
        const cp2 = {
          x: p2.cp1x,
          y: p2.cp1y
        };
        const a = _pointInLine(p1, cp1, t);
        const b = _pointInLine(cp1, cp2, t);
        const c = _pointInLine(cp2, p2, t);
        const d = _pointInLine(a, b, t);
        const e = _pointInLine(b, c, t);
        return _pointInLine(d, e, t);
      }
      var getRightToLeftAdapter = function(rectX, width) {
        return {
          x(x) {
            return rectX + rectX + width - x;
          },
          setWidth(w) {
            width = w;
          },
          textAlign(align) {
            if (align === "center") {
              return align;
            }
            return align === "right" ? "left" : "right";
          },
          xPlus(x, value) {
            return x - value;
          },
          leftForLtr(x, itemWidth) {
            return x - itemWidth;
          }
        };
      };
      var getLeftToRightAdapter = function() {
        return {
          x(x) {
            return x;
          },
          setWidth(w) {
          },
          textAlign(align) {
            return align;
          },
          xPlus(x, value) {
            return x + value;
          },
          leftForLtr(x, _itemWidth) {
            return x;
          }
        };
      };
      function getRtlAdapter(rtl, rectX, width) {
        return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
      }
      function overrideTextDirection(ctx, direction) {
        let style, original;
        if (direction === "ltr" || direction === "rtl") {
          style = ctx.canvas.style;
          original = [
            style.getPropertyValue("direction"),
            style.getPropertyPriority("direction")
          ];
          style.setProperty("direction", direction, "important");
          ctx.prevTextDirection = original;
        }
      }
      function restoreTextDirection(ctx, original) {
        if (original !== void 0) {
          delete ctx.prevTextDirection;
          ctx.canvas.style.setProperty("direction", original[0], original[1]);
        }
      }
      function propertyFn(property) {
        if (property === "angle") {
          return {
            between: _angleBetween,
            compare: _angleDiff,
            normalize: _normalizeAngle
          };
        }
        return {
          between: _isBetween,
          compare: (a, b) => a - b,
          normalize: (x) => x
        };
      }
      function normalizeSegment({ start, end, count, loop, style }) {
        return {
          start: start % count,
          end: end % count,
          loop: loop && (end - start + 1) % count === 0,
          style
        };
      }
      function getSegment(segment, points, bounds) {
        const { property, start: startBound, end: endBound } = bounds;
        const { between, normalize } = propertyFn(property);
        const count = points.length;
        let { start, end, loop } = segment;
        let i, ilen;
        if (loop) {
          start += count;
          end += count;
          for (i = 0, ilen = count; i < ilen; ++i) {
            if (!between(normalize(points[start % count][property]), startBound, endBound)) {
              break;
            }
            start--;
            end--;
          }
          start %= count;
          end %= count;
        }
        if (end < start) {
          end += count;
        }
        return {
          start,
          end,
          loop,
          style: segment.style
        };
      }
      function _boundSegment(segment, points, bounds) {
        if (!bounds) {
          return [
            segment
          ];
        }
        const { property, start: startBound, end: endBound } = bounds;
        const count = points.length;
        const { compare, between, normalize } = propertyFn(property);
        const { start, end, loop, style } = getSegment(segment, points, bounds);
        const result = [];
        let inside = false;
        let subStart = null;
        let value, point, prevValue;
        const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;
        const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);
        const shouldStart = () => inside || startIsBefore();
        const shouldStop = () => !inside || endIsBefore();
        for (let i = start, prev = start; i <= end; ++i) {
          point = points[i % count];
          if (point.skip) {
            continue;
          }
          value = normalize(point[property]);
          if (value === prevValue) {
            continue;
          }
          inside = between(value, startBound, endBound);
          if (subStart === null && shouldStart()) {
            subStart = compare(value, startBound) === 0 ? i : prev;
          }
          if (subStart !== null && shouldStop()) {
            result.push(normalizeSegment({
              start: subStart,
              end: i,
              loop,
              count,
              style
            }));
            subStart = null;
          }
          prev = i;
          prevValue = value;
        }
        if (subStart !== null) {
          result.push(normalizeSegment({
            start: subStart,
            end,
            loop,
            count,
            style
          }));
        }
        return result;
      }
      function _boundSegments(line, bounds) {
        const result = [];
        const segments = line.segments;
        for (let i = 0; i < segments.length; i++) {
          const sub = _boundSegment(segments[i], line.points, bounds);
          if (sub.length) {
            result.push(...sub);
          }
        }
        return result;
      }
      function findStartAndEnd(points, count, loop, spanGaps) {
        let start = 0;
        let end = count - 1;
        if (loop && !spanGaps) {
          while (start < count && !points[start].skip) {
            start++;
          }
        }
        while (start < count && points[start].skip) {
          start++;
        }
        start %= count;
        if (loop) {
          end += start;
        }
        while (end > start && points[end % count].skip) {
          end--;
        }
        end %= count;
        return {
          start,
          end
        };
      }
      function solidSegments(points, start, max, loop) {
        const count = points.length;
        const result = [];
        let last = start;
        let prev = points[start];
        let end;
        for (end = start + 1; end <= max; ++end) {
          const cur = points[end % count];
          if (cur.skip || cur.stop) {
            if (!prev.skip) {
              loop = false;
              result.push({
                start: start % count,
                end: (end - 1) % count,
                loop
              });
              start = last = cur.stop ? end : null;
            }
          } else {
            last = end;
            if (prev.skip) {
              start = end;
            }
          }
          prev = cur;
        }
        if (last !== null) {
          result.push({
            start: start % count,
            end: last % count,
            loop
          });
        }
        return result;
      }
      function _computeSegments(line, segmentOptions) {
        const points = line.points;
        const spanGaps = line.options.spanGaps;
        const count = points.length;
        if (!count) {
          return [];
        }
        const loop = !!line._loop;
        const { start, end } = findStartAndEnd(points, count, loop, spanGaps);
        if (spanGaps === true) {
          return splitByStyles(line, [
            {
              start,
              end,
              loop
            }
          ], points, segmentOptions);
        }
        const max = end < start ? end + count : end;
        const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;
        return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);
      }
      function splitByStyles(line, segments, points, segmentOptions) {
        if (!segmentOptions || !segmentOptions.setContext || !points) {
          return segments;
        }
        return doSplitByStyles(line, segments, points, segmentOptions);
      }
      function doSplitByStyles(line, segments, points, segmentOptions) {
        const chartContext = line._chart.getContext();
        const baseStyle = readStyle(line.options);
        const { _datasetIndex: datasetIndex, options: { spanGaps } } = line;
        const count = points.length;
        const result = [];
        let prevStyle = baseStyle;
        let start = segments[0].start;
        let i = start;
        function addStyle(s, e, l, st) {
          const dir = spanGaps ? -1 : 1;
          if (s === e) {
            return;
          }
          s += count;
          while (points[s % count].skip) {
            s -= dir;
          }
          while (points[e % count].skip) {
            e += dir;
          }
          if (s % count !== e % count) {
            result.push({
              start: s % count,
              end: e % count,
              loop: l,
              style: st
            });
            prevStyle = st;
            start = e % count;
          }
        }
        for (const segment of segments) {
          start = spanGaps ? start : segment.start;
          let prev = points[start % count];
          let style;
          for (i = start + 1; i <= segment.end; i++) {
            const pt = points[i % count];
            style = readStyle(segmentOptions.setContext(createContext(chartContext, {
              type: "segment",
              p0: prev,
              p1: pt,
              p0DataIndex: (i - 1) % count,
              p1DataIndex: i % count,
              datasetIndex
            })));
            if (styleChanged(style, prevStyle)) {
              addStyle(start, i - 1, segment.loop, prevStyle);
            }
            prev = pt;
            prevStyle = style;
          }
          if (start < i - 1) {
            addStyle(start, i - 1, segment.loop, prevStyle);
          }
        }
        return result;
      }
      function readStyle(options) {
        return {
          backgroundColor: options.backgroundColor,
          borderCapStyle: options.borderCapStyle,
          borderDash: options.borderDash,
          borderDashOffset: options.borderDashOffset,
          borderJoinStyle: options.borderJoinStyle,
          borderWidth: options.borderWidth,
          borderColor: options.borderColor
        };
      }
      function styleChanged(style, prevStyle) {
        if (!prevStyle) {
          return false;
        }
        const cache = [];
        const replacer = function(key, value) {
          if (!isPatternOrGradient(value)) {
            return value;
          }
          if (!cache.includes(value)) {
            cache.push(value);
          }
          return cache.indexOf(value);
        };
        return JSON.stringify(style, replacer) !== JSON.stringify(prevStyle, replacer);
      }
      exports.HALF_PI = HALF_PI;
      exports.INFINITY = INFINITY;
      exports.PI = PI;
      exports.PITAU = PITAU;
      exports.QUARTER_PI = QUARTER_PI;
      exports.RAD_PER_DEG = RAD_PER_DEG;
      exports.TAU = TAU;
      exports.TWO_THIRDS_PI = TWO_THIRDS_PI;
      exports.Ticks = Ticks;
      exports._addGrace = _addGrace;
      exports._alignPixel = _alignPixel;
      exports._alignStartEnd = _alignStartEnd;
      exports._angleBetween = _angleBetween;
      exports._angleDiff = _angleDiff;
      exports._arrayUnique = _arrayUnique;
      exports._attachContext = _attachContext;
      exports._bezierCurveTo = _bezierCurveTo;
      exports._bezierInterpolation = _bezierInterpolation;
      exports._boundSegment = _boundSegment;
      exports._boundSegments = _boundSegments;
      exports._capitalize = _capitalize;
      exports._computeSegments = _computeSegments;
      exports._createResolver = _createResolver;
      exports._decimalPlaces = _decimalPlaces;
      exports._deprecated = _deprecated;
      exports._descriptors = _descriptors;
      exports._elementsEqual = _elementsEqual;
      exports._factorize = _factorize;
      exports._filterBetween = _filterBetween;
      exports._getParentNode = _getParentNode;
      exports._getStartAndCountOfVisiblePoints = _getStartAndCountOfVisiblePoints;
      exports._int16Range = _int16Range;
      exports._isBetween = _isBetween;
      exports._isClickEvent = _isClickEvent;
      exports._isDomSupported = _isDomSupported;
      exports._isPointInArea = _isPointInArea;
      exports._limitValue = _limitValue;
      exports._longestText = _longestText;
      exports._lookup = _lookup;
      exports._lookupByKey = _lookupByKey;
      exports._measureText = _measureText;
      exports._merger = _merger;
      exports._mergerIf = _mergerIf;
      exports._normalizeAngle = _normalizeAngle;
      exports._parseObjectDataRadialScale = _parseObjectDataRadialScale;
      exports._pointInLine = _pointInLine;
      exports._readValueToProps = _readValueToProps;
      exports._rlookupByKey = _rlookupByKey;
      exports._scaleRangesChanged = _scaleRangesChanged;
      exports._setMinAndMaxByKey = _setMinAndMaxByKey;
      exports._splitKey = _splitKey;
      exports._steppedInterpolation = _steppedInterpolation;
      exports._steppedLineTo = _steppedLineTo;
      exports._textX = _textX;
      exports._toLeftRightCenter = _toLeftRightCenter;
      exports._updateBezierControlPoints = _updateBezierControlPoints;
      exports.addRoundedRectPath = addRoundedRectPath;
      exports.almostEquals = almostEquals;
      exports.almostWhole = almostWhole;
      exports.callback = callback;
      exports.clearCanvas = clearCanvas;
      exports.clipArea = clipArea;
      exports.clone = clone;
      exports.color = color;
      exports.createContext = createContext;
      exports.debounce = debounce;
      exports.defaults = defaults;
      exports.defined = defined;
      exports.descriptors = descriptors;
      exports.distanceBetweenPoints = distanceBetweenPoints;
      exports.drawPoint = drawPoint;
      exports.drawPointLegend = drawPointLegend;
      exports.each = each;
      exports.effects = effects;
      exports.finiteOrDefault = finiteOrDefault;
      exports.fontString = fontString;
      exports.formatNumber = formatNumber;
      exports.getAngleFromPoint = getAngleFromPoint;
      exports.getHoverColor = getHoverColor;
      exports.getMaximumSize = getMaximumSize;
      exports.getRelativePosition = getRelativePosition;
      exports.getRtlAdapter = getRtlAdapter;
      exports.getStyle = getStyle;
      exports.isArray = isArray;
      exports.isFunction = isFunction;
      exports.isNullOrUndef = isNullOrUndef;
      exports.isNumber = isNumber;
      exports.isNumberFinite = isNumberFinite;
      exports.isObject = isObject;
      exports.isPatternOrGradient = isPatternOrGradient;
      exports.listenArrayEvents = listenArrayEvents;
      exports.log10 = log10;
      exports.merge = merge;
      exports.mergeIf = mergeIf;
      exports.niceNum = niceNum;
      exports.noop = noop;
      exports.overrideTextDirection = overrideTextDirection;
      exports.overrides = overrides;
      exports.readUsedSize = readUsedSize;
      exports.renderText = renderText;
      exports.requestAnimFrame = requestAnimFrame;
      exports.resolve = resolve;
      exports.resolveObjectKey = resolveObjectKey;
      exports.restoreTextDirection = restoreTextDirection;
      exports.retinaScale = retinaScale;
      exports.setsEqual = setsEqual;
      exports.sign = sign;
      exports.splineCurve = splineCurve;
      exports.splineCurveMonotone = splineCurveMonotone;
      exports.supportsEventListenerOptions = supportsEventListenerOptions;
      exports.throttled = throttled;
      exports.toDegrees = toDegrees;
      exports.toDimension = toDimension;
      exports.toFont = toFont;
      exports.toFontString = toFontString;
      exports.toLineHeight = toLineHeight;
      exports.toPadding = toPadding;
      exports.toPercentage = toPercentage;
      exports.toRadians = toRadians;
      exports.toTRBL = toTRBL;
      exports.toTRBLCorners = toTRBLCorners;
      exports.uid = uid;
      exports.unclipArea = unclipArea;
      exports.unlistenArrayEvents = unlistenArrayEvents;
      exports.valueOrDefault = valueOrDefault;
    }
  });

  // node_modules/chart.js/dist/chart.cjs
  var require_chart = __commonJS({
    "node_modules/chart.js/dist/chart.cjs"(exports) {
      "use strict";
      var helpers_segment = require_helpers_segment();
      require_color();
      var Animator = class {
        constructor() {
          this._request = null;
          this._charts = /* @__PURE__ */ new Map();
          this._running = false;
          this._lastDate = void 0;
        }
        _notify(chart, anims, date, type) {
          const callbacks = anims.listeners[type];
          const numSteps = anims.duration;
          callbacks.forEach((fn) => fn({
            chart,
            initial: anims.initial,
            numSteps,
            currentStep: Math.min(date - anims.start, numSteps)
          }));
        }
        _refresh() {
          if (this._request) {
            return;
          }
          this._running = true;
          this._request = helpers_segment.requestAnimFrame.call(window, () => {
            this._update();
            this._request = null;
            if (this._running) {
              this._refresh();
            }
          });
        }
        _update(date = Date.now()) {
          let remaining = 0;
          this._charts.forEach((anims, chart) => {
            if (!anims.running || !anims.items.length) {
              return;
            }
            const items = anims.items;
            let i = items.length - 1;
            let draw2 = false;
            let item;
            for (; i >= 0; --i) {
              item = items[i];
              if (item._active) {
                if (item._total > anims.duration) {
                  anims.duration = item._total;
                }
                item.tick(date);
                draw2 = true;
              } else {
                items[i] = items[items.length - 1];
                items.pop();
              }
            }
            if (draw2) {
              chart.draw();
              this._notify(chart, anims, date, "progress");
            }
            if (!items.length) {
              anims.running = false;
              this._notify(chart, anims, date, "complete");
              anims.initial = false;
            }
            remaining += items.length;
          });
          this._lastDate = date;
          if (remaining === 0) {
            this._running = false;
          }
        }
        _getAnims(chart) {
          const charts = this._charts;
          let anims = charts.get(chart);
          if (!anims) {
            anims = {
              running: false,
              initial: true,
              items: [],
              listeners: {
                complete: [],
                progress: []
              }
            };
            charts.set(chart, anims);
          }
          return anims;
        }
        listen(chart, event, cb) {
          this._getAnims(chart).listeners[event].push(cb);
        }
        add(chart, items) {
          if (!items || !items.length) {
            return;
          }
          this._getAnims(chart).items.push(...items);
        }
        has(chart) {
          return this._getAnims(chart).items.length > 0;
        }
        start(chart) {
          const anims = this._charts.get(chart);
          if (!anims) {
            return;
          }
          anims.running = true;
          anims.start = Date.now();
          anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);
          this._refresh();
        }
        running(chart) {
          if (!this._running) {
            return false;
          }
          const anims = this._charts.get(chart);
          if (!anims || !anims.running || !anims.items.length) {
            return false;
          }
          return true;
        }
        stop(chart) {
          const anims = this._charts.get(chart);
          if (!anims || !anims.items.length) {
            return;
          }
          const items = anims.items;
          let i = items.length - 1;
          for (; i >= 0; --i) {
            items[i].cancel();
          }
          anims.items = [];
          this._notify(chart, anims, Date.now(), "complete");
        }
        remove(chart) {
          return this._charts.delete(chart);
        }
      };
      var animator = /* @__PURE__ */ new Animator();
      var transparent = "transparent";
      var interpolators = {
        boolean(from, to, factor) {
          return factor > 0.5 ? to : from;
        },
        color(from, to, factor) {
          const c0 = helpers_segment.color(from || transparent);
          const c1 = c0.valid && helpers_segment.color(to || transparent);
          return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to;
        },
        number(from, to, factor) {
          return from + (to - from) * factor;
        }
      };
      var Animation = class {
        constructor(cfg, target, prop, to) {
          const currentValue = target[prop];
          to = helpers_segment.resolve([
            cfg.to,
            to,
            currentValue,
            cfg.from
          ]);
          const from = helpers_segment.resolve([
            cfg.from,
            currentValue,
            to
          ]);
          this._active = true;
          this._fn = cfg.fn || interpolators[cfg.type || typeof from];
          this._easing = helpers_segment.effects[cfg.easing] || helpers_segment.effects.linear;
          this._start = Math.floor(Date.now() + (cfg.delay || 0));
          this._duration = this._total = Math.floor(cfg.duration);
          this._loop = !!cfg.loop;
          this._target = target;
          this._prop = prop;
          this._from = from;
          this._to = to;
          this._promises = void 0;
        }
        active() {
          return this._active;
        }
        update(cfg, to, date) {
          if (this._active) {
            this._notify(false);
            const currentValue = this._target[this._prop];
            const elapsed = date - this._start;
            const remain = this._duration - elapsed;
            this._start = date;
            this._duration = Math.floor(Math.max(remain, cfg.duration));
            this._total += elapsed;
            this._loop = !!cfg.loop;
            this._to = helpers_segment.resolve([
              cfg.to,
              to,
              currentValue,
              cfg.from
            ]);
            this._from = helpers_segment.resolve([
              cfg.from,
              currentValue,
              to
            ]);
          }
        }
        cancel() {
          if (this._active) {
            this.tick(Date.now());
            this._active = false;
            this._notify(false);
          }
        }
        tick(date) {
          const elapsed = date - this._start;
          const duration = this._duration;
          const prop = this._prop;
          const from = this._from;
          const loop = this._loop;
          const to = this._to;
          let factor;
          this._active = from !== to && (loop || elapsed < duration);
          if (!this._active) {
            this._target[prop] = to;
            this._notify(true);
            return;
          }
          if (elapsed < 0) {
            this._target[prop] = from;
            return;
          }
          factor = elapsed / duration % 2;
          factor = loop && factor > 1 ? 2 - factor : factor;
          factor = this._easing(Math.min(1, Math.max(0, factor)));
          this._target[prop] = this._fn(from, to, factor);
        }
        wait() {
          const promises = this._promises || (this._promises = []);
          return new Promise((res, rej) => {
            promises.push({
              res,
              rej
            });
          });
        }
        _notify(resolved) {
          const method = resolved ? "res" : "rej";
          const promises = this._promises || [];
          for (let i = 0; i < promises.length; i++) {
            promises[i][method]();
          }
        }
      };
      var Animations = class {
        constructor(chart, config) {
          this._chart = chart;
          this._properties = /* @__PURE__ */ new Map();
          this.configure(config);
        }
        configure(config) {
          if (!helpers_segment.isObject(config)) {
            return;
          }
          const animationOptions = Object.keys(helpers_segment.defaults.animation);
          const animatedProps = this._properties;
          Object.getOwnPropertyNames(config).forEach((key) => {
            const cfg = config[key];
            if (!helpers_segment.isObject(cfg)) {
              return;
            }
            const resolved = {};
            for (const option of animationOptions) {
              resolved[option] = cfg[option];
            }
            (helpers_segment.isArray(cfg.properties) && cfg.properties || [
              key
            ]).forEach((prop) => {
              if (prop === key || !animatedProps.has(prop)) {
                animatedProps.set(prop, resolved);
              }
            });
          });
        }
        _animateOptions(target, values) {
          const newOptions = values.options;
          const options = resolveTargetOptions(target, newOptions);
          if (!options) {
            return [];
          }
          const animations = this._createAnimations(options, newOptions);
          if (newOptions.$shared) {
            awaitAll(target.options.$animations, newOptions).then(() => {
              target.options = newOptions;
            }, () => {
            });
          }
          return animations;
        }
        _createAnimations(target, values) {
          const animatedProps = this._properties;
          const animations = [];
          const running = target.$animations || (target.$animations = {});
          const props = Object.keys(values);
          const date = Date.now();
          let i;
          for (i = props.length - 1; i >= 0; --i) {
            const prop = props[i];
            if (prop.charAt(0) === "$") {
              continue;
            }
            if (prop === "options") {
              animations.push(...this._animateOptions(target, values));
              continue;
            }
            const value = values[prop];
            let animation = running[prop];
            const cfg = animatedProps.get(prop);
            if (animation) {
              if (cfg && animation.active()) {
                animation.update(cfg, value, date);
                continue;
              } else {
                animation.cancel();
              }
            }
            if (!cfg || !cfg.duration) {
              target[prop] = value;
              continue;
            }
            running[prop] = animation = new Animation(cfg, target, prop, value);
            animations.push(animation);
          }
          return animations;
        }
        update(target, values) {
          if (this._properties.size === 0) {
            Object.assign(target, values);
            return;
          }
          const animations = this._createAnimations(target, values);
          if (animations.length) {
            animator.add(this._chart, animations);
            return true;
          }
        }
      };
      function awaitAll(animations, properties) {
        const running = [];
        const keys = Object.keys(properties);
        for (let i = 0; i < keys.length; i++) {
          const anim = animations[keys[i]];
          if (anim && anim.active()) {
            running.push(anim.wait());
          }
        }
        return Promise.all(running);
      }
      function resolveTargetOptions(target, newOptions) {
        if (!newOptions) {
          return;
        }
        let options = target.options;
        if (!options) {
          target.options = newOptions;
          return;
        }
        if (options.$shared) {
          target.options = options = Object.assign({}, options, {
            $shared: false,
            $animations: {}
          });
        }
        return options;
      }
      function scaleClip(scale, allowedOverflow) {
        const opts = scale && scale.options || {};
        const reverse = opts.reverse;
        const min = opts.min === void 0 ? allowedOverflow : 0;
        const max = opts.max === void 0 ? allowedOverflow : 0;
        return {
          start: reverse ? max : min,
          end: reverse ? min : max
        };
      }
      function defaultClip(xScale, yScale, allowedOverflow) {
        if (allowedOverflow === false) {
          return false;
        }
        const x = scaleClip(xScale, allowedOverflow);
        const y = scaleClip(yScale, allowedOverflow);
        return {
          top: y.end,
          right: x.end,
          bottom: y.start,
          left: x.start
        };
      }
      function toClip(value) {
        let t, r, b, l;
        if (helpers_segment.isObject(value)) {
          t = value.top;
          r = value.right;
          b = value.bottom;
          l = value.left;
        } else {
          t = r = b = l = value;
        }
        return {
          top: t,
          right: r,
          bottom: b,
          left: l,
          disabled: value === false
        };
      }
      function getSortedDatasetIndices(chart, filterVisible) {
        const keys = [];
        const metasets = chart._getSortedDatasetMetas(filterVisible);
        let i, ilen;
        for (i = 0, ilen = metasets.length; i < ilen; ++i) {
          keys.push(metasets[i].index);
        }
        return keys;
      }
      function applyStack(stack, value, dsIndex, options = {}) {
        const keys = stack.keys;
        const singleMode = options.mode === "single";
        let i, ilen, datasetIndex, otherValue;
        if (value === null) {
          return;
        }
        for (i = 0, ilen = keys.length; i < ilen; ++i) {
          datasetIndex = +keys[i];
          if (datasetIndex === dsIndex) {
            if (options.all) {
              continue;
            }
            break;
          }
          otherValue = stack.values[datasetIndex];
          if (helpers_segment.isNumberFinite(otherValue) && (singleMode || value === 0 || helpers_segment.sign(value) === helpers_segment.sign(otherValue))) {
            value += otherValue;
          }
        }
        return value;
      }
      function convertObjectDataToArray(data) {
        const keys = Object.keys(data);
        const adata = new Array(keys.length);
        let i, ilen, key;
        for (i = 0, ilen = keys.length; i < ilen; ++i) {
          key = keys[i];
          adata[i] = {
            x: key,
            y: data[key]
          };
        }
        return adata;
      }
      function isStacked(scale, meta) {
        const stacked = scale && scale.options.stacked;
        return stacked || stacked === void 0 && meta.stack !== void 0;
      }
      function getStackKey(indexScale, valueScale, meta) {
        return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
      }
      function getUserBounds(scale) {
        const { min, max, minDefined, maxDefined } = scale.getUserBounds();
        return {
          min: minDefined ? min : Number.NEGATIVE_INFINITY,
          max: maxDefined ? max : Number.POSITIVE_INFINITY
        };
      }
      function getOrCreateStack(stacks, stackKey, indexValue) {
        const subStack = stacks[stackKey] || (stacks[stackKey] = {});
        return subStack[indexValue] || (subStack[indexValue] = {});
      }
      function getLastIndexInStack(stack, vScale, positive, type) {
        for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {
          const value = stack[meta.index];
          if (positive && value > 0 || !positive && value < 0) {
            return meta.index;
          }
        }
        return null;
      }
      function updateStacks(controller, parsed) {
        const { chart, _cachedMeta: meta } = controller;
        const stacks = chart._stacks || (chart._stacks = {});
        const { iScale, vScale, index: datasetIndex } = meta;
        const iAxis = iScale.axis;
        const vAxis = vScale.axis;
        const key = getStackKey(iScale, vScale, meta);
        const ilen = parsed.length;
        let stack;
        for (let i = 0; i < ilen; ++i) {
          const item = parsed[i];
          const { [iAxis]: index2, [vAxis]: value } = item;
          const itemStacks = item._stacks || (item._stacks = {});
          stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index2);
          stack[datasetIndex] = value;
          stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
          stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
          const visualValues = stack._visualValues || (stack._visualValues = {});
          visualValues[datasetIndex] = value;
        }
      }
      function getFirstScaleId(chart, axis) {
        const scales2 = chart.scales;
        return Object.keys(scales2).filter((key) => scales2[key].axis === axis).shift();
      }
      function createDatasetContext(parent, index2) {
        return helpers_segment.createContext(parent, {
          active: false,
          dataset: void 0,
          datasetIndex: index2,
          index: index2,
          mode: "default",
          type: "dataset"
        });
      }
      function createDataContext(parent, index2, element) {
        return helpers_segment.createContext(parent, {
          active: false,
          dataIndex: index2,
          parsed: void 0,
          raw: void 0,
          element,
          index: index2,
          mode: "default",
          type: "data"
        });
      }
      function clearStacks(meta, items) {
        const datasetIndex = meta.controller.index;
        const axis = meta.vScale && meta.vScale.axis;
        if (!axis) {
          return;
        }
        items = items || meta._parsed;
        for (const parsed of items) {
          const stacks = parsed._stacks;
          if (!stacks || stacks[axis] === void 0 || stacks[axis][datasetIndex] === void 0) {
            return;
          }
          delete stacks[axis][datasetIndex];
          if (stacks[axis]._visualValues !== void 0 && stacks[axis]._visualValues[datasetIndex] !== void 0) {
            delete stacks[axis]._visualValues[datasetIndex];
          }
        }
      }
      var isDirectUpdateMode = (mode) => mode === "reset" || mode === "none";
      var cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);
      var createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked && {
        keys: getSortedDatasetIndices(chart, true),
        values: null
      };
      var DatasetController = class {
        constructor(chart, datasetIndex) {
          this.chart = chart;
          this._ctx = chart.ctx;
          this.index = datasetIndex;
          this._cachedDataOpts = {};
          this._cachedMeta = this.getMeta();
          this._type = this._cachedMeta.type;
          this.options = void 0;
          this._parsing = false;
          this._data = void 0;
          this._objectData = void 0;
          this._sharedOptions = void 0;
          this._drawStart = void 0;
          this._drawCount = void 0;
          this.enableOptionSharing = false;
          this.supportsDecimation = false;
          this.$context = void 0;
          this._syncList = [];
          this.datasetElementType = new.target.datasetElementType;
          this.dataElementType = new.target.dataElementType;
          this.initialize();
        }
        initialize() {
          const meta = this._cachedMeta;
          this.configure();
          this.linkScales();
          meta._stacked = isStacked(meta.vScale, meta);
          this.addElements();
          if (this.options.fill && !this.chart.isPluginEnabled("filler")) {
            console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
          }
        }
        updateIndex(datasetIndex) {
          if (this.index !== datasetIndex) {
            clearStacks(this._cachedMeta);
          }
          this.index = datasetIndex;
        }
        linkScales() {
          const chart = this.chart;
          const meta = this._cachedMeta;
          const dataset = this.getDataset();
          const chooseId = (axis, x, y, r) => axis === "x" ? x : axis === "r" ? r : y;
          const xid = meta.xAxisID = helpers_segment.valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, "x"));
          const yid = meta.yAxisID = helpers_segment.valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, "y"));
          const rid = meta.rAxisID = helpers_segment.valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, "r"));
          const indexAxis = meta.indexAxis;
          const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
          const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
          meta.xScale = this.getScaleForId(xid);
          meta.yScale = this.getScaleForId(yid);
          meta.rScale = this.getScaleForId(rid);
          meta.iScale = this.getScaleForId(iid);
          meta.vScale = this.getScaleForId(vid);
        }
        getDataset() {
          return this.chart.data.datasets[this.index];
        }
        getMeta() {
          return this.chart.getDatasetMeta(this.index);
        }
        getScaleForId(scaleID) {
          return this.chart.scales[scaleID];
        }
        _getOtherScale(scale) {
          const meta = this._cachedMeta;
          return scale === meta.iScale ? meta.vScale : meta.iScale;
        }
        reset() {
          this._update("reset");
        }
        _destroy() {
          const meta = this._cachedMeta;
          if (this._data) {
            helpers_segment.unlistenArrayEvents(this._data, this);
          }
          if (meta._stacked) {
            clearStacks(meta);
          }
        }
        _dataCheck() {
          const dataset = this.getDataset();
          const data = dataset.data || (dataset.data = []);
          const _data = this._data;
          if (helpers_segment.isObject(data)) {
            this._data = convertObjectDataToArray(data);
          } else if (_data !== data) {
            if (_data) {
              helpers_segment.unlistenArrayEvents(_data, this);
              const meta = this._cachedMeta;
              clearStacks(meta);
              meta._parsed = [];
            }
            if (data && Object.isExtensible(data)) {
              helpers_segment.listenArrayEvents(data, this);
            }
            this._syncList = [];
            this._data = data;
          }
        }
        addElements() {
          const meta = this._cachedMeta;
          this._dataCheck();
          if (this.datasetElementType) {
            meta.dataset = new this.datasetElementType();
          }
        }
        buildOrUpdateElements(resetNewElements) {
          const meta = this._cachedMeta;
          const dataset = this.getDataset();
          let stackChanged = false;
          this._dataCheck();
          const oldStacked = meta._stacked;
          meta._stacked = isStacked(meta.vScale, meta);
          if (meta.stack !== dataset.stack) {
            stackChanged = true;
            clearStacks(meta);
            meta.stack = dataset.stack;
          }
          this._resyncElements(resetNewElements);
          if (stackChanged || oldStacked !== meta._stacked) {
            updateStacks(this, meta._parsed);
          }
        }
        configure() {
          const config = this.chart.config;
          const scopeKeys = config.datasetScopeKeys(this._type);
          const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
          this.options = config.createResolver(scopes, this.getContext());
          this._parsing = this.options.parsing;
          this._cachedDataOpts = {};
        }
        parse(start, count) {
          const { _cachedMeta: meta, _data: data } = this;
          const { iScale, _stacked } = meta;
          const iAxis = iScale.axis;
          let sorted = start === 0 && count === data.length ? true : meta._sorted;
          let prev = start > 0 && meta._parsed[start - 1];
          let i, cur, parsed;
          if (this._parsing === false) {
            meta._parsed = data;
            meta._sorted = true;
            parsed = data;
          } else {
            if (helpers_segment.isArray(data[start])) {
              parsed = this.parseArrayData(meta, data, start, count);
            } else if (helpers_segment.isObject(data[start])) {
              parsed = this.parseObjectData(meta, data, start, count);
            } else {
              parsed = this.parsePrimitiveData(meta, data, start, count);
            }
            const isNotInOrderComparedToPrev = () => cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];
            for (i = 0; i < count; ++i) {
              meta._parsed[i + start] = cur = parsed[i];
              if (sorted) {
                if (isNotInOrderComparedToPrev()) {
                  sorted = false;
                }
                prev = cur;
              }
            }
            meta._sorted = sorted;
          }
          if (_stacked) {
            updateStacks(this, parsed);
          }
        }
        parsePrimitiveData(meta, data, start, count) {
          const { iScale, vScale } = meta;
          const iAxis = iScale.axis;
          const vAxis = vScale.axis;
          const labels = iScale.getLabels();
          const singleScale = iScale === vScale;
          const parsed = new Array(count);
          let i, ilen, index2;
          for (i = 0, ilen = count; i < ilen; ++i) {
            index2 = i + start;
            parsed[i] = {
              [iAxis]: singleScale || iScale.parse(labels[index2], index2),
              [vAxis]: vScale.parse(data[index2], index2)
            };
          }
          return parsed;
        }
        parseArrayData(meta, data, start, count) {
          const { xScale, yScale } = meta;
          const parsed = new Array(count);
          let i, ilen, index2, item;
          for (i = 0, ilen = count; i < ilen; ++i) {
            index2 = i + start;
            item = data[index2];
            parsed[i] = {
              x: xScale.parse(item[0], index2),
              y: yScale.parse(item[1], index2)
            };
          }
          return parsed;
        }
        parseObjectData(meta, data, start, count) {
          const { xScale, yScale } = meta;
          const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
          const parsed = new Array(count);
          let i, ilen, index2, item;
          for (i = 0, ilen = count; i < ilen; ++i) {
            index2 = i + start;
            item = data[index2];
            parsed[i] = {
              x: xScale.parse(helpers_segment.resolveObjectKey(item, xAxisKey), index2),
              y: yScale.parse(helpers_segment.resolveObjectKey(item, yAxisKey), index2)
            };
          }
          return parsed;
        }
        getParsed(index2) {
          return this._cachedMeta._parsed[index2];
        }
        getDataElement(index2) {
          return this._cachedMeta.data[index2];
        }
        applyStack(scale, parsed, mode) {
          const chart = this.chart;
          const meta = this._cachedMeta;
          const value = parsed[scale.axis];
          const stack = {
            keys: getSortedDatasetIndices(chart, true),
            values: parsed._stacks[scale.axis]._visualValues
          };
          return applyStack(stack, value, meta.index, {
            mode
          });
        }
        updateRangeFromParsed(range, scale, parsed, stack) {
          const parsedValue = parsed[scale.axis];
          let value = parsedValue === null ? NaN : parsedValue;
          const values = stack && parsed._stacks[scale.axis];
          if (stack && values) {
            stack.values = values;
            value = applyStack(stack, parsedValue, this._cachedMeta.index);
          }
          range.min = Math.min(range.min, value);
          range.max = Math.max(range.max, value);
        }
        getMinMax(scale, canStack) {
          const meta = this._cachedMeta;
          const _parsed = meta._parsed;
          const sorted = meta._sorted && scale === meta.iScale;
          const ilen = _parsed.length;
          const otherScale = this._getOtherScale(scale);
          const stack = createStack(canStack, meta, this.chart);
          const range = {
            min: Number.POSITIVE_INFINITY,
            max: Number.NEGATIVE_INFINITY
          };
          const { min: otherMin, max: otherMax } = getUserBounds(otherScale);
          let i, parsed;
          function _skip() {
            parsed = _parsed[i];
            const otherValue = parsed[otherScale.axis];
            return !helpers_segment.isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
          }
          for (i = 0; i < ilen; ++i) {
            if (_skip()) {
              continue;
            }
            this.updateRangeFromParsed(range, scale, parsed, stack);
            if (sorted) {
              break;
            }
          }
          if (sorted) {
            for (i = ilen - 1; i >= 0; --i) {
              if (_skip()) {
                continue;
              }
              this.updateRangeFromParsed(range, scale, parsed, stack);
              break;
            }
          }
          return range;
        }
        getAllParsedValues(scale) {
          const parsed = this._cachedMeta._parsed;
          const values = [];
          let i, ilen, value;
          for (i = 0, ilen = parsed.length; i < ilen; ++i) {
            value = parsed[i][scale.axis];
            if (helpers_segment.isNumberFinite(value)) {
              values.push(value);
            }
          }
          return values;
        }
        getMaxOverflow() {
          return false;
        }
        getLabelAndValue(index2) {
          const meta = this._cachedMeta;
          const iScale = meta.iScale;
          const vScale = meta.vScale;
          const parsed = this.getParsed(index2);
          return {
            label: iScale ? "" + iScale.getLabelForValue(parsed[iScale.axis]) : "",
            value: vScale ? "" + vScale.getLabelForValue(parsed[vScale.axis]) : ""
          };
        }
        _update(mode) {
          const meta = this._cachedMeta;
          this.update(mode || "default");
          meta._clip = toClip(helpers_segment.valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
        }
        update(mode) {
        }
        draw() {
          const ctx = this._ctx;
          const chart = this.chart;
          const meta = this._cachedMeta;
          const elements2 = meta.data || [];
          const area = chart.chartArea;
          const active = [];
          const start = this._drawStart || 0;
          const count = this._drawCount || elements2.length - start;
          const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
          let i;
          if (meta.dataset) {
            meta.dataset.draw(ctx, area, start, count);
          }
          for (i = start; i < start + count; ++i) {
            const element = elements2[i];
            if (element.hidden) {
              continue;
            }
            if (element.active && drawActiveElementsOnTop) {
              active.push(element);
            } else {
              element.draw(ctx, area);
            }
          }
          for (i = 0; i < active.length; ++i) {
            active[i].draw(ctx, area);
          }
        }
        getStyle(index2, active) {
          const mode = active ? "active" : "default";
          return index2 === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index2 || 0, mode);
        }
        getContext(index2, active, mode) {
          const dataset = this.getDataset();
          let context;
          if (index2 >= 0 && index2 < this._cachedMeta.data.length) {
            const element = this._cachedMeta.data[index2];
            context = element.$context || (element.$context = createDataContext(this.getContext(), index2, element));
            context.parsed = this.getParsed(index2);
            context.raw = dataset.data[index2];
            context.index = context.dataIndex = index2;
          } else {
            context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
            context.dataset = dataset;
            context.index = context.datasetIndex = this.index;
          }
          context.active = !!active;
          context.mode = mode;
          return context;
        }
        resolveDatasetElementOptions(mode) {
          return this._resolveElementOptions(this.datasetElementType.id, mode);
        }
        resolveDataElementOptions(index2, mode) {
          return this._resolveElementOptions(this.dataElementType.id, mode, index2);
        }
        _resolveElementOptions(elementType, mode = "default", index2) {
          const active = mode === "active";
          const cache = this._cachedDataOpts;
          const cacheKey = elementType + "-" + mode;
          const cached = cache[cacheKey];
          const sharing = this.enableOptionSharing && helpers_segment.defined(index2);
          if (cached) {
            return cloneIfNotShared(cached, sharing);
          }
          const config = this.chart.config;
          const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
          const prefixes = active ? [
            `${elementType}Hover`,
            "hover",
            elementType,
            ""
          ] : [
            elementType,
            ""
          ];
          const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
          const names = Object.keys(helpers_segment.defaults.elements[elementType]);
          const context = () => this.getContext(index2, active, mode);
          const values = config.resolveNamedOptions(scopes, names, context, prefixes);
          if (values.$shared) {
            values.$shared = sharing;
            cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
          }
          return values;
        }
        _resolveAnimations(index2, transition, active) {
          const chart = this.chart;
          const cache = this._cachedDataOpts;
          const cacheKey = `animation-${transition}`;
          const cached = cache[cacheKey];
          if (cached) {
            return cached;
          }
          let options;
          if (chart.options.animation !== false) {
            const config = this.chart.config;
            const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
            const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
            options = config.createResolver(scopes, this.getContext(index2, active, transition));
          }
          const animations = new Animations(chart, options && options.animations);
          if (options && options._cacheable) {
            cache[cacheKey] = Object.freeze(animations);
          }
          return animations;
        }
        getSharedOptions(options) {
          if (!options.$shared) {
            return;
          }
          return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
        }
        includeOptions(mode, sharedOptions) {
          return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
        }
        _getSharedOptions(start, mode) {
          const firstOpts = this.resolveDataElementOptions(start, mode);
          const previouslySharedOptions = this._sharedOptions;
          const sharedOptions = this.getSharedOptions(firstOpts);
          const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;
          this.updateSharedOptions(sharedOptions, mode, firstOpts);
          return {
            sharedOptions,
            includeOptions
          };
        }
        updateElement(element, index2, properties, mode) {
          if (isDirectUpdateMode(mode)) {
            Object.assign(element, properties);
          } else {
            this._resolveAnimations(index2, mode).update(element, properties);
          }
        }
        updateSharedOptions(sharedOptions, mode, newOptions) {
          if (sharedOptions && !isDirectUpdateMode(mode)) {
            this._resolveAnimations(void 0, mode).update(sharedOptions, newOptions);
          }
        }
        _setStyle(element, index2, mode, active) {
          element.active = active;
          const options = this.getStyle(index2, active);
          this._resolveAnimations(index2, mode, active).update(element, {
            options: !active && this.getSharedOptions(options) || options
          });
        }
        removeHoverStyle(element, datasetIndex, index2) {
          this._setStyle(element, index2, "active", false);
        }
        setHoverStyle(element, datasetIndex, index2) {
          this._setStyle(element, index2, "active", true);
        }
        _removeDatasetHoverStyle() {
          const element = this._cachedMeta.dataset;
          if (element) {
            this._setStyle(element, void 0, "active", false);
          }
        }
        _setDatasetHoverStyle() {
          const element = this._cachedMeta.dataset;
          if (element) {
            this._setStyle(element, void 0, "active", true);
          }
        }
        _resyncElements(resetNewElements) {
          const data = this._data;
          const elements2 = this._cachedMeta.data;
          for (const [method, arg1, arg2] of this._syncList) {
            this[method](arg1, arg2);
          }
          this._syncList = [];
          const numMeta = elements2.length;
          const numData = data.length;
          const count = Math.min(numData, numMeta);
          if (count) {
            this.parse(0, count);
          }
          if (numData > numMeta) {
            this._insertElements(numMeta, numData - numMeta, resetNewElements);
          } else if (numData < numMeta) {
            this._removeElements(numData, numMeta - numData);
          }
        }
        _insertElements(start, count, resetNewElements = true) {
          const meta = this._cachedMeta;
          const data = meta.data;
          const end = start + count;
          let i;
          const move = (arr) => {
            arr.length += count;
            for (i = arr.length - 1; i >= end; i--) {
              arr[i] = arr[i - count];
            }
          };
          move(data);
          for (i = start; i < end; ++i) {
            data[i] = new this.dataElementType();
          }
          if (this._parsing) {
            move(meta._parsed);
          }
          this.parse(start, count);
          if (resetNewElements) {
            this.updateElements(data, start, count, "reset");
          }
        }
        updateElements(element, start, count, mode) {
        }
        _removeElements(start, count) {
          const meta = this._cachedMeta;
          if (this._parsing) {
            const removed = meta._parsed.splice(start, count);
            if (meta._stacked) {
              clearStacks(meta, removed);
            }
          }
          meta.data.splice(start, count);
        }
        _sync(args) {
          if (this._parsing) {
            this._syncList.push(args);
          } else {
            const [method, arg1, arg2] = args;
            this[method](arg1, arg2);
          }
          this.chart._dataChanges.push([
            this.index,
            ...args
          ]);
        }
        _onDataPush() {
          const count = arguments.length;
          this._sync([
            "_insertElements",
            this.getDataset().data.length - count,
            count
          ]);
        }
        _onDataPop() {
          this._sync([
            "_removeElements",
            this._cachedMeta.data.length - 1,
            1
          ]);
        }
        _onDataShift() {
          this._sync([
            "_removeElements",
            0,
            1
          ]);
        }
        _onDataSplice(start, count) {
          if (count) {
            this._sync([
              "_removeElements",
              start,
              count
            ]);
          }
          const newCount = arguments.length - 2;
          if (newCount) {
            this._sync([
              "_insertElements",
              start,
              newCount
            ]);
          }
        }
        _onDataUnshift() {
          this._sync([
            "_insertElements",
            0,
            arguments.length
          ]);
        }
      };
      __publicField(DatasetController, "defaults", {});
      __publicField(DatasetController, "datasetElementType", null);
      __publicField(DatasetController, "dataElementType", null);
      function getAllScaleValues(scale, type) {
        if (!scale._cache.$bar) {
          const visibleMetas = scale.getMatchingVisibleMetas(type);
          let values = [];
          for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {
            values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));
          }
          scale._cache.$bar = helpers_segment._arrayUnique(values.sort((a, b) => a - b));
        }
        return scale._cache.$bar;
      }
      function computeMinSampleSize(meta) {
        const scale = meta.iScale;
        const values = getAllScaleValues(scale, meta.type);
        let min = scale._length;
        let i, ilen, curr, prev;
        const updateMinAndPrev = () => {
          if (curr === 32767 || curr === -32768) {
            return;
          }
          if (helpers_segment.defined(prev)) {
            min = Math.min(min, Math.abs(curr - prev) || min);
          }
          prev = curr;
        };
        for (i = 0, ilen = values.length; i < ilen; ++i) {
          curr = scale.getPixelForValue(values[i]);
          updateMinAndPrev();
        }
        prev = void 0;
        for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {
          curr = scale.getPixelForTick(i);
          updateMinAndPrev();
        }
        return min;
      }
      function computeFitCategoryTraits(index2, ruler, options, stackCount) {
        const thickness = options.barThickness;
        let size, ratio;
        if (helpers_segment.isNullOrUndef(thickness)) {
          size = ruler.min * options.categoryPercentage;
          ratio = options.barPercentage;
        } else {
          size = thickness * stackCount;
          ratio = 1;
        }
        return {
          chunk: size / stackCount,
          ratio,
          start: ruler.pixels[index2] - size / 2
        };
      }
      function computeFlexCategoryTraits(index2, ruler, options, stackCount) {
        const pixels = ruler.pixels;
        const curr = pixels[index2];
        let prev = index2 > 0 ? pixels[index2 - 1] : null;
        let next = index2 < pixels.length - 1 ? pixels[index2 + 1] : null;
        const percent = options.categoryPercentage;
        if (prev === null) {
          prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
        }
        if (next === null) {
          next = curr + curr - prev;
        }
        const start = curr - (curr - Math.min(prev, next)) / 2 * percent;
        const size = Math.abs(next - prev) / 2 * percent;
        return {
          chunk: size / stackCount,
          ratio: options.barPercentage,
          start
        };
      }
      function parseFloatBar(entry, item, vScale, i) {
        const startValue = vScale.parse(entry[0], i);
        const endValue = vScale.parse(entry[1], i);
        const min = Math.min(startValue, endValue);
        const max = Math.max(startValue, endValue);
        let barStart = min;
        let barEnd = max;
        if (Math.abs(min) > Math.abs(max)) {
          barStart = max;
          barEnd = min;
        }
        item[vScale.axis] = barEnd;
        item._custom = {
          barStart,
          barEnd,
          start: startValue,
          end: endValue,
          min,
          max
        };
      }
      function parseValue(entry, item, vScale, i) {
        if (helpers_segment.isArray(entry)) {
          parseFloatBar(entry, item, vScale, i);
        } else {
          item[vScale.axis] = vScale.parse(entry, i);
        }
        return item;
      }
      function parseArrayOrPrimitive(meta, data, start, count) {
        const iScale = meta.iScale;
        const vScale = meta.vScale;
        const labels = iScale.getLabels();
        const singleScale = iScale === vScale;
        const parsed = [];
        let i, ilen, item, entry;
        for (i = start, ilen = start + count; i < ilen; ++i) {
          entry = data[i];
          item = {};
          item[iScale.axis] = singleScale || iScale.parse(labels[i], i);
          parsed.push(parseValue(entry, item, vScale, i));
        }
        return parsed;
      }
      function isFloatBar(custom) {
        return custom && custom.barStart !== void 0 && custom.barEnd !== void 0;
      }
      function barSign(size, vScale, actualBase) {
        if (size !== 0) {
          return helpers_segment.sign(size);
        }
        return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
      }
      function borderProps(properties) {
        let reverse, start, end, top, bottom;
        if (properties.horizontal) {
          reverse = properties.base > properties.x;
          start = "left";
          end = "right";
        } else {
          reverse = properties.base < properties.y;
          start = "bottom";
          end = "top";
        }
        if (reverse) {
          top = "end";
          bottom = "start";
        } else {
          top = "start";
          bottom = "end";
        }
        return {
          start,
          end,
          reverse,
          top,
          bottom
        };
      }
      function setBorderSkipped(properties, options, stack, index2) {
        let edge = options.borderSkipped;
        const res = {};
        if (!edge) {
          properties.borderSkipped = res;
          return;
        }
        if (edge === true) {
          properties.borderSkipped = {
            top: true,
            right: true,
            bottom: true,
            left: true
          };
          return;
        }
        const { start, end, reverse, top, bottom } = borderProps(properties);
        if (edge === "middle" && stack) {
          properties.enableBorderRadius = true;
          if ((stack._top || 0) === index2) {
            edge = top;
          } else if ((stack._bottom || 0) === index2) {
            edge = bottom;
          } else {
            res[parseEdge(bottom, start, end, reverse)] = true;
            edge = top;
          }
        }
        res[parseEdge(edge, start, end, reverse)] = true;
        properties.borderSkipped = res;
      }
      function parseEdge(edge, a, b, reverse) {
        if (reverse) {
          edge = swap(edge, a, b);
          edge = startEnd(edge, b, a);
        } else {
          edge = startEnd(edge, a, b);
        }
        return edge;
      }
      function swap(orig, v1, v2) {
        return orig === v1 ? v2 : orig === v2 ? v1 : orig;
      }
      function startEnd(v, start, end) {
        return v === "start" ? start : v === "end" ? end : v;
      }
      function setInflateAmount(properties, { inflateAmount }, ratio) {
        properties.inflateAmount = inflateAmount === "auto" ? ratio === 1 ? 0.33 : 0 : inflateAmount;
      }
      var BarController = class extends DatasetController {
        parsePrimitiveData(meta, data, start, count) {
          return parseArrayOrPrimitive(meta, data, start, count);
        }
        parseArrayData(meta, data, start, count) {
          return parseArrayOrPrimitive(meta, data, start, count);
        }
        parseObjectData(meta, data, start, count) {
          const { iScale, vScale } = meta;
          const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
          const iAxisKey = iScale.axis === "x" ? xAxisKey : yAxisKey;
          const vAxisKey = vScale.axis === "x" ? xAxisKey : yAxisKey;
          const parsed = [];
          let i, ilen, item, obj;
          for (i = start, ilen = start + count; i < ilen; ++i) {
            obj = data[i];
            item = {};
            item[iScale.axis] = iScale.parse(helpers_segment.resolveObjectKey(obj, iAxisKey), i);
            parsed.push(parseValue(helpers_segment.resolveObjectKey(obj, vAxisKey), item, vScale, i));
          }
          return parsed;
        }
        updateRangeFromParsed(range, scale, parsed, stack) {
          super.updateRangeFromParsed(range, scale, parsed, stack);
          const custom = parsed._custom;
          if (custom && scale === this._cachedMeta.vScale) {
            range.min = Math.min(range.min, custom.min);
            range.max = Math.max(range.max, custom.max);
          }
        }
        getMaxOverflow() {
          return 0;
        }
        getLabelAndValue(index2) {
          const meta = this._cachedMeta;
          const { iScale, vScale } = meta;
          const parsed = this.getParsed(index2);
          const custom = parsed._custom;
          const value = isFloatBar(custom) ? "[" + custom.start + ", " + custom.end + "]" : "" + vScale.getLabelForValue(parsed[vScale.axis]);
          return {
            label: "" + iScale.getLabelForValue(parsed[iScale.axis]),
            value
          };
        }
        initialize() {
          this.enableOptionSharing = true;
          super.initialize();
          const meta = this._cachedMeta;
          meta.stack = this.getDataset().stack;
        }
        update(mode) {
          const meta = this._cachedMeta;
          this.updateElements(meta.data, 0, meta.data.length, mode);
        }
        updateElements(bars, start, count, mode) {
          const reset = mode === "reset";
          const { index: index2, _cachedMeta: { vScale } } = this;
          const base = vScale.getBasePixel();
          const horizontal = vScale.isHorizontal();
          const ruler = this._getRuler();
          const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
          for (let i = start; i < start + count; i++) {
            const parsed = this.getParsed(i);
            const vpixels = reset || helpers_segment.isNullOrUndef(parsed[vScale.axis]) ? {
              base,
              head: base
            } : this._calculateBarValuePixels(i);
            const ipixels = this._calculateBarIndexPixels(i, ruler);
            const stack = (parsed._stacks || {})[vScale.axis];
            const properties = {
              horizontal,
              base: vpixels.base,
              enableBorderRadius: !stack || isFloatBar(parsed._custom) || index2 === stack._top || index2 === stack._bottom,
              x: horizontal ? vpixels.head : ipixels.center,
              y: horizontal ? ipixels.center : vpixels.head,
              height: horizontal ? ipixels.size : Math.abs(vpixels.size),
              width: horizontal ? Math.abs(vpixels.size) : ipixels.size
            };
            if (includeOptions) {
              properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? "active" : mode);
            }
            const options = properties.options || bars[i].options;
            setBorderSkipped(properties, options, stack, index2);
            setInflateAmount(properties, options, ruler.ratio);
            this.updateElement(bars[i], i, properties, mode);
          }
        }
        _getStacks(last, dataIndex) {
          const { iScale } = this._cachedMeta;
          const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta) => meta.controller.options.grouped);
          const stacked = iScale.options.stacked;
          const stacks = [];
          const skipNull = (meta) => {
            const parsed = meta.controller.getParsed(dataIndex);
            const val = parsed && parsed[meta.vScale.axis];
            if (helpers_segment.isNullOrUndef(val) || isNaN(val)) {
              return true;
            }
          };
          for (const meta of metasets) {
            if (dataIndex !== void 0 && skipNull(meta)) {
              continue;
            }
            if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === void 0 && meta.stack === void 0) {
              stacks.push(meta.stack);
            }
            if (meta.index === last) {
              break;
            }
          }
          if (!stacks.length) {
            stacks.push(void 0);
          }
          return stacks;
        }
        _getStackCount(index2) {
          return this._getStacks(void 0, index2).length;
        }
        _getStackIndex(datasetIndex, name, dataIndex) {
          const stacks = this._getStacks(datasetIndex, dataIndex);
          const index2 = name !== void 0 ? stacks.indexOf(name) : -1;
          return index2 === -1 ? stacks.length - 1 : index2;
        }
        _getRuler() {
          const opts = this.options;
          const meta = this._cachedMeta;
          const iScale = meta.iScale;
          const pixels = [];
          let i, ilen;
          for (i = 0, ilen = meta.data.length; i < ilen; ++i) {
            pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));
          }
          const barThickness = opts.barThickness;
          const min = barThickness || computeMinSampleSize(meta);
          return {
            min,
            pixels,
            start: iScale._startPixel,
            end: iScale._endPixel,
            stackCount: this._getStackCount(),
            scale: iScale,
            grouped: opts.grouped,
            ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
          };
        }
        _calculateBarValuePixels(index2) {
          const { _cachedMeta: { vScale, _stacked, index: datasetIndex }, options: { base: baseValue, minBarLength } } = this;
          const actualBase = baseValue || 0;
          const parsed = this.getParsed(index2);
          const custom = parsed._custom;
          const floating = isFloatBar(custom);
          let value = parsed[vScale.axis];
          let start = 0;
          let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
          let head, size;
          if (length !== value) {
            start = length - value;
            length = value;
          }
          if (floating) {
            value = custom.barStart;
            length = custom.barEnd - custom.barStart;
            if (value !== 0 && helpers_segment.sign(value) !== helpers_segment.sign(custom.barEnd)) {
              start = 0;
            }
            start += value;
          }
          const startValue = !helpers_segment.isNullOrUndef(baseValue) && !floating ? baseValue : start;
          let base = vScale.getPixelForValue(startValue);
          if (this.chart.getDataVisibility(index2)) {
            head = vScale.getPixelForValue(start + length);
          } else {
            head = base;
          }
          size = head - base;
          if (Math.abs(size) < minBarLength) {
            size = barSign(size, vScale, actualBase) * minBarLength;
            if (value === actualBase) {
              base -= size / 2;
            }
            const startPixel = vScale.getPixelForDecimal(0);
            const endPixel = vScale.getPixelForDecimal(1);
            const min = Math.min(startPixel, endPixel);
            const max = Math.max(startPixel, endPixel);
            base = Math.max(Math.min(base, max), min);
            head = base + size;
            if (_stacked && !floating) {
              parsed._stacks[vScale.axis]._visualValues[datasetIndex] = vScale.getValueForPixel(head) - vScale.getValueForPixel(base);
            }
          }
          if (base === vScale.getPixelForValue(actualBase)) {
            const halfGrid = helpers_segment.sign(size) * vScale.getLineWidthForValue(actualBase) / 2;
            base += halfGrid;
            size -= halfGrid;
          }
          return {
            size,
            base,
            head,
            center: head + size / 2
          };
        }
        _calculateBarIndexPixels(index2, ruler) {
          const scale = ruler.scale;
          const options = this.options;
          const skipNull = options.skipNull;
          const maxBarThickness = helpers_segment.valueOrDefault(options.maxBarThickness, Infinity);
          let center, size;
          if (ruler.grouped) {
            const stackCount = skipNull ? this._getStackCount(index2) : ruler.stackCount;
            const range = options.barThickness === "flex" ? computeFlexCategoryTraits(index2, ruler, options, stackCount) : computeFitCategoryTraits(index2, ruler, options, stackCount);
            const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index2 : void 0);
            center = range.start + range.chunk * stackIndex + range.chunk / 2;
            size = Math.min(maxBarThickness, range.chunk * range.ratio);
          } else {
            center = scale.getPixelForValue(this.getParsed(index2)[scale.axis], index2);
            size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
          }
          return {
            base: center - size / 2,
            head: center + size / 2,
            center,
            size
          };
        }
        draw() {
          const meta = this._cachedMeta;
          const vScale = meta.vScale;
          const rects = meta.data;
          const ilen = rects.length;
          let i = 0;
          for (; i < ilen; ++i) {
            if (this.getParsed(i)[vScale.axis] !== null) {
              rects[i].draw(this._ctx);
            }
          }
        }
      };
      __publicField(BarController, "id", "bar");
      __publicField(BarController, "defaults", {
        datasetElementType: false,
        dataElementType: "bar",
        categoryPercentage: 0.8,
        barPercentage: 0.9,
        grouped: true,
        animations: {
          numbers: {
            type: "number",
            properties: [
              "x",
              "y",
              "base",
              "width",
              "height"
            ]
          }
        }
      });
      __publicField(BarController, "overrides", {
        scales: {
          _index_: {
            type: "category",
            offset: true,
            grid: {
              offset: true
            }
          },
          _value_: {
            type: "linear",
            beginAtZero: true
          }
        }
      });
      var BubbleController = class extends DatasetController {
        initialize() {
          this.enableOptionSharing = true;
          super.initialize();
        }
        parsePrimitiveData(meta, data, start, count) {
          const parsed = super.parsePrimitiveData(meta, data, start, count);
          for (let i = 0; i < parsed.length; i++) {
            parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;
          }
          return parsed;
        }
        parseArrayData(meta, data, start, count) {
          const parsed = super.parseArrayData(meta, data, start, count);
          for (let i = 0; i < parsed.length; i++) {
            const item = data[start + i];
            parsed[i]._custom = helpers_segment.valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);
          }
          return parsed;
        }
        parseObjectData(meta, data, start, count) {
          const parsed = super.parseObjectData(meta, data, start, count);
          for (let i = 0; i < parsed.length; i++) {
            const item = data[start + i];
            parsed[i]._custom = helpers_segment.valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);
          }
          return parsed;
        }
        getMaxOverflow() {
          const data = this._cachedMeta.data;
          let max = 0;
          for (let i = data.length - 1; i >= 0; --i) {
            max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
          }
          return max > 0 && max;
        }
        getLabelAndValue(index2) {
          const meta = this._cachedMeta;
          const labels = this.chart.data.labels || [];
          const { xScale, yScale } = meta;
          const parsed = this.getParsed(index2);
          const x = xScale.getLabelForValue(parsed.x);
          const y = yScale.getLabelForValue(parsed.y);
          const r = parsed._custom;
          return {
            label: labels[index2] || "",
            value: "(" + x + ", " + y + (r ? ", " + r : "") + ")"
          };
        }
        update(mode) {
          const points = this._cachedMeta.data;
          this.updateElements(points, 0, points.length, mode);
        }
        updateElements(points, start, count, mode) {
          const reset = mode === "reset";
          const { iScale, vScale } = this._cachedMeta;
          const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
          const iAxis = iScale.axis;
          const vAxis = vScale.axis;
          for (let i = start; i < start + count; i++) {
            const point = points[i];
            const parsed = !reset && this.getParsed(i);
            const properties = {};
            const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);
            const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
            properties.skip = isNaN(iPixel) || isNaN(vPixel);
            if (includeOptions) {
              properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
              if (reset) {
                properties.options.radius = 0;
              }
            }
            this.updateElement(point, i, properties, mode);
          }
        }
        resolveDataElementOptions(index2, mode) {
          const parsed = this.getParsed(index2);
          let values = super.resolveDataElementOptions(index2, mode);
          if (values.$shared) {
            values = Object.assign({}, values, {
              $shared: false
            });
          }
          const radius = values.radius;
          if (mode !== "active") {
            values.radius = 0;
          }
          values.radius += helpers_segment.valueOrDefault(parsed && parsed._custom, radius);
          return values;
        }
      };
      __publicField(BubbleController, "id", "bubble");
      __publicField(BubbleController, "defaults", {
        datasetElementType: false,
        dataElementType: "point",
        animations: {
          numbers: {
            type: "number",
            properties: [
              "x",
              "y",
              "borderWidth",
              "radius"
            ]
          }
        }
      });
      __publicField(BubbleController, "overrides", {
        scales: {
          x: {
            type: "linear"
          },
          y: {
            type: "linear"
          }
        }
      });
      function getRatioAndOffset(rotation, circumference, cutout) {
        let ratioX = 1;
        let ratioY = 1;
        let offsetX = 0;
        let offsetY = 0;
        if (circumference < helpers_segment.TAU) {
          const startAngle = rotation;
          const endAngle = startAngle + circumference;
          const startX = Math.cos(startAngle);
          const startY = Math.sin(startAngle);
          const endX = Math.cos(endAngle);
          const endY = Math.sin(endAngle);
          const calcMax = (angle, a, b) => helpers_segment._angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);
          const calcMin = (angle, a, b) => helpers_segment._angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);
          const maxX = calcMax(0, startX, endX);
          const maxY = calcMax(helpers_segment.HALF_PI, startY, endY);
          const minX = calcMin(helpers_segment.PI, startX, endX);
          const minY = calcMin(helpers_segment.PI + helpers_segment.HALF_PI, startY, endY);
          ratioX = (maxX - minX) / 2;
          ratioY = (maxY - minY) / 2;
          offsetX = -(maxX + minX) / 2;
          offsetY = -(maxY + minY) / 2;
        }
        return {
          ratioX,
          ratioY,
          offsetX,
          offsetY
        };
      }
      var DoughnutController = class extends DatasetController {
        constructor(chart, datasetIndex) {
          super(chart, datasetIndex);
          this.enableOptionSharing = true;
          this.innerRadius = void 0;
          this.outerRadius = void 0;
          this.offsetX = void 0;
          this.offsetY = void 0;
        }
        linkScales() {
        }
        parse(start, count) {
          const data = this.getDataset().data;
          const meta = this._cachedMeta;
          if (this._parsing === false) {
            meta._parsed = data;
          } else {
            let getter = (i2) => +data[i2];
            if (helpers_segment.isObject(data[start])) {
              const { key = "value" } = this._parsing;
              getter = (i2) => +helpers_segment.resolveObjectKey(data[i2], key);
            }
            let i, ilen;
            for (i = start, ilen = start + count; i < ilen; ++i) {
              meta._parsed[i] = getter(i);
            }
          }
        }
        _getRotation() {
          return helpers_segment.toRadians(this.options.rotation - 90);
        }
        _getCircumference() {
          return helpers_segment.toRadians(this.options.circumference);
        }
        _getRotationExtents() {
          let min = helpers_segment.TAU;
          let max = -helpers_segment.TAU;
          for (let i = 0; i < this.chart.data.datasets.length; ++i) {
            if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {
              const controller = this.chart.getDatasetMeta(i).controller;
              const rotation = controller._getRotation();
              const circumference = controller._getCircumference();
              min = Math.min(min, rotation);
              max = Math.max(max, rotation + circumference);
            }
          }
          return {
            rotation: min,
            circumference: max - min
          };
        }
        update(mode) {
          const chart = this.chart;
          const { chartArea } = chart;
          const meta = this._cachedMeta;
          const arcs = meta.data;
          const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
          const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
          const cutout = Math.min(helpers_segment.toPercentage(this.options.cutout, maxSize), 1);
          const chartWeight = this._getRingWeight(this.index);
          const { circumference, rotation } = this._getRotationExtents();
          const { ratioX, ratioY, offsetX, offsetY } = getRatioAndOffset(rotation, circumference, cutout);
          const maxWidth = (chartArea.width - spacing) / ratioX;
          const maxHeight = (chartArea.height - spacing) / ratioY;
          const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
          const outerRadius = helpers_segment.toDimension(this.options.radius, maxRadius);
          const innerRadius = Math.max(outerRadius * cutout, 0);
          const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
          this.offsetX = offsetX * outerRadius;
          this.offsetY = offsetY * outerRadius;
          meta.total = this.calculateTotal();
          this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
          this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
          this.updateElements(arcs, 0, arcs.length, mode);
        }
        _circumference(i, reset) {
          const opts = this.options;
          const meta = this._cachedMeta;
          const circumference = this._getCircumference();
          if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {
            return 0;
          }
          return this.calculateCircumference(meta._parsed[i] * circumference / helpers_segment.TAU);
        }
        updateElements(arcs, start, count, mode) {
          const reset = mode === "reset";
          const chart = this.chart;
          const chartArea = chart.chartArea;
          const opts = chart.options;
          const animationOpts = opts.animation;
          const centerX = (chartArea.left + chartArea.right) / 2;
          const centerY = (chartArea.top + chartArea.bottom) / 2;
          const animateScale = reset && animationOpts.animateScale;
          const innerRadius = animateScale ? 0 : this.innerRadius;
          const outerRadius = animateScale ? 0 : this.outerRadius;
          const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
          let startAngle = this._getRotation();
          let i;
          for (i = 0; i < start; ++i) {
            startAngle += this._circumference(i, reset);
          }
          for (i = start; i < start + count; ++i) {
            const circumference = this._circumference(i, reset);
            const arc = arcs[i];
            const properties = {
              x: centerX + this.offsetX,
              y: centerY + this.offsetY,
              startAngle,
              endAngle: startAngle + circumference,
              circumference,
              outerRadius,
              innerRadius
            };
            if (includeOptions) {
              properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? "active" : mode);
            }
            startAngle += circumference;
            this.updateElement(arc, i, properties, mode);
          }
        }
        calculateTotal() {
          const meta = this._cachedMeta;
          const metaData = meta.data;
          let total = 0;
          let i;
          for (i = 0; i < metaData.length; i++) {
            const value = meta._parsed[i];
            if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {
              total += Math.abs(value);
            }
          }
          return total;
        }
        calculateCircumference(value) {
          const total = this._cachedMeta.total;
          if (total > 0 && !isNaN(value)) {
            return helpers_segment.TAU * (Math.abs(value) / total);
          }
          return 0;
        }
        getLabelAndValue(index2) {
          const meta = this._cachedMeta;
          const chart = this.chart;
          const labels = chart.data.labels || [];
          const value = helpers_segment.formatNumber(meta._parsed[index2], chart.options.locale);
          return {
            label: labels[index2] || "",
            value
          };
        }
        getMaxBorderWidth(arcs) {
          let max = 0;
          const chart = this.chart;
          let i, ilen, meta, controller, options;
          if (!arcs) {
            for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
              if (chart.isDatasetVisible(i)) {
                meta = chart.getDatasetMeta(i);
                arcs = meta.data;
                controller = meta.controller;
                break;
              }
            }
          }
          if (!arcs) {
            return 0;
          }
          for (i = 0, ilen = arcs.length; i < ilen; ++i) {
            options = controller.resolveDataElementOptions(i);
            if (options.borderAlign !== "inner") {
              max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);
            }
          }
          return max;
        }
        getMaxOffset(arcs) {
          let max = 0;
          for (let i = 0, ilen = arcs.length; i < ilen; ++i) {
            const options = this.resolveDataElementOptions(i);
            max = Math.max(max, options.offset || 0, options.hoverOffset || 0);
          }
          return max;
        }
        _getRingWeightOffset(datasetIndex) {
          let ringWeightOffset = 0;
          for (let i = 0; i < datasetIndex; ++i) {
            if (this.chart.isDatasetVisible(i)) {
              ringWeightOffset += this._getRingWeight(i);
            }
          }
          return ringWeightOffset;
        }
        _getRingWeight(datasetIndex) {
          return Math.max(helpers_segment.valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
        }
        _getVisibleDatasetWeightTotal() {
          return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
        }
      };
      __publicField(DoughnutController, "id", "doughnut");
      __publicField(DoughnutController, "defaults", {
        datasetElementType: false,
        dataElementType: "arc",
        animation: {
          animateRotate: true,
          animateScale: false
        },
        animations: {
          numbers: {
            type: "number",
            properties: [
              "circumference",
              "endAngle",
              "innerRadius",
              "outerRadius",
              "startAngle",
              "x",
              "y",
              "offset",
              "borderWidth",
              "spacing"
            ]
          }
        },
        cutout: "50%",
        rotation: 0,
        circumference: 360,
        radius: "100%",
        spacing: 0,
        indexAxis: "r"
      });
      __publicField(DoughnutController, "descriptors", {
        _scriptable: (name) => name !== "spacing",
        _indexable: (name) => name !== "spacing" && !name.startsWith("borderDash") && !name.startsWith("hoverBorderDash")
      });
      __publicField(DoughnutController, "overrides", {
        aspectRatio: 1,
        plugins: {
          legend: {
            labels: {
              generateLabels(chart) {
                const data = chart.data;
                if (data.labels.length && data.datasets.length) {
                  const { labels: { pointStyle, color } } = chart.legend.options;
                  return data.labels.map((label, i) => {
                    const meta = chart.getDatasetMeta(0);
                    const style = meta.controller.getStyle(i);
                    return {
                      text: label,
                      fillStyle: style.backgroundColor,
                      strokeStyle: style.borderColor,
                      fontColor: color,
                      lineWidth: style.borderWidth,
                      pointStyle,
                      hidden: !chart.getDataVisibility(i),
                      index: i
                    };
                  });
                }
                return [];
              }
            },
            onClick(e, legendItem, legend) {
              legend.chart.toggleDataVisibility(legendItem.index);
              legend.chart.update();
            }
          }
        }
      });
      var LineController = class extends DatasetController {
        initialize() {
          this.enableOptionSharing = true;
          this.supportsDecimation = true;
          super.initialize();
        }
        update(mode) {
          const meta = this._cachedMeta;
          const { dataset: line, data: points = [], _dataset } = meta;
          const animationsDisabled = this.chart._animationsDisabled;
          let { start, count } = helpers_segment._getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
          this._drawStart = start;
          this._drawCount = count;
          if (helpers_segment._scaleRangesChanged(meta)) {
            start = 0;
            count = points.length;
          }
          line._chart = this.chart;
          line._datasetIndex = this.index;
          line._decimated = !!_dataset._decimated;
          line.points = points;
          const options = this.resolveDatasetElementOptions(mode);
          if (!this.options.showLine) {
            options.borderWidth = 0;
          }
          options.segment = this.options.segment;
          this.updateElement(line, void 0, {
            animated: !animationsDisabled,
            options
          }, mode);
          this.updateElements(points, start, count, mode);
        }
        updateElements(points, start, count, mode) {
          const reset = mode === "reset";
          const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
          const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
          const iAxis = iScale.axis;
          const vAxis = vScale.axis;
          const { spanGaps, segment } = this.options;
          const maxGapLength = helpers_segment.isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
          const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
          const end = start + count;
          const pointsCount = points.length;
          let prevParsed = start > 0 && this.getParsed(start - 1);
          for (let i = 0; i < pointsCount; ++i) {
            const point = points[i];
            const properties = directUpdate ? point : {};
            if (i < start || i >= end) {
              properties.skip = true;
              continue;
            }
            const parsed = this.getParsed(i);
            const nullData = helpers_segment.isNullOrUndef(parsed[vAxis]);
            const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
            const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
            properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
            properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
            if (segment) {
              properties.parsed = parsed;
              properties.raw = _dataset.data[i];
            }
            if (includeOptions) {
              properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
            }
            if (!directUpdate) {
              this.updateElement(point, i, properties, mode);
            }
            prevParsed = parsed;
          }
        }
        getMaxOverflow() {
          const meta = this._cachedMeta;
          const dataset = meta.dataset;
          const border = dataset.options && dataset.options.borderWidth || 0;
          const data = meta.data || [];
          if (!data.length) {
            return border;
          }
          const firstPoint = data[0].size(this.resolveDataElementOptions(0));
          const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
          return Math.max(border, firstPoint, lastPoint) / 2;
        }
        draw() {
          const meta = this._cachedMeta;
          meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
          super.draw();
        }
      };
      __publicField(LineController, "id", "line");
      __publicField(LineController, "defaults", {
        datasetElementType: "line",
        dataElementType: "point",
        showLine: true,
        spanGaps: false
      });
      __publicField(LineController, "overrides", {
        scales: {
          _index_: {
            type: "category"
          },
          _value_: {
            type: "linear"
          }
        }
      });
      var PolarAreaController = class extends DatasetController {
        constructor(chart, datasetIndex) {
          super(chart, datasetIndex);
          this.innerRadius = void 0;
          this.outerRadius = void 0;
        }
        getLabelAndValue(index2) {
          const meta = this._cachedMeta;
          const chart = this.chart;
          const labels = chart.data.labels || [];
          const value = helpers_segment.formatNumber(meta._parsed[index2].r, chart.options.locale);
          return {
            label: labels[index2] || "",
            value
          };
        }
        parseObjectData(meta, data, start, count) {
          return helpers_segment._parseObjectDataRadialScale.bind(this)(meta, data, start, count);
        }
        update(mode) {
          const arcs = this._cachedMeta.data;
          this._updateRadius();
          this.updateElements(arcs, 0, arcs.length, mode);
        }
        getMinMax() {
          const meta = this._cachedMeta;
          const range = {
            min: Number.POSITIVE_INFINITY,
            max: Number.NEGATIVE_INFINITY
          };
          meta.data.forEach((element, index2) => {
            const parsed = this.getParsed(index2).r;
            if (!isNaN(parsed) && this.chart.getDataVisibility(index2)) {
              if (parsed < range.min) {
                range.min = parsed;
              }
              if (parsed > range.max) {
                range.max = parsed;
              }
            }
          });
          return range;
        }
        _updateRadius() {
          const chart = this.chart;
          const chartArea = chart.chartArea;
          const opts = chart.options;
          const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
          const outerRadius = Math.max(minSize / 2, 0);
          const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);
          const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();
          this.outerRadius = outerRadius - radiusLength * this.index;
          this.innerRadius = this.outerRadius - radiusLength;
        }
        updateElements(arcs, start, count, mode) {
          const reset = mode === "reset";
          const chart = this.chart;
          const opts = chart.options;
          const animationOpts = opts.animation;
          const scale = this._cachedMeta.rScale;
          const centerX = scale.xCenter;
          const centerY = scale.yCenter;
          const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * helpers_segment.PI;
          let angle = datasetStartAngle;
          let i;
          const defaultAngle = 360 / this.countVisibleElements();
          for (i = 0; i < start; ++i) {
            angle += this._computeAngle(i, mode, defaultAngle);
          }
          for (i = start; i < start + count; i++) {
            const arc = arcs[i];
            let startAngle = angle;
            let endAngle = angle + this._computeAngle(i, mode, defaultAngle);
            let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;
            angle = endAngle;
            if (reset) {
              if (animationOpts.animateScale) {
                outerRadius = 0;
              }
              if (animationOpts.animateRotate) {
                startAngle = endAngle = datasetStartAngle;
              }
            }
            const properties = {
              x: centerX,
              y: centerY,
              innerRadius: 0,
              outerRadius,
              startAngle,
              endAngle,
              options: this.resolveDataElementOptions(i, arc.active ? "active" : mode)
            };
            this.updateElement(arc, i, properties, mode);
          }
        }
        countVisibleElements() {
          const meta = this._cachedMeta;
          let count = 0;
          meta.data.forEach((element, index2) => {
            if (!isNaN(this.getParsed(index2).r) && this.chart.getDataVisibility(index2)) {
              count++;
            }
          });
          return count;
        }
        _computeAngle(index2, mode, defaultAngle) {
          return this.chart.getDataVisibility(index2) ? helpers_segment.toRadians(this.resolveDataElementOptions(index2, mode).angle || defaultAngle) : 0;
        }
      };
      __publicField(PolarAreaController, "id", "polarArea");
      __publicField(PolarAreaController, "defaults", {
        dataElementType: "arc",
        animation: {
          animateRotate: true,
          animateScale: true
        },
        animations: {
          numbers: {
            type: "number",
            properties: [
              "x",
              "y",
              "startAngle",
              "endAngle",
              "innerRadius",
              "outerRadius"
            ]
          }
        },
        indexAxis: "r",
        startAngle: 0
      });
      __publicField(PolarAreaController, "overrides", {
        aspectRatio: 1,
        plugins: {
          legend: {
            labels: {
              generateLabels(chart) {
                const data = chart.data;
                if (data.labels.length && data.datasets.length) {
                  const { labels: { pointStyle, color } } = chart.legend.options;
                  return data.labels.map((label, i) => {
                    const meta = chart.getDatasetMeta(0);
                    const style = meta.controller.getStyle(i);
                    return {
                      text: label,
                      fillStyle: style.backgroundColor,
                      strokeStyle: style.borderColor,
                      fontColor: color,
                      lineWidth: style.borderWidth,
                      pointStyle,
                      hidden: !chart.getDataVisibility(i),
                      index: i
                    };
                  });
                }
                return [];
              }
            },
            onClick(e, legendItem, legend) {
              legend.chart.toggleDataVisibility(legendItem.index);
              legend.chart.update();
            }
          }
        },
        scales: {
          r: {
            type: "radialLinear",
            angleLines: {
              display: false
            },
            beginAtZero: true,
            grid: {
              circular: true
            },
            pointLabels: {
              display: false
            },
            startAngle: 0
          }
        }
      });
      var PieController = class extends DoughnutController {
      };
      __publicField(PieController, "id", "pie");
      __publicField(PieController, "defaults", {
        cutout: 0,
        rotation: 0,
        circumference: 360,
        radius: "100%"
      });
      var RadarController = class extends DatasetController {
        getLabelAndValue(index2) {
          const vScale = this._cachedMeta.vScale;
          const parsed = this.getParsed(index2);
          return {
            label: vScale.getLabels()[index2],
            value: "" + vScale.getLabelForValue(parsed[vScale.axis])
          };
        }
        parseObjectData(meta, data, start, count) {
          return helpers_segment._parseObjectDataRadialScale.bind(this)(meta, data, start, count);
        }
        update(mode) {
          const meta = this._cachedMeta;
          const line = meta.dataset;
          const points = meta.data || [];
          const labels = meta.iScale.getLabels();
          line.points = points;
          if (mode !== "resize") {
            const options = this.resolveDatasetElementOptions(mode);
            if (!this.options.showLine) {
              options.borderWidth = 0;
            }
            const properties = {
              _loop: true,
              _fullLoop: labels.length === points.length,
              options
            };
            this.updateElement(line, void 0, properties, mode);
          }
          this.updateElements(points, 0, points.length, mode);
        }
        updateElements(points, start, count, mode) {
          const scale = this._cachedMeta.rScale;
          const reset = mode === "reset";
          for (let i = start; i < start + count; i++) {
            const point = points[i];
            const options = this.resolveDataElementOptions(i, point.active ? "active" : mode);
            const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);
            const x = reset ? scale.xCenter : pointPosition.x;
            const y = reset ? scale.yCenter : pointPosition.y;
            const properties = {
              x,
              y,
              angle: pointPosition.angle,
              skip: isNaN(x) || isNaN(y),
              options
            };
            this.updateElement(point, i, properties, mode);
          }
        }
      };
      __publicField(RadarController, "id", "radar");
      __publicField(RadarController, "defaults", {
        datasetElementType: "line",
        dataElementType: "point",
        indexAxis: "r",
        showLine: true,
        elements: {
          line: {
            fill: "start"
          }
        }
      });
      __publicField(RadarController, "overrides", {
        aspectRatio: 1,
        scales: {
          r: {
            type: "radialLinear"
          }
        }
      });
      var ScatterController = class extends DatasetController {
        getLabelAndValue(index2) {
          const meta = this._cachedMeta;
          const labels = this.chart.data.labels || [];
          const { xScale, yScale } = meta;
          const parsed = this.getParsed(index2);
          const x = xScale.getLabelForValue(parsed.x);
          const y = yScale.getLabelForValue(parsed.y);
          return {
            label: labels[index2] || "",
            value: "(" + x + ", " + y + ")"
          };
        }
        update(mode) {
          const meta = this._cachedMeta;
          const { data: points = [] } = meta;
          const animationsDisabled = this.chart._animationsDisabled;
          let { start, count } = helpers_segment._getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
          this._drawStart = start;
          this._drawCount = count;
          if (helpers_segment._scaleRangesChanged(meta)) {
            start = 0;
            count = points.length;
          }
          if (this.options.showLine) {
            const { dataset: line, _dataset } = meta;
            line._chart = this.chart;
            line._datasetIndex = this.index;
            line._decimated = !!_dataset._decimated;
            line.points = points;
            const options = this.resolveDatasetElementOptions(mode);
            options.segment = this.options.segment;
            this.updateElement(line, void 0, {
              animated: !animationsDisabled,
              options
            }, mode);
          }
          this.updateElements(points, start, count, mode);
        }
        addElements() {
          const { showLine } = this.options;
          if (!this.datasetElementType && showLine) {
            this.datasetElementType = this.chart.registry.getElement("line");
          }
          super.addElements();
        }
        updateElements(points, start, count, mode) {
          const reset = mode === "reset";
          const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
          const firstOpts = this.resolveDataElementOptions(start, mode);
          const sharedOptions = this.getSharedOptions(firstOpts);
          const includeOptions = this.includeOptions(mode, sharedOptions);
          const iAxis = iScale.axis;
          const vAxis = vScale.axis;
          const { spanGaps, segment } = this.options;
          const maxGapLength = helpers_segment.isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
          const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
          let prevParsed = start > 0 && this.getParsed(start - 1);
          for (let i = start; i < start + count; ++i) {
            const point = points[i];
            const parsed = this.getParsed(i);
            const properties = directUpdate ? point : {};
            const nullData = helpers_segment.isNullOrUndef(parsed[vAxis]);
            const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
            const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
            properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
            properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
            if (segment) {
              properties.parsed = parsed;
              properties.raw = _dataset.data[i];
            }
            if (includeOptions) {
              properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
            }
            if (!directUpdate) {
              this.updateElement(point, i, properties, mode);
            }
            prevParsed = parsed;
          }
          this.updateSharedOptions(sharedOptions, mode, firstOpts);
        }
        getMaxOverflow() {
          const meta = this._cachedMeta;
          const data = meta.data || [];
          if (!this.options.showLine) {
            let max = 0;
            for (let i = data.length - 1; i >= 0; --i) {
              max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
            }
            return max > 0 && max;
          }
          const dataset = meta.dataset;
          const border = dataset.options && dataset.options.borderWidth || 0;
          if (!data.length) {
            return border;
          }
          const firstPoint = data[0].size(this.resolveDataElementOptions(0));
          const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
          return Math.max(border, firstPoint, lastPoint) / 2;
        }
      };
      __publicField(ScatterController, "id", "scatter");
      __publicField(ScatterController, "defaults", {
        datasetElementType: false,
        dataElementType: "point",
        showLine: false,
        fill: false
      });
      __publicField(ScatterController, "overrides", {
        interaction: {
          mode: "point"
        },
        scales: {
          x: {
            type: "linear"
          },
          y: {
            type: "linear"
          }
        }
      });
      var controllers = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        BarController,
        BubbleController,
        DoughnutController,
        LineController,
        PieController,
        PolarAreaController,
        RadarController,
        ScatterController
      });
      function abstract() {
        throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
      }
      var DateAdapterBase = class {
        /**
        * Override default date adapter methods.
        * Accepts type parameter to define options type.
        * @example
        * Chart._adapters._date.override<{myAdapterOption: string}>({
        *   init() {
        *     console.log(this.options.myAdapterOption);
        *   }
        * })
        */
        static override(members) {
          Object.assign(DateAdapterBase.prototype, members);
        }
        options;
        constructor(options) {
          this.options = options || {};
        }
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        init() {
        }
        formats() {
          return abstract();
        }
        parse() {
          return abstract();
        }
        format() {
          return abstract();
        }
        add() {
          return abstract();
        }
        diff() {
          return abstract();
        }
        startOf() {
          return abstract();
        }
        endOf() {
          return abstract();
        }
      };
      var adapters = {
        _date: DateAdapterBase
      };
      function binarySearch(metaset, axis, value, intersect) {
        const { controller, data, _sorted } = metaset;
        const iScale = controller._cachedMeta.iScale;
        if (iScale && axis === iScale.axis && axis !== "r" && _sorted && data.length) {
          const lookupMethod = iScale._reversePixels ? helpers_segment._rlookupByKey : helpers_segment._lookupByKey;
          if (!intersect) {
            return lookupMethod(data, axis, value);
          } else if (controller._sharedOptions) {
            const el = data[0];
            const range = typeof el.getRange === "function" && el.getRange(axis);
            if (range) {
              const start = lookupMethod(data, axis, value - range);
              const end = lookupMethod(data, axis, value + range);
              return {
                lo: start.lo,
                hi: end.hi
              };
            }
          }
        }
        return {
          lo: 0,
          hi: data.length - 1
        };
      }
      function evaluateInteractionItems(chart, axis, position, handler, intersect) {
        const metasets = chart.getSortedVisibleDatasetMetas();
        const value = position[axis];
        for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
          const { index: index2, data } = metasets[i];
          const { lo, hi } = binarySearch(metasets[i], axis, value, intersect);
          for (let j = lo; j <= hi; ++j) {
            const element = data[j];
            if (!element.skip) {
              handler(element, index2, j);
            }
          }
        }
      }
      function getDistanceMetricForAxis(axis) {
        const useX = axis.indexOf("x") !== -1;
        const useY = axis.indexOf("y") !== -1;
        return function(pt1, pt2) {
          const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
          const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
          return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
        };
      }
      function getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {
        const items = [];
        if (!includeInvisible && !chart.isPointInArea(position)) {
          return items;
        }
        const evaluationFunc = function(element, datasetIndex, index2) {
          if (!includeInvisible && !helpers_segment._isPointInArea(element, chart.chartArea, 0)) {
            return;
          }
          if (element.inRange(position.x, position.y, useFinalPosition)) {
            items.push({
              element,
              datasetIndex,
              index: index2
            });
          }
        };
        evaluateInteractionItems(chart, axis, position, evaluationFunc, true);
        return items;
      }
      function getNearestRadialItems(chart, position, axis, useFinalPosition) {
        let items = [];
        function evaluationFunc(element, datasetIndex, index2) {
          const { startAngle, endAngle } = element.getProps([
            "startAngle",
            "endAngle"
          ], useFinalPosition);
          const { angle } = helpers_segment.getAngleFromPoint(element, {
            x: position.x,
            y: position.y
          });
          if (helpers_segment._angleBetween(angle, startAngle, endAngle)) {
            items.push({
              element,
              datasetIndex,
              index: index2
            });
          }
        }
        evaluateInteractionItems(chart, axis, position, evaluationFunc);
        return items;
      }
      function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
        let items = [];
        const distanceMetric = getDistanceMetricForAxis(axis);
        let minDistance = Number.POSITIVE_INFINITY;
        function evaluationFunc(element, datasetIndex, index2) {
          const inRange2 = element.inRange(position.x, position.y, useFinalPosition);
          if (intersect && !inRange2) {
            return;
          }
          const center = element.getCenterPoint(useFinalPosition);
          const pointInArea = !!includeInvisible || chart.isPointInArea(center);
          if (!pointInArea && !inRange2) {
            return;
          }
          const distance = distanceMetric(position, center);
          if (distance < minDistance) {
            items = [
              {
                element,
                datasetIndex,
                index: index2
              }
            ];
            minDistance = distance;
          } else if (distance === minDistance) {
            items.push({
              element,
              datasetIndex,
              index: index2
            });
          }
        }
        evaluateInteractionItems(chart, axis, position, evaluationFunc);
        return items;
      }
      function getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
        if (!includeInvisible && !chart.isPointInArea(position)) {
          return [];
        }
        return axis === "r" && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);
      }
      function getAxisItems(chart, position, axis, intersect, useFinalPosition) {
        const items = [];
        const rangeMethod = axis === "x" ? "inXRange" : "inYRange";
        let intersectsItem = false;
        evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index2) => {
          if (element[rangeMethod](position[axis], useFinalPosition)) {
            items.push({
              element,
              datasetIndex,
              index: index2
            });
            intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);
          }
        });
        if (intersect && !intersectsItem) {
          return [];
        }
        return items;
      }
      var Interaction = {
        evaluateInteractionItems,
        modes: {
          index(chart, e, options, useFinalPosition) {
            const position = helpers_segment.getRelativePosition(e, chart);
            const axis = options.axis || "x";
            const includeInvisible = options.includeInvisible || false;
            const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
            const elements2 = [];
            if (!items.length) {
              return [];
            }
            chart.getSortedVisibleDatasetMetas().forEach((meta) => {
              const index2 = items[0].index;
              const element = meta.data[index2];
              if (element && !element.skip) {
                elements2.push({
                  element,
                  datasetIndex: meta.index,
                  index: index2
                });
              }
            });
            return elements2;
          },
          dataset(chart, e, options, useFinalPosition) {
            const position = helpers_segment.getRelativePosition(e, chart);
            const axis = options.axis || "xy";
            const includeInvisible = options.includeInvisible || false;
            let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
            if (items.length > 0) {
              const datasetIndex = items[0].datasetIndex;
              const data = chart.getDatasetMeta(datasetIndex).data;
              items = [];
              for (let i = 0; i < data.length; ++i) {
                items.push({
                  element: data[i],
                  datasetIndex,
                  index: i
                });
              }
            }
            return items;
          },
          point(chart, e, options, useFinalPosition) {
            const position = helpers_segment.getRelativePosition(e, chart);
            const axis = options.axis || "xy";
            const includeInvisible = options.includeInvisible || false;
            return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);
          },
          nearest(chart, e, options, useFinalPosition) {
            const position = helpers_segment.getRelativePosition(e, chart);
            const axis = options.axis || "xy";
            const includeInvisible = options.includeInvisible || false;
            return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);
          },
          x(chart, e, options, useFinalPosition) {
            const position = helpers_segment.getRelativePosition(e, chart);
            return getAxisItems(chart, position, "x", options.intersect, useFinalPosition);
          },
          y(chart, e, options, useFinalPosition) {
            const position = helpers_segment.getRelativePosition(e, chart);
            return getAxisItems(chart, position, "y", options.intersect, useFinalPosition);
          }
        }
      };
      var STATIC_POSITIONS = [
        "left",
        "top",
        "right",
        "bottom"
      ];
      function filterByPosition(array, position) {
        return array.filter((v) => v.pos === position);
      }
      function filterDynamicPositionByAxis(array, axis) {
        return array.filter((v) => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);
      }
      function sortByWeight(array, reverse) {
        return array.sort((a, b) => {
          const v0 = reverse ? b : a;
          const v1 = reverse ? a : b;
          return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
        });
      }
      function wrapBoxes(boxes) {
        const layoutBoxes = [];
        let i, ilen, box, pos, stack, stackWeight;
        for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {
          box = boxes[i];
          ({ position: pos, options: { stack, stackWeight = 1 } } = box);
          layoutBoxes.push({
            index: i,
            box,
            pos,
            horizontal: box.isHorizontal(),
            weight: box.weight,
            stack: stack && pos + stack,
            stackWeight
          });
        }
        return layoutBoxes;
      }
      function buildStacks(layouts2) {
        const stacks = {};
        for (const wrap of layouts2) {
          const { stack, pos, stackWeight } = wrap;
          if (!stack || !STATIC_POSITIONS.includes(pos)) {
            continue;
          }
          const _stack = stacks[stack] || (stacks[stack] = {
            count: 0,
            placed: 0,
            weight: 0,
            size: 0
          });
          _stack.count++;
          _stack.weight += stackWeight;
        }
        return stacks;
      }
      function setLayoutDims(layouts2, params) {
        const stacks = buildStacks(layouts2);
        const { vBoxMaxWidth, hBoxMaxHeight } = params;
        let i, ilen, layout;
        for (i = 0, ilen = layouts2.length; i < ilen; ++i) {
          layout = layouts2[i];
          const { fullSize } = layout.box;
          const stack = stacks[layout.stack];
          const factor = stack && layout.stackWeight / stack.weight;
          if (layout.horizontal) {
            layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
            layout.height = hBoxMaxHeight;
          } else {
            layout.width = vBoxMaxWidth;
            layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
          }
        }
        return stacks;
      }
      function buildLayoutBoxes(boxes) {
        const layoutBoxes = wrapBoxes(boxes);
        const fullSize = sortByWeight(layoutBoxes.filter((wrap) => wrap.box.fullSize), true);
        const left = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
        const right = sortByWeight(filterByPosition(layoutBoxes, "right"));
        const top = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
        const bottom = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
        const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, "x");
        const centerVertical = filterDynamicPositionByAxis(layoutBoxes, "y");
        return {
          fullSize,
          leftAndTop: left.concat(top),
          rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
          chartArea: filterByPosition(layoutBoxes, "chartArea"),
          vertical: left.concat(right).concat(centerVertical),
          horizontal: top.concat(bottom).concat(centerHorizontal)
        };
      }
      function getCombinedMax(maxPadding, chartArea, a, b) {
        return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
      }
      function updateMaxPadding(maxPadding, boxPadding) {
        maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
        maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
        maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
        maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
      }
      function updateDims(chartArea, params, layout, stacks) {
        const { pos, box } = layout;
        const maxPadding = chartArea.maxPadding;
        if (!helpers_segment.isObject(pos)) {
          if (layout.size) {
            chartArea[pos] -= layout.size;
          }
          const stack = stacks[layout.stack] || {
            size: 0,
            count: 1
          };
          stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
          layout.size = stack.size / stack.count;
          chartArea[pos] += layout.size;
        }
        if (box.getPadding) {
          updateMaxPadding(maxPadding, box.getPadding());
        }
        const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right"));
        const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom"));
        const widthChanged = newWidth !== chartArea.w;
        const heightChanged = newHeight !== chartArea.h;
        chartArea.w = newWidth;
        chartArea.h = newHeight;
        return layout.horizontal ? {
          same: widthChanged,
          other: heightChanged
        } : {
          same: heightChanged,
          other: widthChanged
        };
      }
      function handleMaxPadding(chartArea) {
        const maxPadding = chartArea.maxPadding;
        function updatePos(pos) {
          const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
          chartArea[pos] += change;
          return change;
        }
        chartArea.y += updatePos("top");
        chartArea.x += updatePos("left");
        updatePos("right");
        updatePos("bottom");
      }
      function getMargins(horizontal, chartArea) {
        const maxPadding = chartArea.maxPadding;
        function marginForPositions(positions) {
          const margin = {
            left: 0,
            top: 0,
            right: 0,
            bottom: 0
          };
          positions.forEach((pos) => {
            margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
          });
          return margin;
        }
        return horizontal ? marginForPositions([
          "left",
          "right"
        ]) : marginForPositions([
          "top",
          "bottom"
        ]);
      }
      function fitBoxes(boxes, chartArea, params, stacks) {
        const refitBoxes = [];
        let i, ilen, layout, box, refit, changed;
        for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {
          layout = boxes[i];
          box = layout.box;
          box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
          const { same, other } = updateDims(chartArea, params, layout, stacks);
          refit |= same && refitBoxes.length;
          changed = changed || other;
          if (!box.fullSize) {
            refitBoxes.push(layout);
          }
        }
        return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
      }
      function setBoxDims(box, left, top, width, height) {
        box.top = top;
        box.left = left;
        box.right = left + width;
        box.bottom = top + height;
        box.width = width;
        box.height = height;
      }
      function placeBoxes(boxes, chartArea, params, stacks) {
        const userPadding = params.padding;
        let { x, y } = chartArea;
        for (const layout of boxes) {
          const box = layout.box;
          const stack = stacks[layout.stack] || {
            count: 1,
            placed: 0,
            weight: 1
          };
          const weight = layout.stackWeight / stack.weight || 1;
          if (layout.horizontal) {
            const width = chartArea.w * weight;
            const height = stack.size || box.height;
            if (helpers_segment.defined(stack.start)) {
              y = stack.start;
            }
            if (box.fullSize) {
              setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);
            } else {
              setBoxDims(box, chartArea.left + stack.placed, y, width, height);
            }
            stack.start = y;
            stack.placed += width;
            y = box.bottom;
          } else {
            const height = chartArea.h * weight;
            const width = stack.size || box.width;
            if (helpers_segment.defined(stack.start)) {
              x = stack.start;
            }
            if (box.fullSize) {
              setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);
            } else {
              setBoxDims(box, x, chartArea.top + stack.placed, width, height);
            }
            stack.start = x;
            stack.placed += height;
            x = box.right;
          }
        }
        chartArea.x = x;
        chartArea.y = y;
      }
      var layouts = {
        addBox(chart, item) {
          if (!chart.boxes) {
            chart.boxes = [];
          }
          item.fullSize = item.fullSize || false;
          item.position = item.position || "top";
          item.weight = item.weight || 0;
          item._layers = item._layers || function() {
            return [
              {
                z: 0,
                draw(chartArea) {
                  item.draw(chartArea);
                }
              }
            ];
          };
          chart.boxes.push(item);
        },
        removeBox(chart, layoutItem) {
          const index2 = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
          if (index2 !== -1) {
            chart.boxes.splice(index2, 1);
          }
        },
        configure(chart, item, options) {
          item.fullSize = options.fullSize;
          item.position = options.position;
          item.weight = options.weight;
        },
        update(chart, width, height, minPadding) {
          if (!chart) {
            return;
          }
          const padding = helpers_segment.toPadding(chart.options.layout.padding);
          const availableWidth = Math.max(width - padding.width, 0);
          const availableHeight = Math.max(height - padding.height, 0);
          const boxes = buildLayoutBoxes(chart.boxes);
          const verticalBoxes = boxes.vertical;
          const horizontalBoxes = boxes.horizontal;
          helpers_segment.each(chart.boxes, (box) => {
            if (typeof box.beforeLayout === "function") {
              box.beforeLayout();
            }
          });
          const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) => wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
          const params = Object.freeze({
            outerWidth: width,
            outerHeight: height,
            padding,
            availableWidth,
            availableHeight,
            vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
            hBoxMaxHeight: availableHeight / 2
          });
          const maxPadding = Object.assign({}, padding);
          updateMaxPadding(maxPadding, helpers_segment.toPadding(minPadding));
          const chartArea = Object.assign({
            maxPadding,
            w: availableWidth,
            h: availableHeight,
            x: padding.left,
            y: padding.top
          }, padding);
          const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
          fitBoxes(boxes.fullSize, chartArea, params, stacks);
          fitBoxes(verticalBoxes, chartArea, params, stacks);
          if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
            fitBoxes(verticalBoxes, chartArea, params, stacks);
          }
          handleMaxPadding(chartArea);
          placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
          chartArea.x += chartArea.w;
          chartArea.y += chartArea.h;
          placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
          chart.chartArea = {
            left: chartArea.left,
            top: chartArea.top,
            right: chartArea.left + chartArea.w,
            bottom: chartArea.top + chartArea.h,
            height: chartArea.h,
            width: chartArea.w
          };
          helpers_segment.each(boxes.chartArea, (layout) => {
            const box = layout.box;
            Object.assign(box, chart.chartArea);
            box.update(chartArea.w, chartArea.h, {
              left: 0,
              top: 0,
              right: 0,
              bottom: 0
            });
          });
        }
      };
      var BasePlatform = class {
        acquireContext(canvas, aspectRatio) {
        }
        releaseContext(context) {
          return false;
        }
        addEventListener(chart, type, listener) {
        }
        removeEventListener(chart, type, listener) {
        }
        getDevicePixelRatio() {
          return 1;
        }
        getMaximumSize(element, width, height, aspectRatio) {
          width = Math.max(0, width || element.width);
          height = height || element.height;
          return {
            width,
            height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
          };
        }
        isAttached(canvas) {
          return true;
        }
        updateConfig(config) {
        }
      };
      var BasicPlatform = class extends BasePlatform {
        acquireContext(item) {
          return item && item.getContext && item.getContext("2d") || null;
        }
        updateConfig(config) {
          config.options.animation = false;
        }
      };
      var EXPANDO_KEY = "$chartjs";
      var EVENT_TYPES = {
        touchstart: "mousedown",
        touchmove: "mousemove",
        touchend: "mouseup",
        pointerenter: "mouseenter",
        pointerdown: "mousedown",
        pointermove: "mousemove",
        pointerup: "mouseup",
        pointerleave: "mouseout",
        pointerout: "mouseout"
      };
      var isNullOrEmpty = (value) => value === null || value === "";
      function initCanvas(canvas, aspectRatio) {
        const style = canvas.style;
        const renderHeight = canvas.getAttribute("height");
        const renderWidth = canvas.getAttribute("width");
        canvas[EXPANDO_KEY] = {
          initial: {
            height: renderHeight,
            width: renderWidth,
            style: {
              display: style.display,
              height: style.height,
              width: style.width
            }
          }
        };
        style.display = style.display || "block";
        style.boxSizing = style.boxSizing || "border-box";
        if (isNullOrEmpty(renderWidth)) {
          const displayWidth = helpers_segment.readUsedSize(canvas, "width");
          if (displayWidth !== void 0) {
            canvas.width = displayWidth;
          }
        }
        if (isNullOrEmpty(renderHeight)) {
          if (canvas.style.height === "") {
            canvas.height = canvas.width / (aspectRatio || 2);
          } else {
            const displayHeight = helpers_segment.readUsedSize(canvas, "height");
            if (displayHeight !== void 0) {
              canvas.height = displayHeight;
            }
          }
        }
        return canvas;
      }
      var eventListenerOptions = helpers_segment.supportsEventListenerOptions ? {
        passive: true
      } : false;
      function addListener(node, type, listener) {
        node.addEventListener(type, listener, eventListenerOptions);
      }
      function removeListener(chart, type, listener) {
        chart.canvas.removeEventListener(type, listener, eventListenerOptions);
      }
      function fromNativeEvent(event, chart) {
        const type = EVENT_TYPES[event.type] || event.type;
        const { x, y } = helpers_segment.getRelativePosition(event, chart);
        return {
          type,
          chart,
          native: event,
          x: x !== void 0 ? x : null,
          y: y !== void 0 ? y : null
        };
      }
      function nodeListContains(nodeList, canvas) {
        for (const node of nodeList) {
          if (node === canvas || node.contains(canvas)) {
            return true;
          }
        }
      }
      function createAttachObserver(chart, type, listener) {
        const canvas = chart.canvas;
        const observer = new MutationObserver((entries) => {
          let trigger = false;
          for (const entry of entries) {
            trigger = trigger || nodeListContains(entry.addedNodes, canvas);
            trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
          }
          if (trigger) {
            listener();
          }
        });
        observer.observe(document, {
          childList: true,
          subtree: true
        });
        return observer;
      }
      function createDetachObserver(chart, type, listener) {
        const canvas = chart.canvas;
        const observer = new MutationObserver((entries) => {
          let trigger = false;
          for (const entry of entries) {
            trigger = trigger || nodeListContains(entry.removedNodes, canvas);
            trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
          }
          if (trigger) {
            listener();
          }
        });
        observer.observe(document, {
          childList: true,
          subtree: true
        });
        return observer;
      }
      var drpListeningCharts = /* @__PURE__ */ new Map();
      var oldDevicePixelRatio = 0;
      function onWindowResize() {
        const dpr = window.devicePixelRatio;
        if (dpr === oldDevicePixelRatio) {
          return;
        }
        oldDevicePixelRatio = dpr;
        drpListeningCharts.forEach((resize, chart) => {
          if (chart.currentDevicePixelRatio !== dpr) {
            resize();
          }
        });
      }
      function listenDevicePixelRatioChanges(chart, resize) {
        if (!drpListeningCharts.size) {
          window.addEventListener("resize", onWindowResize);
        }
        drpListeningCharts.set(chart, resize);
      }
      function unlistenDevicePixelRatioChanges(chart) {
        drpListeningCharts.delete(chart);
        if (!drpListeningCharts.size) {
          window.removeEventListener("resize", onWindowResize);
        }
      }
      function createResizeObserver(chart, type, listener) {
        const canvas = chart.canvas;
        const container = canvas && helpers_segment._getParentNode(canvas);
        if (!container) {
          return;
        }
        const resize = helpers_segment.throttled((width, height) => {
          const w = container.clientWidth;
          listener(width, height);
          if (w < container.clientWidth) {
            listener();
          }
        }, window);
        const observer = new ResizeObserver((entries) => {
          const entry = entries[0];
          const width = entry.contentRect.width;
          const height = entry.contentRect.height;
          if (width === 0 && height === 0) {
            return;
          }
          resize(width, height);
        });
        observer.observe(container);
        listenDevicePixelRatioChanges(chart, resize);
        return observer;
      }
      function releaseObserver(chart, type, observer) {
        if (observer) {
          observer.disconnect();
        }
        if (type === "resize") {
          unlistenDevicePixelRatioChanges(chart);
        }
      }
      function createProxyAndListen(chart, type, listener) {
        const canvas = chart.canvas;
        const proxy = helpers_segment.throttled((event) => {
          if (chart.ctx !== null) {
            listener(fromNativeEvent(event, chart));
          }
        }, chart);
        addListener(canvas, type, proxy);
        return proxy;
      }
      var DomPlatform = class extends BasePlatform {
        acquireContext(canvas, aspectRatio) {
          const context = canvas && canvas.getContext && canvas.getContext("2d");
          if (context && context.canvas === canvas) {
            initCanvas(canvas, aspectRatio);
            return context;
          }
          return null;
        }
        releaseContext(context) {
          const canvas = context.canvas;
          if (!canvas[EXPANDO_KEY]) {
            return false;
          }
          const initial = canvas[EXPANDO_KEY].initial;
          [
            "height",
            "width"
          ].forEach((prop) => {
            const value = initial[prop];
            if (helpers_segment.isNullOrUndef(value)) {
              canvas.removeAttribute(prop);
            } else {
              canvas.setAttribute(prop, value);
            }
          });
          const style = initial.style || {};
          Object.keys(style).forEach((key) => {
            canvas.style[key] = style[key];
          });
          canvas.width = canvas.width;
          delete canvas[EXPANDO_KEY];
          return true;
        }
        addEventListener(chart, type, listener) {
          this.removeEventListener(chart, type);
          const proxies = chart.$proxies || (chart.$proxies = {});
          const handlers = {
            attach: createAttachObserver,
            detach: createDetachObserver,
            resize: createResizeObserver
          };
          const handler = handlers[type] || createProxyAndListen;
          proxies[type] = handler(chart, type, listener);
        }
        removeEventListener(chart, type) {
          const proxies = chart.$proxies || (chart.$proxies = {});
          const proxy = proxies[type];
          if (!proxy) {
            return;
          }
          const handlers = {
            attach: releaseObserver,
            detach: releaseObserver,
            resize: releaseObserver
          };
          const handler = handlers[type] || removeListener;
          handler(chart, type, proxy);
          proxies[type] = void 0;
        }
        getDevicePixelRatio() {
          return window.devicePixelRatio;
        }
        getMaximumSize(canvas, width, height, aspectRatio) {
          return helpers_segment.getMaximumSize(canvas, width, height, aspectRatio);
        }
        isAttached(canvas) {
          const container = helpers_segment._getParentNode(canvas);
          return !!(container && container.isConnected);
        }
      };
      function _detectPlatform(canvas) {
        if (!helpers_segment._isDomSupported() || typeof OffscreenCanvas !== "undefined" && canvas instanceof OffscreenCanvas) {
          return BasicPlatform;
        }
        return DomPlatform;
      }
      var Element = class {
        x;
        y;
        active = false;
        options;
        $animations;
        tooltipPosition(useFinalPosition) {
          const { x, y } = this.getProps([
            "x",
            "y"
          ], useFinalPosition);
          return {
            x,
            y
          };
        }
        hasValue() {
          return helpers_segment.isNumber(this.x) && helpers_segment.isNumber(this.y);
        }
        getProps(props, final) {
          const anims = this.$animations;
          if (!final || !anims) {
            return this;
          }
          const ret = {};
          props.forEach((prop) => {
            ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
          });
          return ret;
        }
      };
      __publicField(Element, "defaults", {});
      __publicField(Element, "defaultRoutes");
      function autoSkip(scale, ticks) {
        const tickOpts = scale.options.ticks;
        const determinedMaxTicks = determineMaxTicks(scale);
        const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);
        const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
        const numMajorIndices = majorIndices.length;
        const first = majorIndices[0];
        const last = majorIndices[numMajorIndices - 1];
        const newTicks = [];
        if (numMajorIndices > ticksLimit) {
          skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
          return newTicks;
        }
        const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
        if (numMajorIndices > 0) {
          let i, ilen;
          const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
          skip(ticks, newTicks, spacing, helpers_segment.isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
          for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {
            skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);
          }
          skip(ticks, newTicks, spacing, last, helpers_segment.isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
          return newTicks;
        }
        skip(ticks, newTicks, spacing);
        return newTicks;
      }
      function determineMaxTicks(scale) {
        const offset = scale.options.offset;
        const tickLength = scale._tickSize();
        const maxScale = scale._length / tickLength + (offset ? 0 : 1);
        const maxChart = scale._maxLength / tickLength;
        return Math.floor(Math.min(maxScale, maxChart));
      }
      function calculateSpacing(majorIndices, ticks, ticksLimit) {
        const evenMajorSpacing = getEvenSpacing(majorIndices);
        const spacing = ticks.length / ticksLimit;
        if (!evenMajorSpacing) {
          return Math.max(spacing, 1);
        }
        const factors = helpers_segment._factorize(evenMajorSpacing);
        for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {
          const factor = factors[i];
          if (factor > spacing) {
            return factor;
          }
        }
        return Math.max(spacing, 1);
      }
      function getMajorIndices(ticks) {
        const result = [];
        let i, ilen;
        for (i = 0, ilen = ticks.length; i < ilen; i++) {
          if (ticks[i].major) {
            result.push(i);
          }
        }
        return result;
      }
      function skipMajors(ticks, newTicks, majorIndices, spacing) {
        let count = 0;
        let next = majorIndices[0];
        let i;
        spacing = Math.ceil(spacing);
        for (i = 0; i < ticks.length; i++) {
          if (i === next) {
            newTicks.push(ticks[i]);
            count++;
            next = majorIndices[count * spacing];
          }
        }
      }
      function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
        const start = helpers_segment.valueOrDefault(majorStart, 0);
        const end = Math.min(helpers_segment.valueOrDefault(majorEnd, ticks.length), ticks.length);
        let count = 0;
        let length, i, next;
        spacing = Math.ceil(spacing);
        if (majorEnd) {
          length = majorEnd - majorStart;
          spacing = length / Math.floor(length / spacing);
        }
        next = start;
        while (next < 0) {
          count++;
          next = Math.round(start + count * spacing);
        }
        for (i = Math.max(start, 0); i < end; i++) {
          if (i === next) {
            newTicks.push(ticks[i]);
            count++;
            next = Math.round(start + count * spacing);
          }
        }
      }
      function getEvenSpacing(arr) {
        const len = arr.length;
        let i, diff;
        if (len < 2) {
          return false;
        }
        for (diff = arr[0], i = 1; i < len; ++i) {
          if (arr[i] - arr[i - 1] !== diff) {
            return false;
          }
        }
        return diff;
      }
      var reverseAlign = (align) => align === "left" ? "right" : align === "right" ? "left" : align;
      var offsetFromEdge = (scale, edge, offset) => edge === "top" || edge === "left" ? scale[edge] + offset : scale[edge] - offset;
      var getTicksLimit = (ticksLength, maxTicksLimit) => Math.min(maxTicksLimit || ticksLength, ticksLength);
      function sample(arr, numItems) {
        const result = [];
        const increment = arr.length / numItems;
        const len = arr.length;
        let i = 0;
        for (; i < len; i += increment) {
          result.push(arr[Math.floor(i)]);
        }
        return result;
      }
      function getPixelForGridLine(scale, index2, offsetGridLines) {
        const length = scale.ticks.length;
        const validIndex2 = Math.min(index2, length - 1);
        const start = scale._startPixel;
        const end = scale._endPixel;
        const epsilon = 1e-6;
        let lineValue = scale.getPixelForTick(validIndex2);
        let offset;
        if (offsetGridLines) {
          if (length === 1) {
            offset = Math.max(lineValue - start, end - lineValue);
          } else if (index2 === 0) {
            offset = (scale.getPixelForTick(1) - lineValue) / 2;
          } else {
            offset = (lineValue - scale.getPixelForTick(validIndex2 - 1)) / 2;
          }
          lineValue += validIndex2 < index2 ? offset : -offset;
          if (lineValue < start - epsilon || lineValue > end + epsilon) {
            return;
          }
        }
        return lineValue;
      }
      function garbageCollect(caches, length) {
        helpers_segment.each(caches, (cache) => {
          const gc = cache.gc;
          const gcLen = gc.length / 2;
          let i;
          if (gcLen > length) {
            for (i = 0; i < gcLen; ++i) {
              delete cache.data[gc[i]];
            }
            gc.splice(0, gcLen);
          }
        });
      }
      function getTickMarkLength(options) {
        return options.drawTicks ? options.tickLength : 0;
      }
      function getTitleHeight(options, fallback) {
        if (!options.display) {
          return 0;
        }
        const font = helpers_segment.toFont(options.font, fallback);
        const padding = helpers_segment.toPadding(options.padding);
        const lines = helpers_segment.isArray(options.text) ? options.text.length : 1;
        return lines * font.lineHeight + padding.height;
      }
      function createScaleContext(parent, scale) {
        return helpers_segment.createContext(parent, {
          scale,
          type: "scale"
        });
      }
      function createTickContext(parent, index2, tick) {
        return helpers_segment.createContext(parent, {
          tick,
          index: index2,
          type: "tick"
        });
      }
      function titleAlign(align, position, reverse) {
        let ret = helpers_segment._toLeftRightCenter(align);
        if (reverse && position !== "right" || !reverse && position === "right") {
          ret = reverseAlign(ret);
        }
        return ret;
      }
      function titleArgs(scale, offset, position, align) {
        const { top, left, bottom, right, chart } = scale;
        const { chartArea, scales: scales2 } = chart;
        let rotation = 0;
        let maxWidth, titleX, titleY;
        const height = bottom - top;
        const width = right - left;
        if (scale.isHorizontal()) {
          titleX = helpers_segment._alignStartEnd(align, left, right);
          if (helpers_segment.isObject(position)) {
            const positionAxisID = Object.keys(position)[0];
            const value = position[positionAxisID];
            titleY = scales2[positionAxisID].getPixelForValue(value) + height - offset;
          } else if (position === "center") {
            titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;
          } else {
            titleY = offsetFromEdge(scale, position, offset);
          }
          maxWidth = right - left;
        } else {
          if (helpers_segment.isObject(position)) {
            const positionAxisID = Object.keys(position)[0];
            const value = position[positionAxisID];
            titleX = scales2[positionAxisID].getPixelForValue(value) - width + offset;
          } else if (position === "center") {
            titleX = (chartArea.left + chartArea.right) / 2 - width + offset;
          } else {
            titleX = offsetFromEdge(scale, position, offset);
          }
          titleY = helpers_segment._alignStartEnd(align, bottom, top);
          rotation = position === "left" ? -helpers_segment.HALF_PI : helpers_segment.HALF_PI;
        }
        return {
          titleX,
          titleY,
          maxWidth,
          rotation
        };
      }
      var Scale = class extends Element {
        constructor(cfg) {
          super();
          this.id = cfg.id;
          this.type = cfg.type;
          this.options = void 0;
          this.ctx = cfg.ctx;
          this.chart = cfg.chart;
          this.top = void 0;
          this.bottom = void 0;
          this.left = void 0;
          this.right = void 0;
          this.width = void 0;
          this.height = void 0;
          this._margins = {
            left: 0,
            right: 0,
            top: 0,
            bottom: 0
          };
          this.maxWidth = void 0;
          this.maxHeight = void 0;
          this.paddingTop = void 0;
          this.paddingBottom = void 0;
          this.paddingLeft = void 0;
          this.paddingRight = void 0;
          this.axis = void 0;
          this.labelRotation = void 0;
          this.min = void 0;
          this.max = void 0;
          this._range = void 0;
          this.ticks = [];
          this._gridLineItems = null;
          this._labelItems = null;
          this._labelSizes = null;
          this._length = 0;
          this._maxLength = 0;
          this._longestTextCache = {};
          this._startPixel = void 0;
          this._endPixel = void 0;
          this._reversePixels = false;
          this._userMax = void 0;
          this._userMin = void 0;
          this._suggestedMax = void 0;
          this._suggestedMin = void 0;
          this._ticksLength = 0;
          this._borderValue = 0;
          this._cache = {};
          this._dataLimitsCached = false;
          this.$context = void 0;
        }
        init(options) {
          this.options = options.setContext(this.getContext());
          this.axis = options.axis;
          this._userMin = this.parse(options.min);
          this._userMax = this.parse(options.max);
          this._suggestedMin = this.parse(options.suggestedMin);
          this._suggestedMax = this.parse(options.suggestedMax);
        }
        parse(raw, index2) {
          return raw;
        }
        getUserBounds() {
          let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;
          _userMin = helpers_segment.finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
          _userMax = helpers_segment.finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
          _suggestedMin = helpers_segment.finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
          _suggestedMax = helpers_segment.finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
          return {
            min: helpers_segment.finiteOrDefault(_userMin, _suggestedMin),
            max: helpers_segment.finiteOrDefault(_userMax, _suggestedMax),
            minDefined: helpers_segment.isNumberFinite(_userMin),
            maxDefined: helpers_segment.isNumberFinite(_userMax)
          };
        }
        getMinMax(canStack) {
          let { min, max, minDefined, maxDefined } = this.getUserBounds();
          let range;
          if (minDefined && maxDefined) {
            return {
              min,
              max
            };
          }
          const metas = this.getMatchingVisibleMetas();
          for (let i = 0, ilen = metas.length; i < ilen; ++i) {
            range = metas[i].controller.getMinMax(this, canStack);
            if (!minDefined) {
              min = Math.min(min, range.min);
            }
            if (!maxDefined) {
              max = Math.max(max, range.max);
            }
          }
          min = maxDefined && min > max ? max : min;
          max = minDefined && min > max ? min : max;
          return {
            min: helpers_segment.finiteOrDefault(min, helpers_segment.finiteOrDefault(max, min)),
            max: helpers_segment.finiteOrDefault(max, helpers_segment.finiteOrDefault(min, max))
          };
        }
        getPadding() {
          return {
            left: this.paddingLeft || 0,
            top: this.paddingTop || 0,
            right: this.paddingRight || 0,
            bottom: this.paddingBottom || 0
          };
        }
        getTicks() {
          return this.ticks;
        }
        getLabels() {
          const data = this.chart.data;
          return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
        }
        getLabelItems(chartArea = this.chart.chartArea) {
          const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
          return items;
        }
        beforeLayout() {
          this._cache = {};
          this._dataLimitsCached = false;
        }
        beforeUpdate() {
          helpers_segment.callback(this.options.beforeUpdate, [
            this
          ]);
        }
        update(maxWidth, maxHeight, margins) {
          const { beginAtZero, grace, ticks: tickOpts } = this.options;
          const sampleSize = tickOpts.sampleSize;
          this.beforeUpdate();
          this.maxWidth = maxWidth;
          this.maxHeight = maxHeight;
          this._margins = margins = Object.assign({
            left: 0,
            right: 0,
            top: 0,
            bottom: 0
          }, margins);
          this.ticks = null;
          this._labelSizes = null;
          this._gridLineItems = null;
          this._labelItems = null;
          this.beforeSetDimensions();
          this.setDimensions();
          this.afterSetDimensions();
          this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
          if (!this._dataLimitsCached) {
            this.beforeDataLimits();
            this.determineDataLimits();
            this.afterDataLimits();
            this._range = helpers_segment._addGrace(this, grace, beginAtZero);
            this._dataLimitsCached = true;
          }
          this.beforeBuildTicks();
          this.ticks = this.buildTicks() || [];
          this.afterBuildTicks();
          const samplingEnabled = sampleSize < this.ticks.length;
          this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
          this.configure();
          this.beforeCalculateLabelRotation();
          this.calculateLabelRotation();
          this.afterCalculateLabelRotation();
          if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto")) {
            this.ticks = autoSkip(this, this.ticks);
            this._labelSizes = null;
            this.afterAutoSkip();
          }
          if (samplingEnabled) {
            this._convertTicksToLabels(this.ticks);
          }
          this.beforeFit();
          this.fit();
          this.afterFit();
          this.afterUpdate();
        }
        configure() {
          let reversePixels = this.options.reverse;
          let startPixel, endPixel;
          if (this.isHorizontal()) {
            startPixel = this.left;
            endPixel = this.right;
          } else {
            startPixel = this.top;
            endPixel = this.bottom;
            reversePixels = !reversePixels;
          }
          this._startPixel = startPixel;
          this._endPixel = endPixel;
          this._reversePixels = reversePixels;
          this._length = endPixel - startPixel;
          this._alignToPixels = this.options.alignToPixels;
        }
        afterUpdate() {
          helpers_segment.callback(this.options.afterUpdate, [
            this
          ]);
        }
        beforeSetDimensions() {
          helpers_segment.callback(this.options.beforeSetDimensions, [
            this
          ]);
        }
        setDimensions() {
          if (this.isHorizontal()) {
            this.width = this.maxWidth;
            this.left = 0;
            this.right = this.width;
          } else {
            this.height = this.maxHeight;
            this.top = 0;
            this.bottom = this.height;
          }
          this.paddingLeft = 0;
          this.paddingTop = 0;
          this.paddingRight = 0;
          this.paddingBottom = 0;
        }
        afterSetDimensions() {
          helpers_segment.callback(this.options.afterSetDimensions, [
            this
          ]);
        }
        _callHooks(name) {
          this.chart.notifyPlugins(name, this.getContext());
          helpers_segment.callback(this.options[name], [
            this
          ]);
        }
        beforeDataLimits() {
          this._callHooks("beforeDataLimits");
        }
        determineDataLimits() {
        }
        afterDataLimits() {
          this._callHooks("afterDataLimits");
        }
        beforeBuildTicks() {
          this._callHooks("beforeBuildTicks");
        }
        buildTicks() {
          return [];
        }
        afterBuildTicks() {
          this._callHooks("afterBuildTicks");
        }
        beforeTickToLabelConversion() {
          helpers_segment.callback(this.options.beforeTickToLabelConversion, [
            this
          ]);
        }
        generateTickLabels(ticks) {
          const tickOpts = this.options.ticks;
          let i, ilen, tick;
          for (i = 0, ilen = ticks.length; i < ilen; i++) {
            tick = ticks[i];
            tick.label = helpers_segment.callback(tickOpts.callback, [
              tick.value,
              i,
              ticks
            ], this);
          }
        }
        afterTickToLabelConversion() {
          helpers_segment.callback(this.options.afterTickToLabelConversion, [
            this
          ]);
        }
        beforeCalculateLabelRotation() {
          helpers_segment.callback(this.options.beforeCalculateLabelRotation, [
            this
          ]);
        }
        calculateLabelRotation() {
          const options = this.options;
          const tickOpts = options.ticks;
          const numTicks = getTicksLimit(this.ticks.length, options.ticks.maxTicksLimit);
          const minRotation = tickOpts.minRotation || 0;
          const maxRotation = tickOpts.maxRotation;
          let labelRotation = minRotation;
          let tickWidth, maxHeight, maxLabelDiagonal;
          if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
            this.labelRotation = minRotation;
            return;
          }
          const labelSizes = this._getLabelSizes();
          const maxLabelWidth = labelSizes.widest.width;
          const maxLabelHeight = labelSizes.highest.height;
          const maxWidth = helpers_segment._limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
          tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
          if (maxLabelWidth + 6 > tickWidth) {
            tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
            maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
            maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
            labelRotation = helpers_segment.toDegrees(Math.min(Math.asin(helpers_segment._limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(helpers_segment._limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(helpers_segment._limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));
            labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
          }
          this.labelRotation = labelRotation;
        }
        afterCalculateLabelRotation() {
          helpers_segment.callback(this.options.afterCalculateLabelRotation, [
            this
          ]);
        }
        afterAutoSkip() {
        }
        beforeFit() {
          helpers_segment.callback(this.options.beforeFit, [
            this
          ]);
        }
        fit() {
          const minSize = {
            width: 0,
            height: 0
          };
          const { chart, options: { ticks: tickOpts, title: titleOpts, grid: gridOpts } } = this;
          const display = this._isVisible();
          const isHorizontal = this.isHorizontal();
          if (display) {
            const titleHeight = getTitleHeight(titleOpts, chart.options.font);
            if (isHorizontal) {
              minSize.width = this.maxWidth;
              minSize.height = getTickMarkLength(gridOpts) + titleHeight;
            } else {
              minSize.height = this.maxHeight;
              minSize.width = getTickMarkLength(gridOpts) + titleHeight;
            }
            if (tickOpts.display && this.ticks.length) {
              const { first, last, widest, highest } = this._getLabelSizes();
              const tickPadding = tickOpts.padding * 2;
              const angleRadians = helpers_segment.toRadians(this.labelRotation);
              const cos = Math.cos(angleRadians);
              const sin = Math.sin(angleRadians);
              if (isHorizontal) {
                const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
                minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
              } else {
                const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
                minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
              }
              this._calculatePadding(first, last, sin, cos);
            }
          }
          this._handleMargins();
          if (isHorizontal) {
            this.width = this._length = chart.width - this._margins.left - this._margins.right;
            this.height = minSize.height;
          } else {
            this.width = minSize.width;
            this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
          }
        }
        _calculatePadding(first, last, sin, cos) {
          const { ticks: { align, padding }, position } = this.options;
          const isRotated = this.labelRotation !== 0;
          const labelsBelowTicks = position !== "top" && this.axis === "x";
          if (this.isHorizontal()) {
            const offsetLeft = this.getPixelForTick(0) - this.left;
            const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
            let paddingLeft = 0;
            let paddingRight = 0;
            if (isRotated) {
              if (labelsBelowTicks) {
                paddingLeft = cos * first.width;
                paddingRight = sin * last.height;
              } else {
                paddingLeft = sin * first.height;
                paddingRight = cos * last.width;
              }
            } else if (align === "start") {
              paddingRight = last.width;
            } else if (align === "end") {
              paddingLeft = first.width;
            } else if (align !== "inner") {
              paddingLeft = first.width / 2;
              paddingRight = last.width / 2;
            }
            this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
            this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
          } else {
            let paddingTop = last.height / 2;
            let paddingBottom = first.height / 2;
            if (align === "start") {
              paddingTop = 0;
              paddingBottom = first.height;
            } else if (align === "end") {
              paddingTop = last.height;
              paddingBottom = 0;
            }
            this.paddingTop = paddingTop + padding;
            this.paddingBottom = paddingBottom + padding;
          }
        }
        _handleMargins() {
          if (this._margins) {
            this._margins.left = Math.max(this.paddingLeft, this._margins.left);
            this._margins.top = Math.max(this.paddingTop, this._margins.top);
            this._margins.right = Math.max(this.paddingRight, this._margins.right);
            this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
          }
        }
        afterFit() {
          helpers_segment.callback(this.options.afterFit, [
            this
          ]);
        }
        isHorizontal() {
          const { axis, position } = this.options;
          return position === "top" || position === "bottom" || axis === "x";
        }
        isFullSize() {
          return this.options.fullSize;
        }
        _convertTicksToLabels(ticks) {
          this.beforeTickToLabelConversion();
          this.generateTickLabels(ticks);
          let i, ilen;
          for (i = 0, ilen = ticks.length; i < ilen; i++) {
            if (helpers_segment.isNullOrUndef(ticks[i].label)) {
              ticks.splice(i, 1);
              ilen--;
              i--;
            }
          }
          this.afterTickToLabelConversion();
        }
        _getLabelSizes() {
          let labelSizes = this._labelSizes;
          if (!labelSizes) {
            const sampleSize = this.options.ticks.sampleSize;
            let ticks = this.ticks;
            if (sampleSize < ticks.length) {
              ticks = sample(ticks, sampleSize);
            }
            this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length, this.options.ticks.maxTicksLimit);
          }
          return labelSizes;
        }
        _computeLabelSizes(ticks, length, maxTicksLimit) {
          const { ctx, _longestTextCache: caches } = this;
          const widths = [];
          const heights = [];
          const increment = Math.floor(length / getTicksLimit(length, maxTicksLimit));
          let widestLabelSize = 0;
          let highestLabelSize = 0;
          let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;
          for (i = 0; i < length; i += increment) {
            label = ticks[i].label;
            tickFont = this._resolveTickFontOptions(i);
            ctx.font = fontString = tickFont.string;
            cache = caches[fontString] = caches[fontString] || {
              data: {},
              gc: []
            };
            lineHeight = tickFont.lineHeight;
            width = height = 0;
            if (!helpers_segment.isNullOrUndef(label) && !helpers_segment.isArray(label)) {
              width = helpers_segment._measureText(ctx, cache.data, cache.gc, width, label);
              height = lineHeight;
            } else if (helpers_segment.isArray(label)) {
              for (j = 0, jlen = label.length; j < jlen; ++j) {
                nestedLabel = label[j];
                if (!helpers_segment.isNullOrUndef(nestedLabel) && !helpers_segment.isArray(nestedLabel)) {
                  width = helpers_segment._measureText(ctx, cache.data, cache.gc, width, nestedLabel);
                  height += lineHeight;
                }
              }
            }
            widths.push(width);
            heights.push(height);
            widestLabelSize = Math.max(width, widestLabelSize);
            highestLabelSize = Math.max(height, highestLabelSize);
          }
          garbageCollect(caches, length);
          const widest = widths.indexOf(widestLabelSize);
          const highest = heights.indexOf(highestLabelSize);
          const valueAt = (idx) => ({
            width: widths[idx] || 0,
            height: heights[idx] || 0
          });
          return {
            first: valueAt(0),
            last: valueAt(length - 1),
            widest: valueAt(widest),
            highest: valueAt(highest),
            widths,
            heights
          };
        }
        getLabelForValue(value) {
          return value;
        }
        getPixelForValue(value, index2) {
          return NaN;
        }
        getValueForPixel(pixel) {
        }
        getPixelForTick(index2) {
          const ticks = this.ticks;
          if (index2 < 0 || index2 > ticks.length - 1) {
            return null;
          }
          return this.getPixelForValue(ticks[index2].value);
        }
        getPixelForDecimal(decimal) {
          if (this._reversePixels) {
            decimal = 1 - decimal;
          }
          const pixel = this._startPixel + decimal * this._length;
          return helpers_segment._int16Range(this._alignToPixels ? helpers_segment._alignPixel(this.chart, pixel, 0) : pixel);
        }
        getDecimalForPixel(pixel) {
          const decimal = (pixel - this._startPixel) / this._length;
          return this._reversePixels ? 1 - decimal : decimal;
        }
        getBasePixel() {
          return this.getPixelForValue(this.getBaseValue());
        }
        getBaseValue() {
          const { min, max } = this;
          return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
        }
        getContext(index2) {
          const ticks = this.ticks || [];
          if (index2 >= 0 && index2 < ticks.length) {
            const tick = ticks[index2];
            return tick.$context || (tick.$context = createTickContext(this.getContext(), index2, tick));
          }
          return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
        }
        _tickSize() {
          const optionTicks = this.options.ticks;
          const rot = helpers_segment.toRadians(this.labelRotation);
          const cos = Math.abs(Math.cos(rot));
          const sin = Math.abs(Math.sin(rot));
          const labelSizes = this._getLabelSizes();
          const padding = optionTicks.autoSkipPadding || 0;
          const w = labelSizes ? labelSizes.widest.width + padding : 0;
          const h = labelSizes ? labelSizes.highest.height + padding : 0;
          return this.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;
        }
        _isVisible() {
          const display = this.options.display;
          if (display !== "auto") {
            return !!display;
          }
          return this.getMatchingVisibleMetas().length > 0;
        }
        _computeGridLineItems(chartArea) {
          const axis = this.axis;
          const chart = this.chart;
          const options = this.options;
          const { grid, position, border } = options;
          const offset = grid.offset;
          const isHorizontal = this.isHorizontal();
          const ticks = this.ticks;
          const ticksLength = ticks.length + (offset ? 1 : 0);
          const tl = getTickMarkLength(grid);
          const items = [];
          const borderOpts = border.setContext(this.getContext());
          const axisWidth = borderOpts.display ? borderOpts.width : 0;
          const axisHalfWidth = axisWidth / 2;
          const alignBorderValue = function(pixel) {
            return helpers_segment._alignPixel(chart, pixel, axisWidth);
          };
          let borderValue, i, lineValue, alignedLineValue;
          let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
          if (position === "top") {
            borderValue = alignBorderValue(this.bottom);
            ty1 = this.bottom - tl;
            ty2 = borderValue - axisHalfWidth;
            y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
            y2 = chartArea.bottom;
          } else if (position === "bottom") {
            borderValue = alignBorderValue(this.top);
            y1 = chartArea.top;
            y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
            ty1 = borderValue + axisHalfWidth;
            ty2 = this.top + tl;
          } else if (position === "left") {
            borderValue = alignBorderValue(this.right);
            tx1 = this.right - tl;
            tx2 = borderValue - axisHalfWidth;
            x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
            x2 = chartArea.right;
          } else if (position === "right") {
            borderValue = alignBorderValue(this.left);
            x1 = chartArea.left;
            x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
            tx1 = borderValue + axisHalfWidth;
            tx2 = this.left + tl;
          } else if (axis === "x") {
            if (position === "center") {
              borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
            } else if (helpers_segment.isObject(position)) {
              const positionAxisID = Object.keys(position)[0];
              const value = position[positionAxisID];
              borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
            }
            y1 = chartArea.top;
            y2 = chartArea.bottom;
            ty1 = borderValue + axisHalfWidth;
            ty2 = ty1 + tl;
          } else if (axis === "y") {
            if (position === "center") {
              borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
            } else if (helpers_segment.isObject(position)) {
              const positionAxisID = Object.keys(position)[0];
              const value = position[positionAxisID];
              borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
            }
            tx1 = borderValue - axisHalfWidth;
            tx2 = tx1 - tl;
            x1 = chartArea.left;
            x2 = chartArea.right;
          }
          const limit = helpers_segment.valueOrDefault(options.ticks.maxTicksLimit, ticksLength);
          const step = Math.max(1, Math.ceil(ticksLength / limit));
          for (i = 0; i < ticksLength; i += step) {
            const context = this.getContext(i);
            const optsAtIndex = grid.setContext(context);
            const optsAtIndexBorder = border.setContext(context);
            const lineWidth = optsAtIndex.lineWidth;
            const lineColor = optsAtIndex.color;
            const borderDash = optsAtIndexBorder.dash || [];
            const borderDashOffset = optsAtIndexBorder.dashOffset;
            const tickWidth = optsAtIndex.tickWidth;
            const tickColor = optsAtIndex.tickColor;
            const tickBorderDash = optsAtIndex.tickBorderDash || [];
            const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
            lineValue = getPixelForGridLine(this, i, offset);
            if (lineValue === void 0) {
              continue;
            }
            alignedLineValue = helpers_segment._alignPixel(chart, lineValue, lineWidth);
            if (isHorizontal) {
              tx1 = tx2 = x1 = x2 = alignedLineValue;
            } else {
              ty1 = ty2 = y1 = y2 = alignedLineValue;
            }
            items.push({
              tx1,
              ty1,
              tx2,
              ty2,
              x1,
              y1,
              x2,
              y2,
              width: lineWidth,
              color: lineColor,
              borderDash,
              borderDashOffset,
              tickWidth,
              tickColor,
              tickBorderDash,
              tickBorderDashOffset
            });
          }
          this._ticksLength = ticksLength;
          this._borderValue = borderValue;
          return items;
        }
        _computeLabelItems(chartArea) {
          const axis = this.axis;
          const options = this.options;
          const { position, ticks: optionTicks } = options;
          const isHorizontal = this.isHorizontal();
          const ticks = this.ticks;
          const { align, crossAlign, padding, mirror } = optionTicks;
          const tl = getTickMarkLength(options.grid);
          const tickAndPadding = tl + padding;
          const hTickAndPadding = mirror ? -padding : tickAndPadding;
          const rotation = -helpers_segment.toRadians(this.labelRotation);
          const items = [];
          let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
          let textBaseline = "middle";
          if (position === "top") {
            y = this.bottom - hTickAndPadding;
            textAlign = this._getXAxisLabelAlignment();
          } else if (position === "bottom") {
            y = this.top + hTickAndPadding;
            textAlign = this._getXAxisLabelAlignment();
          } else if (position === "left") {
            const ret = this._getYAxisLabelAlignment(tl);
            textAlign = ret.textAlign;
            x = ret.x;
          } else if (position === "right") {
            const ret = this._getYAxisLabelAlignment(tl);
            textAlign = ret.textAlign;
            x = ret.x;
          } else if (axis === "x") {
            if (position === "center") {
              y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
            } else if (helpers_segment.isObject(position)) {
              const positionAxisID = Object.keys(position)[0];
              const value = position[positionAxisID];
              y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
            }
            textAlign = this._getXAxisLabelAlignment();
          } else if (axis === "y") {
            if (position === "center") {
              x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
            } else if (helpers_segment.isObject(position)) {
              const positionAxisID = Object.keys(position)[0];
              const value = position[positionAxisID];
              x = this.chart.scales[positionAxisID].getPixelForValue(value);
            }
            textAlign = this._getYAxisLabelAlignment(tl).textAlign;
          }
          if (axis === "y") {
            if (align === "start") {
              textBaseline = "top";
            } else if (align === "end") {
              textBaseline = "bottom";
            }
          }
          const labelSizes = this._getLabelSizes();
          for (i = 0, ilen = ticks.length; i < ilen; ++i) {
            tick = ticks[i];
            label = tick.label;
            const optsAtIndex = optionTicks.setContext(this.getContext(i));
            pixel = this.getPixelForTick(i) + optionTicks.labelOffset;
            font = this._resolveTickFontOptions(i);
            lineHeight = font.lineHeight;
            lineCount = helpers_segment.isArray(label) ? label.length : 1;
            const halfCount = lineCount / 2;
            const color = optsAtIndex.color;
            const strokeColor = optsAtIndex.textStrokeColor;
            const strokeWidth = optsAtIndex.textStrokeWidth;
            let tickTextAlign = textAlign;
            if (isHorizontal) {
              x = pixel;
              if (textAlign === "inner") {
                if (i === ilen - 1) {
                  tickTextAlign = !this.options.reverse ? "right" : "left";
                } else if (i === 0) {
                  tickTextAlign = !this.options.reverse ? "left" : "right";
                } else {
                  tickTextAlign = "center";
                }
              }
              if (position === "top") {
                if (crossAlign === "near" || rotation !== 0) {
                  textOffset = -lineCount * lineHeight + lineHeight / 2;
                } else if (crossAlign === "center") {
                  textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
                } else {
                  textOffset = -labelSizes.highest.height + lineHeight / 2;
                }
              } else {
                if (crossAlign === "near" || rotation !== 0) {
                  textOffset = lineHeight / 2;
                } else if (crossAlign === "center") {
                  textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
                } else {
                  textOffset = labelSizes.highest.height - lineCount * lineHeight;
                }
              }
              if (mirror) {
                textOffset *= -1;
              }
              if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {
                x += lineHeight / 2 * Math.sin(rotation);
              }
            } else {
              y = pixel;
              textOffset = (1 - lineCount) * lineHeight / 2;
            }
            let backdrop;
            if (optsAtIndex.showLabelBackdrop) {
              const labelPadding = helpers_segment.toPadding(optsAtIndex.backdropPadding);
              const height = labelSizes.heights[i];
              const width = labelSizes.widths[i];
              let top = textOffset - labelPadding.top;
              let left = 0 - labelPadding.left;
              switch (textBaseline) {
                case "middle":
                  top -= height / 2;
                  break;
                case "bottom":
                  top -= height;
                  break;
              }
              switch (textAlign) {
                case "center":
                  left -= width / 2;
                  break;
                case "right":
                  left -= width;
                  break;
              }
              backdrop = {
                left,
                top,
                width: width + labelPadding.width,
                height: height + labelPadding.height,
                color: optsAtIndex.backdropColor
              };
            }
            items.push({
              label,
              font,
              textOffset,
              options: {
                rotation,
                color,
                strokeColor,
                strokeWidth,
                textAlign: tickTextAlign,
                textBaseline,
                translation: [
                  x,
                  y
                ],
                backdrop
              }
            });
          }
          return items;
        }
        _getXAxisLabelAlignment() {
          const { position, ticks } = this.options;
          const rotation = -helpers_segment.toRadians(this.labelRotation);
          if (rotation) {
            return position === "top" ? "left" : "right";
          }
          let align = "center";
          if (ticks.align === "start") {
            align = "left";
          } else if (ticks.align === "end") {
            align = "right";
          } else if (ticks.align === "inner") {
            align = "inner";
          }
          return align;
        }
        _getYAxisLabelAlignment(tl) {
          const { position, ticks: { crossAlign, mirror, padding } } = this.options;
          const labelSizes = this._getLabelSizes();
          const tickAndPadding = tl + padding;
          const widest = labelSizes.widest.width;
          let textAlign;
          let x;
          if (position === "left") {
            if (mirror) {
              x = this.right + padding;
              if (crossAlign === "near") {
                textAlign = "left";
              } else if (crossAlign === "center") {
                textAlign = "center";
                x += widest / 2;
              } else {
                textAlign = "right";
                x += widest;
              }
            } else {
              x = this.right - tickAndPadding;
              if (crossAlign === "near") {
                textAlign = "right";
              } else if (crossAlign === "center") {
                textAlign = "center";
                x -= widest / 2;
              } else {
                textAlign = "left";
                x = this.left;
              }
            }
          } else if (position === "right") {
            if (mirror) {
              x = this.left + padding;
              if (crossAlign === "near") {
                textAlign = "right";
              } else if (crossAlign === "center") {
                textAlign = "center";
                x -= widest / 2;
              } else {
                textAlign = "left";
                x -= widest;
              }
            } else {
              x = this.left + tickAndPadding;
              if (crossAlign === "near") {
                textAlign = "left";
              } else if (crossAlign === "center") {
                textAlign = "center";
                x += widest / 2;
              } else {
                textAlign = "right";
                x = this.right;
              }
            }
          } else {
            textAlign = "right";
          }
          return {
            textAlign,
            x
          };
        }
        _computeLabelArea() {
          if (this.options.ticks.mirror) {
            return;
          }
          const chart = this.chart;
          const position = this.options.position;
          if (position === "left" || position === "right") {
            return {
              top: 0,
              left: this.left,
              bottom: chart.height,
              right: this.right
            };
          }
          if (position === "top" || position === "bottom") {
            return {
              top: this.top,
              left: 0,
              bottom: this.bottom,
              right: chart.width
            };
          }
        }
        drawBackground() {
          const { ctx, options: { backgroundColor }, left, top, width, height } = this;
          if (backgroundColor) {
            ctx.save();
            ctx.fillStyle = backgroundColor;
            ctx.fillRect(left, top, width, height);
            ctx.restore();
          }
        }
        getLineWidthForValue(value) {
          const grid = this.options.grid;
          if (!this._isVisible() || !grid.display) {
            return 0;
          }
          const ticks = this.ticks;
          const index2 = ticks.findIndex((t) => t.value === value);
          if (index2 >= 0) {
            const opts = grid.setContext(this.getContext(index2));
            return opts.lineWidth;
          }
          return 0;
        }
        drawGrid(chartArea) {
          const grid = this.options.grid;
          const ctx = this.ctx;
          const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
          let i, ilen;
          const drawLine = (p1, p2, style) => {
            if (!style.width || !style.color) {
              return;
            }
            ctx.save();
            ctx.lineWidth = style.width;
            ctx.strokeStyle = style.color;
            ctx.setLineDash(style.borderDash || []);
            ctx.lineDashOffset = style.borderDashOffset;
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
            ctx.restore();
          };
          if (grid.display) {
            for (i = 0, ilen = items.length; i < ilen; ++i) {
              const item = items[i];
              if (grid.drawOnChartArea) {
                drawLine({
                  x: item.x1,
                  y: item.y1
                }, {
                  x: item.x2,
                  y: item.y2
                }, item);
              }
              if (grid.drawTicks) {
                drawLine({
                  x: item.tx1,
                  y: item.ty1
                }, {
                  x: item.tx2,
                  y: item.ty2
                }, {
                  color: item.tickColor,
                  width: item.tickWidth,
                  borderDash: item.tickBorderDash,
                  borderDashOffset: item.tickBorderDashOffset
                });
              }
            }
          }
        }
        drawBorder() {
          const { chart, ctx, options: { border, grid } } = this;
          const borderOpts = border.setContext(this.getContext());
          const axisWidth = border.display ? borderOpts.width : 0;
          if (!axisWidth) {
            return;
          }
          const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
          const borderValue = this._borderValue;
          let x1, x2, y1, y2;
          if (this.isHorizontal()) {
            x1 = helpers_segment._alignPixel(chart, this.left, axisWidth) - axisWidth / 2;
            x2 = helpers_segment._alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;
            y1 = y2 = borderValue;
          } else {
            y1 = helpers_segment._alignPixel(chart, this.top, axisWidth) - axisWidth / 2;
            y2 = helpers_segment._alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
            x1 = x2 = borderValue;
          }
          ctx.save();
          ctx.lineWidth = borderOpts.width;
          ctx.strokeStyle = borderOpts.color;
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.stroke();
          ctx.restore();
        }
        drawLabels(chartArea) {
          const optionTicks = this.options.ticks;
          if (!optionTicks.display) {
            return;
          }
          const ctx = this.ctx;
          const area = this._computeLabelArea();
          if (area) {
            helpers_segment.clipArea(ctx, area);
          }
          const items = this.getLabelItems(chartArea);
          for (const item of items) {
            const renderTextOptions = item.options;
            const tickFont = item.font;
            const label = item.label;
            const y = item.textOffset;
            helpers_segment.renderText(ctx, label, 0, y, tickFont, renderTextOptions);
          }
          if (area) {
            helpers_segment.unclipArea(ctx);
          }
        }
        drawTitle() {
          const { ctx, options: { position, title, reverse } } = this;
          if (!title.display) {
            return;
          }
          const font = helpers_segment.toFont(title.font);
          const padding = helpers_segment.toPadding(title.padding);
          const align = title.align;
          let offset = font.lineHeight / 2;
          if (position === "bottom" || position === "center" || helpers_segment.isObject(position)) {
            offset += padding.bottom;
            if (helpers_segment.isArray(title.text)) {
              offset += font.lineHeight * (title.text.length - 1);
            }
          } else {
            offset += padding.top;
          }
          const { titleX, titleY, maxWidth, rotation } = titleArgs(this, offset, position, align);
          helpers_segment.renderText(ctx, title.text, 0, 0, font, {
            color: title.color,
            maxWidth,
            rotation,
            textAlign: titleAlign(align, position, reverse),
            textBaseline: "middle",
            translation: [
              titleX,
              titleY
            ]
          });
        }
        draw(chartArea) {
          if (!this._isVisible()) {
            return;
          }
          this.drawBackground();
          this.drawGrid(chartArea);
          this.drawBorder();
          this.drawTitle();
          this.drawLabels(chartArea);
        }
        _layers() {
          const opts = this.options;
          const tz = opts.ticks && opts.ticks.z || 0;
          const gz = helpers_segment.valueOrDefault(opts.grid && opts.grid.z, -1);
          const bz = helpers_segment.valueOrDefault(opts.border && opts.border.z, 0);
          if (!this._isVisible() || this.draw !== Scale.prototype.draw) {
            return [
              {
                z: tz,
                draw: (chartArea) => {
                  this.draw(chartArea);
                }
              }
            ];
          }
          return [
            {
              z: gz,
              draw: (chartArea) => {
                this.drawBackground();
                this.drawGrid(chartArea);
                this.drawTitle();
              }
            },
            {
              z: bz,
              draw: () => {
                this.drawBorder();
              }
            },
            {
              z: tz,
              draw: (chartArea) => {
                this.drawLabels(chartArea);
              }
            }
          ];
        }
        getMatchingVisibleMetas(type) {
          const metas = this.chart.getSortedVisibleDatasetMetas();
          const axisID = this.axis + "AxisID";
          const result = [];
          let i, ilen;
          for (i = 0, ilen = metas.length; i < ilen; ++i) {
            const meta = metas[i];
            if (meta[axisID] === this.id && (!type || meta.type === type)) {
              result.push(meta);
            }
          }
          return result;
        }
        _resolveTickFontOptions(index2) {
          const opts = this.options.ticks.setContext(this.getContext(index2));
          return helpers_segment.toFont(opts.font);
        }
        _maxDigits() {
          const fontSize = this._resolveTickFontOptions(0).lineHeight;
          return (this.isHorizontal() ? this.width : this.height) / fontSize;
        }
      };
      var TypedRegistry = class {
        constructor(type, scope, override) {
          this.type = type;
          this.scope = scope;
          this.override = override;
          this.items = /* @__PURE__ */ Object.create(null);
        }
        isForType(type) {
          return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
        }
        register(item) {
          const proto = Object.getPrototypeOf(item);
          let parentScope;
          if (isIChartComponent(proto)) {
            parentScope = this.register(proto);
          }
          const items = this.items;
          const id = item.id;
          const scope = this.scope + "." + id;
          if (!id) {
            throw new Error("class does not have id: " + item);
          }
          if (id in items) {
            return scope;
          }
          items[id] = item;
          registerDefaults(item, scope, parentScope);
          if (this.override) {
            helpers_segment.defaults.override(item.id, item.overrides);
          }
          return scope;
        }
        get(id) {
          return this.items[id];
        }
        unregister(item) {
          const items = this.items;
          const id = item.id;
          const scope = this.scope;
          if (id in items) {
            delete items[id];
          }
          if (scope && id in helpers_segment.defaults[scope]) {
            delete helpers_segment.defaults[scope][id];
            if (this.override) {
              delete helpers_segment.overrides[id];
            }
          }
        }
      };
      function registerDefaults(item, scope, parentScope) {
        const itemDefaults = helpers_segment.merge(/* @__PURE__ */ Object.create(null), [
          parentScope ? helpers_segment.defaults.get(parentScope) : {},
          helpers_segment.defaults.get(scope),
          item.defaults
        ]);
        helpers_segment.defaults.set(scope, itemDefaults);
        if (item.defaultRoutes) {
          routeDefaults(scope, item.defaultRoutes);
        }
        if (item.descriptors) {
          helpers_segment.defaults.describe(scope, item.descriptors);
        }
      }
      function routeDefaults(scope, routes) {
        Object.keys(routes).forEach((property) => {
          const propertyParts = property.split(".");
          const sourceName = propertyParts.pop();
          const sourceScope = [
            scope
          ].concat(propertyParts).join(".");
          const parts = routes[property].split(".");
          const targetName = parts.pop();
          const targetScope = parts.join(".");
          helpers_segment.defaults.route(sourceScope, sourceName, targetScope, targetName);
        });
      }
      function isIChartComponent(proto) {
        return "id" in proto && "defaults" in proto;
      }
      var Registry = class {
        constructor() {
          this.controllers = new TypedRegistry(DatasetController, "datasets", true);
          this.elements = new TypedRegistry(Element, "elements");
          this.plugins = new TypedRegistry(Object, "plugins");
          this.scales = new TypedRegistry(Scale, "scales");
          this._typedRegistries = [
            this.controllers,
            this.scales,
            this.elements
          ];
        }
        add(...args) {
          this._each("register", args);
        }
        remove(...args) {
          this._each("unregister", args);
        }
        addControllers(...args) {
          this._each("register", args, this.controllers);
        }
        addElements(...args) {
          this._each("register", args, this.elements);
        }
        addPlugins(...args) {
          this._each("register", args, this.plugins);
        }
        addScales(...args) {
          this._each("register", args, this.scales);
        }
        getController(id) {
          return this._get(id, this.controllers, "controller");
        }
        getElement(id) {
          return this._get(id, this.elements, "element");
        }
        getPlugin(id) {
          return this._get(id, this.plugins, "plugin");
        }
        getScale(id) {
          return this._get(id, this.scales, "scale");
        }
        removeControllers(...args) {
          this._each("unregister", args, this.controllers);
        }
        removeElements(...args) {
          this._each("unregister", args, this.elements);
        }
        removePlugins(...args) {
          this._each("unregister", args, this.plugins);
        }
        removeScales(...args) {
          this._each("unregister", args, this.scales);
        }
        _each(method, args, typedRegistry) {
          [
            ...args
          ].forEach((arg) => {
            const reg = typedRegistry || this._getRegistryForType(arg);
            if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {
              this._exec(method, reg, arg);
            } else {
              helpers_segment.each(arg, (item) => {
                const itemReg = typedRegistry || this._getRegistryForType(item);
                this._exec(method, itemReg, item);
              });
            }
          });
        }
        _exec(method, registry2, component) {
          const camelMethod = helpers_segment._capitalize(method);
          helpers_segment.callback(component["before" + camelMethod], [], component);
          registry2[method](component);
          helpers_segment.callback(component["after" + camelMethod], [], component);
        }
        _getRegistryForType(type) {
          for (let i = 0; i < this._typedRegistries.length; i++) {
            const reg = this._typedRegistries[i];
            if (reg.isForType(type)) {
              return reg;
            }
          }
          return this.plugins;
        }
        _get(id, typedRegistry, type) {
          const item = typedRegistry.get(id);
          if (item === void 0) {
            throw new Error('"' + id + '" is not a registered ' + type + ".");
          }
          return item;
        }
      };
      var registry = /* @__PURE__ */ new Registry();
      var PluginService = class {
        constructor() {
          this._init = [];
        }
        notify(chart, hook, args, filter) {
          if (hook === "beforeInit") {
            this._init = this._createDescriptors(chart, true);
            this._notify(this._init, chart, "install");
          }
          const descriptors = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);
          const result = this._notify(descriptors, chart, hook, args);
          if (hook === "afterDestroy") {
            this._notify(descriptors, chart, "stop");
            this._notify(this._init, chart, "uninstall");
          }
          return result;
        }
        _notify(descriptors, chart, hook, args) {
          args = args || {};
          for (const descriptor of descriptors) {
            const plugin = descriptor.plugin;
            const method = plugin[hook];
            const params = [
              chart,
              args,
              descriptor.options
            ];
            if (helpers_segment.callback(method, params, plugin) === false && args.cancelable) {
              return false;
            }
          }
          return true;
        }
        invalidate() {
          if (!helpers_segment.isNullOrUndef(this._cache)) {
            this._oldCache = this._cache;
            this._cache = void 0;
          }
        }
        _descriptors(chart) {
          if (this._cache) {
            return this._cache;
          }
          const descriptors = this._cache = this._createDescriptors(chart);
          this._notifyStateChanges(chart);
          return descriptors;
        }
        _createDescriptors(chart, all) {
          const config = chart && chart.config;
          const options = helpers_segment.valueOrDefault(config.options && config.options.plugins, {});
          const plugins2 = allPlugins(config);
          return options === false && !all ? [] : createDescriptors(chart, plugins2, options, all);
        }
        _notifyStateChanges(chart) {
          const previousDescriptors = this._oldCache || [];
          const descriptors = this._cache;
          const diff = (a, b) => a.filter((x) => !b.some((y) => x.plugin.id === y.plugin.id));
          this._notify(diff(previousDescriptors, descriptors), chart, "stop");
          this._notify(diff(descriptors, previousDescriptors), chart, "start");
        }
      };
      function allPlugins(config) {
        const localIds = {};
        const plugins2 = [];
        const keys = Object.keys(registry.plugins.items);
        for (let i = 0; i < keys.length; i++) {
          plugins2.push(registry.getPlugin(keys[i]));
        }
        const local = config.plugins || [];
        for (let i = 0; i < local.length; i++) {
          const plugin = local[i];
          if (plugins2.indexOf(plugin) === -1) {
            plugins2.push(plugin);
            localIds[plugin.id] = true;
          }
        }
        return {
          plugins: plugins2,
          localIds
        };
      }
      function getOpts(options, all) {
        if (!all && options === false) {
          return null;
        }
        if (options === true) {
          return {};
        }
        return options;
      }
      function createDescriptors(chart, { plugins: plugins2, localIds }, options, all) {
        const result = [];
        const context = chart.getContext();
        for (const plugin of plugins2) {
          const id = plugin.id;
          const opts = getOpts(options[id], all);
          if (opts === null) {
            continue;
          }
          result.push({
            plugin,
            options: pluginOpts(chart.config, {
              plugin,
              local: localIds[id]
            }, opts, context)
          });
        }
        return result;
      }
      function pluginOpts(config, { plugin, local }, opts, context) {
        const keys = config.pluginScopeKeys(plugin);
        const scopes = config.getOptionScopes(opts, keys);
        if (local && plugin.defaults) {
          scopes.push(plugin.defaults);
        }
        return config.createResolver(scopes, context, [
          ""
        ], {
          scriptable: false,
          indexable: false,
          allKeys: true
        });
      }
      function getIndexAxis(type, options) {
        const datasetDefaults = helpers_segment.defaults.datasets[type] || {};
        const datasetOptions = (options.datasets || {})[type] || {};
        return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || "x";
      }
      function getAxisFromDefaultScaleID(id, indexAxis) {
        let axis = id;
        if (id === "_index_") {
          axis = indexAxis;
        } else if (id === "_value_") {
          axis = indexAxis === "x" ? "y" : "x";
        }
        return axis;
      }
      function getDefaultScaleIDFromAxis(axis, indexAxis) {
        return axis === indexAxis ? "_index_" : "_value_";
      }
      function idMatchesAxis(id) {
        if (id === "x" || id === "y" || id === "r") {
          return id;
        }
      }
      function axisFromPosition(position) {
        if (position === "top" || position === "bottom") {
          return "x";
        }
        if (position === "left" || position === "right") {
          return "y";
        }
      }
      function determineAxis(id, ...scaleOptions) {
        if (idMatchesAxis(id)) {
          return id;
        }
        for (const opts of scaleOptions) {
          const axis = opts.axis || axisFromPosition(opts.position) || id.length > 1 && idMatchesAxis(id[0].toLowerCase());
          if (axis) {
            return axis;
          }
        }
        throw new Error(`Cannot determine type of '${id}' axis. Please provide 'axis' or 'position' option.`);
      }
      function getAxisFromDataset(id, axis, dataset) {
        if (dataset[axis + "AxisID"] === id) {
          return {
            axis
          };
        }
      }
      function retrieveAxisFromDatasets(id, config) {
        if (config.data && config.data.datasets) {
          const boundDs = config.data.datasets.filter((d) => d.xAxisID === id || d.yAxisID === id);
          if (boundDs.length) {
            return getAxisFromDataset(id, "x", boundDs[0]) || getAxisFromDataset(id, "y", boundDs[0]);
          }
        }
        return {};
      }
      function mergeScaleConfig(config, options) {
        const chartDefaults = helpers_segment.overrides[config.type] || {
          scales: {}
        };
        const configScales = options.scales || {};
        const chartIndexAxis = getIndexAxis(config.type, options);
        const scales2 = /* @__PURE__ */ Object.create(null);
        Object.keys(configScales).forEach((id) => {
          const scaleConf = configScales[id];
          if (!helpers_segment.isObject(scaleConf)) {
            return console.error(`Invalid scale configuration for scale: ${id}`);
          }
          if (scaleConf._proxy) {
            return console.warn(`Ignoring resolver passed as options for scale: ${id}`);
          }
          const axis = determineAxis(id, scaleConf, retrieveAxisFromDatasets(id, config), helpers_segment.defaults.scales[scaleConf.type]);
          const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
          const defaultScaleOptions = chartDefaults.scales || {};
          scales2[id] = helpers_segment.mergeIf(/* @__PURE__ */ Object.create(null), [
            {
              axis
            },
            scaleConf,
            defaultScaleOptions[axis],
            defaultScaleOptions[defaultId]
          ]);
        });
        config.data.datasets.forEach((dataset) => {
          const type = dataset.type || config.type;
          const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
          const datasetDefaults = helpers_segment.overrides[type] || {};
          const defaultScaleOptions = datasetDefaults.scales || {};
          Object.keys(defaultScaleOptions).forEach((defaultID) => {
            const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
            const id = dataset[axis + "AxisID"] || axis;
            scales2[id] = scales2[id] || /* @__PURE__ */ Object.create(null);
            helpers_segment.mergeIf(scales2[id], [
              {
                axis
              },
              configScales[id],
              defaultScaleOptions[defaultID]
            ]);
          });
        });
        Object.keys(scales2).forEach((key) => {
          const scale = scales2[key];
          helpers_segment.mergeIf(scale, [
            helpers_segment.defaults.scales[scale.type],
            helpers_segment.defaults.scale
          ]);
        });
        return scales2;
      }
      function initOptions(config) {
        const options = config.options || (config.options = {});
        options.plugins = helpers_segment.valueOrDefault(options.plugins, {});
        options.scales = mergeScaleConfig(config, options);
      }
      function initData(data) {
        data = data || {};
        data.datasets = data.datasets || [];
        data.labels = data.labels || [];
        return data;
      }
      function initConfig(config) {
        config = config || {};
        config.data = initData(config.data);
        initOptions(config);
        return config;
      }
      var keyCache = /* @__PURE__ */ new Map();
      var keysCached = /* @__PURE__ */ new Set();
      function cachedKeys(cacheKey, generate) {
        let keys = keyCache.get(cacheKey);
        if (!keys) {
          keys = generate();
          keyCache.set(cacheKey, keys);
          keysCached.add(keys);
        }
        return keys;
      }
      var addIfFound = (set, obj, key) => {
        const opts = helpers_segment.resolveObjectKey(obj, key);
        if (opts !== void 0) {
          set.add(opts);
        }
      };
      var Config = class {
        constructor(config) {
          this._config = initConfig(config);
          this._scopeCache = /* @__PURE__ */ new Map();
          this._resolverCache = /* @__PURE__ */ new Map();
        }
        get platform() {
          return this._config.platform;
        }
        get type() {
          return this._config.type;
        }
        set type(type) {
          this._config.type = type;
        }
        get data() {
          return this._config.data;
        }
        set data(data) {
          this._config.data = initData(data);
        }
        get options() {
          return this._config.options;
        }
        set options(options) {
          this._config.options = options;
        }
        get plugins() {
          return this._config.plugins;
        }
        update() {
          const config = this._config;
          this.clearCache();
          initOptions(config);
        }
        clearCache() {
          this._scopeCache.clear();
          this._resolverCache.clear();
        }
        datasetScopeKeys(datasetType) {
          return cachedKeys(datasetType, () => [
            [
              `datasets.${datasetType}`,
              ""
            ]
          ]);
        }
        datasetAnimationScopeKeys(datasetType, transition) {
          return cachedKeys(`${datasetType}.transition.${transition}`, () => [
            [
              `datasets.${datasetType}.transitions.${transition}`,
              `transitions.${transition}`
            ],
            [
              `datasets.${datasetType}`,
              ""
            ]
          ]);
        }
        datasetElementScopeKeys(datasetType, elementType) {
          return cachedKeys(`${datasetType}-${elementType}`, () => [
            [
              `datasets.${datasetType}.elements.${elementType}`,
              `datasets.${datasetType}`,
              `elements.${elementType}`,
              ""
            ]
          ]);
        }
        pluginScopeKeys(plugin) {
          const id = plugin.id;
          const type = this.type;
          return cachedKeys(`${type}-plugin-${id}`, () => [
            [
              `plugins.${id}`,
              ...plugin.additionalOptionScopes || []
            ]
          ]);
        }
        _cachedScopes(mainScope, resetCache) {
          const _scopeCache = this._scopeCache;
          let cache = _scopeCache.get(mainScope);
          if (!cache || resetCache) {
            cache = /* @__PURE__ */ new Map();
            _scopeCache.set(mainScope, cache);
          }
          return cache;
        }
        getOptionScopes(mainScope, keyLists, resetCache) {
          const { options, type } = this;
          const cache = this._cachedScopes(mainScope, resetCache);
          const cached = cache.get(keyLists);
          if (cached) {
            return cached;
          }
          const scopes = /* @__PURE__ */ new Set();
          keyLists.forEach((keys) => {
            if (mainScope) {
              scopes.add(mainScope);
              keys.forEach((key) => addIfFound(scopes, mainScope, key));
            }
            keys.forEach((key) => addIfFound(scopes, options, key));
            keys.forEach((key) => addIfFound(scopes, helpers_segment.overrides[type] || {}, key));
            keys.forEach((key) => addIfFound(scopes, helpers_segment.defaults, key));
            keys.forEach((key) => addIfFound(scopes, helpers_segment.descriptors, key));
          });
          const array = Array.from(scopes);
          if (array.length === 0) {
            array.push(/* @__PURE__ */ Object.create(null));
          }
          if (keysCached.has(keyLists)) {
            cache.set(keyLists, array);
          }
          return array;
        }
        chartOptionScopes() {
          const { options, type } = this;
          return [
            options,
            helpers_segment.overrides[type] || {},
            helpers_segment.defaults.datasets[type] || {},
            {
              type
            },
            helpers_segment.defaults,
            helpers_segment.descriptors
          ];
        }
        resolveNamedOptions(scopes, names, context, prefixes = [
          ""
        ]) {
          const result = {
            $shared: true
          };
          const { resolver, subPrefixes } = getResolver(this._resolverCache, scopes, prefixes);
          let options = resolver;
          if (needContext(resolver, names)) {
            result.$shared = false;
            context = helpers_segment.isFunction(context) ? context() : context;
            const subResolver = this.createResolver(scopes, context, subPrefixes);
            options = helpers_segment._attachContext(resolver, context, subResolver);
          }
          for (const prop of names) {
            result[prop] = options[prop];
          }
          return result;
        }
        createResolver(scopes, context, prefixes = [
          ""
        ], descriptorDefaults) {
          const { resolver } = getResolver(this._resolverCache, scopes, prefixes);
          return helpers_segment.isObject(context) ? helpers_segment._attachContext(resolver, context, void 0, descriptorDefaults) : resolver;
        }
      };
      function getResolver(resolverCache, scopes, prefixes) {
        let cache = resolverCache.get(scopes);
        if (!cache) {
          cache = /* @__PURE__ */ new Map();
          resolverCache.set(scopes, cache);
        }
        const cacheKey = prefixes.join();
        let cached = cache.get(cacheKey);
        if (!cached) {
          const resolver = helpers_segment._createResolver(scopes, prefixes);
          cached = {
            resolver,
            subPrefixes: prefixes.filter((p) => !p.toLowerCase().includes("hover"))
          };
          cache.set(cacheKey, cached);
        }
        return cached;
      }
      var hasFunction = (value) => helpers_segment.isObject(value) && Object.getOwnPropertyNames(value).reduce((acc, key) => acc || helpers_segment.isFunction(value[key]), false);
      function needContext(proxy, names) {
        const { isScriptable, isIndexable } = helpers_segment._descriptors(proxy);
        for (const prop of names) {
          const scriptable = isScriptable(prop);
          const indexable = isIndexable(prop);
          const value = (indexable || scriptable) && proxy[prop];
          if (scriptable && (helpers_segment.isFunction(value) || hasFunction(value)) || indexable && helpers_segment.isArray(value)) {
            return true;
          }
        }
        return false;
      }
      var version = "4.3.0";
      var KNOWN_POSITIONS = [
        "top",
        "bottom",
        "left",
        "right",
        "chartArea"
      ];
      function positionIsHorizontal(position, axis) {
        return position === "top" || position === "bottom" || KNOWN_POSITIONS.indexOf(position) === -1 && axis === "x";
      }
      function compare2Level(l1, l2) {
        return function(a, b) {
          return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
        };
      }
      function onAnimationsComplete(context) {
        const chart = context.chart;
        const animationOptions = chart.options.animation;
        chart.notifyPlugins("afterRender");
        helpers_segment.callback(animationOptions && animationOptions.onComplete, [
          context
        ], chart);
      }
      function onAnimationProgress(context) {
        const chart = context.chart;
        const animationOptions = chart.options.animation;
        helpers_segment.callback(animationOptions && animationOptions.onProgress, [
          context
        ], chart);
      }
      function getCanvas(item) {
        if (helpers_segment._isDomSupported() && typeof item === "string") {
          item = document.getElementById(item);
        } else if (item && item.length) {
          item = item[0];
        }
        if (item && item.canvas) {
          item = item.canvas;
        }
        return item;
      }
      var instances = {};
      var getChart = (key) => {
        const canvas = getCanvas(key);
        return Object.values(instances).filter((c) => c.canvas === canvas).pop();
      };
      function moveNumericKeys(obj, start, move) {
        const keys = Object.keys(obj);
        for (const key of keys) {
          const intKey = +key;
          if (intKey >= start) {
            const value = obj[key];
            delete obj[key];
            if (move > 0 || intKey > start) {
              obj[intKey + move] = value;
            }
          }
        }
      }
      function determineLastEvent(e, lastEvent, inChartArea, isClick) {
        if (!inChartArea || e.type === "mouseout") {
          return null;
        }
        if (isClick) {
          return lastEvent;
        }
        return e;
      }
      function getDatasetArea(meta) {
        const { xScale, yScale } = meta;
        if (xScale && yScale) {
          return {
            left: xScale.left,
            right: xScale.right,
            top: yScale.top,
            bottom: yScale.bottom
          };
        }
      }
      var Chart = class {
        static register(...items) {
          registry.add(...items);
          invalidatePlugins();
        }
        static unregister(...items) {
          registry.remove(...items);
          invalidatePlugins();
        }
        constructor(item, userConfig) {
          const config = this.config = new Config(userConfig);
          const initialCanvas = getCanvas(item);
          const existingChart = getChart(initialCanvas);
          if (existingChart) {
            throw new Error("Canvas is already in use. Chart with ID '" + existingChart.id + "' must be destroyed before the canvas with ID '" + existingChart.canvas.id + "' can be reused.");
          }
          const options = config.createResolver(config.chartOptionScopes(), this.getContext());
          this.platform = new (config.platform || _detectPlatform(initialCanvas))();
          this.platform.updateConfig(config);
          const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
          const canvas = context && context.canvas;
          const height = canvas && canvas.height;
          const width = canvas && canvas.width;
          this.id = helpers_segment.uid();
          this.ctx = context;
          this.canvas = canvas;
          this.width = width;
          this.height = height;
          this._options = options;
          this._aspectRatio = this.aspectRatio;
          this._layers = [];
          this._metasets = [];
          this._stacks = void 0;
          this.boxes = [];
          this.currentDevicePixelRatio = void 0;
          this.chartArea = void 0;
          this._active = [];
          this._lastEvent = void 0;
          this._listeners = {};
          this._responsiveListeners = void 0;
          this._sortedMetasets = [];
          this.scales = {};
          this._plugins = new PluginService();
          this.$proxies = {};
          this._hiddenIndices = {};
          this.attached = false;
          this._animationsDisabled = void 0;
          this.$context = void 0;
          this._doResize = helpers_segment.debounce((mode) => this.update(mode), options.resizeDelay || 0);
          this._dataChanges = [];
          instances[this.id] = this;
          if (!context || !canvas) {
            console.error("Failed to create chart: can't acquire context from the given item");
            return;
          }
          animator.listen(this, "complete", onAnimationsComplete);
          animator.listen(this, "progress", onAnimationProgress);
          this._initialize();
          if (this.attached) {
            this.update();
          }
        }
        get aspectRatio() {
          const { options: { aspectRatio, maintainAspectRatio }, width, height, _aspectRatio } = this;
          if (!helpers_segment.isNullOrUndef(aspectRatio)) {
            return aspectRatio;
          }
          if (maintainAspectRatio && _aspectRatio) {
            return _aspectRatio;
          }
          return height ? width / height : null;
        }
        get data() {
          return this.config.data;
        }
        set data(data) {
          this.config.data = data;
        }
        get options() {
          return this._options;
        }
        set options(options) {
          this.config.options = options;
        }
        get registry() {
          return registry;
        }
        _initialize() {
          this.notifyPlugins("beforeInit");
          if (this.options.responsive) {
            this.resize();
          } else {
            helpers_segment.retinaScale(this, this.options.devicePixelRatio);
          }
          this.bindEvents();
          this.notifyPlugins("afterInit");
          return this;
        }
        clear() {
          helpers_segment.clearCanvas(this.canvas, this.ctx);
          return this;
        }
        stop() {
          animator.stop(this);
          return this;
        }
        resize(width, height) {
          if (!animator.running(this)) {
            this._resize(width, height);
          } else {
            this._resizeBeforeDraw = {
              width,
              height
            };
          }
        }
        _resize(width, height) {
          const options = this.options;
          const canvas = this.canvas;
          const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
          const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
          const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
          const mode = this.width ? "resize" : "attach";
          this.width = newSize.width;
          this.height = newSize.height;
          this._aspectRatio = this.aspectRatio;
          if (!helpers_segment.retinaScale(this, newRatio, true)) {
            return;
          }
          this.notifyPlugins("resize", {
            size: newSize
          });
          helpers_segment.callback(options.onResize, [
            this,
            newSize
          ], this);
          if (this.attached) {
            if (this._doResize(mode)) {
              this.render();
            }
          }
        }
        ensureScalesHaveIDs() {
          const options = this.options;
          const scalesOptions = options.scales || {};
          helpers_segment.each(scalesOptions, (axisOptions, axisID) => {
            axisOptions.id = axisID;
          });
        }
        buildOrUpdateScales() {
          const options = this.options;
          const scaleOpts = options.scales;
          const scales2 = this.scales;
          const updated = Object.keys(scales2).reduce((obj, id) => {
            obj[id] = false;
            return obj;
          }, {});
          let items = [];
          if (scaleOpts) {
            items = items.concat(Object.keys(scaleOpts).map((id) => {
              const scaleOptions = scaleOpts[id];
              const axis = determineAxis(id, scaleOptions);
              const isRadial = axis === "r";
              const isHorizontal = axis === "x";
              return {
                options: scaleOptions,
                dposition: isRadial ? "chartArea" : isHorizontal ? "bottom" : "left",
                dtype: isRadial ? "radialLinear" : isHorizontal ? "category" : "linear"
              };
            }));
          }
          helpers_segment.each(items, (item) => {
            const scaleOptions = item.options;
            const id = scaleOptions.id;
            const axis = determineAxis(id, scaleOptions);
            const scaleType = helpers_segment.valueOrDefault(scaleOptions.type, item.dtype);
            if (scaleOptions.position === void 0 || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
              scaleOptions.position = item.dposition;
            }
            updated[id] = true;
            let scale = null;
            if (id in scales2 && scales2[id].type === scaleType) {
              scale = scales2[id];
            } else {
              const scaleClass = registry.getScale(scaleType);
              scale = new scaleClass({
                id,
                type: scaleType,
                ctx: this.ctx,
                chart: this
              });
              scales2[scale.id] = scale;
            }
            scale.init(scaleOptions, options);
          });
          helpers_segment.each(updated, (hasUpdated, id) => {
            if (!hasUpdated) {
              delete scales2[id];
            }
          });
          helpers_segment.each(scales2, (scale) => {
            layouts.configure(this, scale, scale.options);
            layouts.addBox(this, scale);
          });
        }
        _updateMetasets() {
          const metasets = this._metasets;
          const numData = this.data.datasets.length;
          const numMeta = metasets.length;
          metasets.sort((a, b) => a.index - b.index);
          if (numMeta > numData) {
            for (let i = numData; i < numMeta; ++i) {
              this._destroyDatasetMeta(i);
            }
            metasets.splice(numData, numMeta - numData);
          }
          this._sortedMetasets = metasets.slice(0).sort(compare2Level("order", "index"));
        }
        _removeUnreferencedMetasets() {
          const { _metasets: metasets, data: { datasets } } = this;
          if (metasets.length > datasets.length) {
            delete this._stacks;
          }
          metasets.forEach((meta, index2) => {
            if (datasets.filter((x) => x === meta._dataset).length === 0) {
              this._destroyDatasetMeta(index2);
            }
          });
        }
        buildOrUpdateControllers() {
          const newControllers = [];
          const datasets = this.data.datasets;
          let i, ilen;
          this._removeUnreferencedMetasets();
          for (i = 0, ilen = datasets.length; i < ilen; i++) {
            const dataset = datasets[i];
            let meta = this.getDatasetMeta(i);
            const type = dataset.type || this.config.type;
            if (meta.type && meta.type !== type) {
              this._destroyDatasetMeta(i);
              meta = this.getDatasetMeta(i);
            }
            meta.type = type;
            meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
            meta.order = dataset.order || 0;
            meta.index = i;
            meta.label = "" + dataset.label;
            meta.visible = this.isDatasetVisible(i);
            if (meta.controller) {
              meta.controller.updateIndex(i);
              meta.controller.linkScales();
            } else {
              const ControllerClass = registry.getController(type);
              const { datasetElementType, dataElementType } = helpers_segment.defaults.datasets[type];
              Object.assign(ControllerClass, {
                dataElementType: registry.getElement(dataElementType),
                datasetElementType: datasetElementType && registry.getElement(datasetElementType)
              });
              meta.controller = new ControllerClass(this, i);
              newControllers.push(meta.controller);
            }
          }
          this._updateMetasets();
          return newControllers;
        }
        _resetElements() {
          helpers_segment.each(this.data.datasets, (dataset, datasetIndex) => {
            this.getDatasetMeta(datasetIndex).controller.reset();
          }, this);
        }
        reset() {
          this._resetElements();
          this.notifyPlugins("reset");
        }
        update(mode) {
          const config = this.config;
          config.update();
          const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
          const animsDisabled = this._animationsDisabled = !options.animation;
          this._updateScales();
          this._checkEventBindings();
          this._updateHiddenIndices();
          this._plugins.invalidate();
          if (this.notifyPlugins("beforeUpdate", {
            mode,
            cancelable: true
          }) === false) {
            return;
          }
          const newControllers = this.buildOrUpdateControllers();
          this.notifyPlugins("beforeElementsUpdate");
          let minPadding = 0;
          for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {
            const { controller } = this.getDatasetMeta(i);
            const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
            controller.buildOrUpdateElements(reset);
            minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
          }
          minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
          this._updateLayout(minPadding);
          if (!animsDisabled) {
            helpers_segment.each(newControllers, (controller) => {
              controller.reset();
            });
          }
          this._updateDatasets(mode);
          this.notifyPlugins("afterUpdate", {
            mode
          });
          this._layers.sort(compare2Level("z", "_idx"));
          const { _active, _lastEvent } = this;
          if (_lastEvent) {
            this._eventHandler(_lastEvent, true);
          } else if (_active.length) {
            this._updateHoverStyles(_active, _active, true);
          }
          this.render();
        }
        _updateScales() {
          helpers_segment.each(this.scales, (scale) => {
            layouts.removeBox(this, scale);
          });
          this.ensureScalesHaveIDs();
          this.buildOrUpdateScales();
        }
        _checkEventBindings() {
          const options = this.options;
          const existingEvents = new Set(Object.keys(this._listeners));
          const newEvents = new Set(options.events);
          if (!helpers_segment.setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
            this.unbindEvents();
            this.bindEvents();
          }
        }
        _updateHiddenIndices() {
          const { _hiddenIndices } = this;
          const changes = this._getUniformDataChanges() || [];
          for (const { method, start, count } of changes) {
            const move = method === "_removeElements" ? -count : count;
            moveNumericKeys(_hiddenIndices, start, move);
          }
        }
        _getUniformDataChanges() {
          const _dataChanges = this._dataChanges;
          if (!_dataChanges || !_dataChanges.length) {
            return;
          }
          this._dataChanges = [];
          const datasetCount = this.data.datasets.length;
          const makeSet = (idx) => new Set(_dataChanges.filter((c) => c[0] === idx).map((c, i) => i + "," + c.splice(1).join(",")));
          const changeSet = makeSet(0);
          for (let i = 1; i < datasetCount; i++) {
            if (!helpers_segment.setsEqual(changeSet, makeSet(i))) {
              return;
            }
          }
          return Array.from(changeSet).map((c) => c.split(",")).map((a) => ({
            method: a[1],
            start: +a[2],
            count: +a[3]
          }));
        }
        _updateLayout(minPadding) {
          if (this.notifyPlugins("beforeLayout", {
            cancelable: true
          }) === false) {
            return;
          }
          layouts.update(this, this.width, this.height, minPadding);
          const area = this.chartArea;
          const noArea = area.width <= 0 || area.height <= 0;
          this._layers = [];
          helpers_segment.each(this.boxes, (box) => {
            if (noArea && box.position === "chartArea") {
              return;
            }
            if (box.configure) {
              box.configure();
            }
            this._layers.push(...box._layers());
          }, this);
          this._layers.forEach((item, index2) => {
            item._idx = index2;
          });
          this.notifyPlugins("afterLayout");
        }
        _updateDatasets(mode) {
          if (this.notifyPlugins("beforeDatasetsUpdate", {
            mode,
            cancelable: true
          }) === false) {
            return;
          }
          for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
            this.getDatasetMeta(i).controller.configure();
          }
          for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
            this._updateDataset(i, helpers_segment.isFunction(mode) ? mode({
              datasetIndex: i
            }) : mode);
          }
          this.notifyPlugins("afterDatasetsUpdate", {
            mode
          });
        }
        _updateDataset(index2, mode) {
          const meta = this.getDatasetMeta(index2);
          const args = {
            meta,
            index: index2,
            mode,
            cancelable: true
          };
          if (this.notifyPlugins("beforeDatasetUpdate", args) === false) {
            return;
          }
          meta.controller._update(mode);
          args.cancelable = false;
          this.notifyPlugins("afterDatasetUpdate", args);
        }
        render() {
          if (this.notifyPlugins("beforeRender", {
            cancelable: true
          }) === false) {
            return;
          }
          if (animator.has(this)) {
            if (this.attached && !animator.running(this)) {
              animator.start(this);
            }
          } else {
            this.draw();
            onAnimationsComplete({
              chart: this
            });
          }
        }
        draw() {
          let i;
          if (this._resizeBeforeDraw) {
            const { width, height } = this._resizeBeforeDraw;
            this._resize(width, height);
            this._resizeBeforeDraw = null;
          }
          this.clear();
          if (this.width <= 0 || this.height <= 0) {
            return;
          }
          if (this.notifyPlugins("beforeDraw", {
            cancelable: true
          }) === false) {
            return;
          }
          const layers = this._layers;
          for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {
            layers[i].draw(this.chartArea);
          }
          this._drawDatasets();
          for (; i < layers.length; ++i) {
            layers[i].draw(this.chartArea);
          }
          this.notifyPlugins("afterDraw");
        }
        _getSortedDatasetMetas(filterVisible) {
          const metasets = this._sortedMetasets;
          const result = [];
          let i, ilen;
          for (i = 0, ilen = metasets.length; i < ilen; ++i) {
            const meta = metasets[i];
            if (!filterVisible || meta.visible) {
              result.push(meta);
            }
          }
          return result;
        }
        getSortedVisibleDatasetMetas() {
          return this._getSortedDatasetMetas(true);
        }
        _drawDatasets() {
          if (this.notifyPlugins("beforeDatasetsDraw", {
            cancelable: true
          }) === false) {
            return;
          }
          const metasets = this.getSortedVisibleDatasetMetas();
          for (let i = metasets.length - 1; i >= 0; --i) {
            this._drawDataset(metasets[i]);
          }
          this.notifyPlugins("afterDatasetsDraw");
        }
        _drawDataset(meta) {
          const ctx = this.ctx;
          const clip = meta._clip;
          const useClip = !clip.disabled;
          const area = getDatasetArea(meta) || this.chartArea;
          const args = {
            meta,
            index: meta.index,
            cancelable: true
          };
          if (this.notifyPlugins("beforeDatasetDraw", args) === false) {
            return;
          }
          if (useClip) {
            helpers_segment.clipArea(ctx, {
              left: clip.left === false ? 0 : area.left - clip.left,
              right: clip.right === false ? this.width : area.right + clip.right,
              top: clip.top === false ? 0 : area.top - clip.top,
              bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom
            });
          }
          meta.controller.draw();
          if (useClip) {
            helpers_segment.unclipArea(ctx);
          }
          args.cancelable = false;
          this.notifyPlugins("afterDatasetDraw", args);
        }
        isPointInArea(point) {
          return helpers_segment._isPointInArea(point, this.chartArea, this._minPadding);
        }
        getElementsAtEventForMode(e, mode, options, useFinalPosition) {
          const method = Interaction.modes[mode];
          if (typeof method === "function") {
            return method(this, e, options, useFinalPosition);
          }
          return [];
        }
        getDatasetMeta(datasetIndex) {
          const dataset = this.data.datasets[datasetIndex];
          const metasets = this._metasets;
          let meta = metasets.filter((x) => x && x._dataset === dataset).pop();
          if (!meta) {
            meta = {
              type: null,
              data: [],
              dataset: null,
              controller: null,
              hidden: null,
              xAxisID: null,
              yAxisID: null,
              order: dataset && dataset.order || 0,
              index: datasetIndex,
              _dataset: dataset,
              _parsed: [],
              _sorted: false
            };
            metasets.push(meta);
          }
          return meta;
        }
        getContext() {
          return this.$context || (this.$context = helpers_segment.createContext(null, {
            chart: this,
            type: "chart"
          }));
        }
        getVisibleDatasetCount() {
          return this.getSortedVisibleDatasetMetas().length;
        }
        isDatasetVisible(datasetIndex) {
          const dataset = this.data.datasets[datasetIndex];
          if (!dataset) {
            return false;
          }
          const meta = this.getDatasetMeta(datasetIndex);
          return typeof meta.hidden === "boolean" ? !meta.hidden : !dataset.hidden;
        }
        setDatasetVisibility(datasetIndex, visible) {
          const meta = this.getDatasetMeta(datasetIndex);
          meta.hidden = !visible;
        }
        toggleDataVisibility(index2) {
          this._hiddenIndices[index2] = !this._hiddenIndices[index2];
        }
        getDataVisibility(index2) {
          return !this._hiddenIndices[index2];
        }
        _updateVisibility(datasetIndex, dataIndex, visible) {
          const mode = visible ? "show" : "hide";
          const meta = this.getDatasetMeta(datasetIndex);
          const anims = meta.controller._resolveAnimations(void 0, mode);
          if (helpers_segment.defined(dataIndex)) {
            meta.data[dataIndex].hidden = !visible;
            this.update();
          } else {
            this.setDatasetVisibility(datasetIndex, visible);
            anims.update(meta, {
              visible
            });
            this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : void 0);
          }
        }
        hide(datasetIndex, dataIndex) {
          this._updateVisibility(datasetIndex, dataIndex, false);
        }
        show(datasetIndex, dataIndex) {
          this._updateVisibility(datasetIndex, dataIndex, true);
        }
        _destroyDatasetMeta(datasetIndex) {
          const meta = this._metasets[datasetIndex];
          if (meta && meta.controller) {
            meta.controller._destroy();
          }
          delete this._metasets[datasetIndex];
        }
        _stop() {
          let i, ilen;
          this.stop();
          animator.remove(this);
          for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
            this._destroyDatasetMeta(i);
          }
        }
        destroy() {
          this.notifyPlugins("beforeDestroy");
          const { canvas, ctx } = this;
          this._stop();
          this.config.clearCache();
          if (canvas) {
            this.unbindEvents();
            helpers_segment.clearCanvas(canvas, ctx);
            this.platform.releaseContext(ctx);
            this.canvas = null;
            this.ctx = null;
          }
          delete instances[this.id];
          this.notifyPlugins("afterDestroy");
        }
        toBase64Image(...args) {
          return this.canvas.toDataURL(...args);
        }
        bindEvents() {
          this.bindUserEvents();
          if (this.options.responsive) {
            this.bindResponsiveEvents();
          } else {
            this.attached = true;
          }
        }
        bindUserEvents() {
          const listeners = this._listeners;
          const platform = this.platform;
          const _add = (type, listener2) => {
            platform.addEventListener(this, type, listener2);
            listeners[type] = listener2;
          };
          const listener = (e, x, y) => {
            e.offsetX = x;
            e.offsetY = y;
            this._eventHandler(e);
          };
          helpers_segment.each(this.options.events, (type) => _add(type, listener));
        }
        bindResponsiveEvents() {
          if (!this._responsiveListeners) {
            this._responsiveListeners = {};
          }
          const listeners = this._responsiveListeners;
          const platform = this.platform;
          const _add = (type, listener2) => {
            platform.addEventListener(this, type, listener2);
            listeners[type] = listener2;
          };
          const _remove = (type, listener2) => {
            if (listeners[type]) {
              platform.removeEventListener(this, type, listener2);
              delete listeners[type];
            }
          };
          const listener = (width, height) => {
            if (this.canvas) {
              this.resize(width, height);
            }
          };
          let detached;
          const attached = () => {
            _remove("attach", attached);
            this.attached = true;
            this.resize();
            _add("resize", listener);
            _add("detach", detached);
          };
          detached = () => {
            this.attached = false;
            _remove("resize", listener);
            this._stop();
            this._resize(0, 0);
            _add("attach", attached);
          };
          if (platform.isAttached(this.canvas)) {
            attached();
          } else {
            detached();
          }
        }
        unbindEvents() {
          helpers_segment.each(this._listeners, (listener, type) => {
            this.platform.removeEventListener(this, type, listener);
          });
          this._listeners = {};
          helpers_segment.each(this._responsiveListeners, (listener, type) => {
            this.platform.removeEventListener(this, type, listener);
          });
          this._responsiveListeners = void 0;
        }
        updateHoverStyle(items, mode, enabled) {
          const prefix = enabled ? "set" : "remove";
          let meta, item, i, ilen;
          if (mode === "dataset") {
            meta = this.getDatasetMeta(items[0].datasetIndex);
            meta.controller["_" + prefix + "DatasetHoverStyle"]();
          }
          for (i = 0, ilen = items.length; i < ilen; ++i) {
            item = items[i];
            const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
            if (controller) {
              controller[prefix + "HoverStyle"](item.element, item.datasetIndex, item.index);
            }
          }
        }
        getActiveElements() {
          return this._active || [];
        }
        setActiveElements(activeElements) {
          const lastActive = this._active || [];
          const active = activeElements.map(({ datasetIndex, index: index2 }) => {
            const meta = this.getDatasetMeta(datasetIndex);
            if (!meta) {
              throw new Error("No dataset found at index " + datasetIndex);
            }
            return {
              datasetIndex,
              element: meta.data[index2],
              index: index2
            };
          });
          const changed = !helpers_segment._elementsEqual(active, lastActive);
          if (changed) {
            this._active = active;
            this._lastEvent = null;
            this._updateHoverStyles(active, lastActive);
          }
        }
        notifyPlugins(hook, args, filter) {
          return this._plugins.notify(this, hook, args, filter);
        }
        isPluginEnabled(pluginId) {
          return this._plugins._cache.filter((p) => p.plugin.id === pluginId).length === 1;
        }
        _updateHoverStyles(active, lastActive, replay) {
          const hoverOptions = this.options.hover;
          const diff = (a, b) => a.filter((x) => !b.some((y) => x.datasetIndex === y.datasetIndex && x.index === y.index));
          const deactivated = diff(lastActive, active);
          const activated = replay ? active : diff(active, lastActive);
          if (deactivated.length) {
            this.updateHoverStyle(deactivated, hoverOptions.mode, false);
          }
          if (activated.length && hoverOptions.mode) {
            this.updateHoverStyle(activated, hoverOptions.mode, true);
          }
        }
        _eventHandler(e, replay) {
          const args = {
            event: e,
            replay,
            cancelable: true,
            inChartArea: this.isPointInArea(e)
          };
          const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.native.type);
          if (this.notifyPlugins("beforeEvent", args, eventFilter) === false) {
            return;
          }
          const changed = this._handleEvent(e, replay, args.inChartArea);
          args.cancelable = false;
          this.notifyPlugins("afterEvent", args, eventFilter);
          if (changed || args.changed) {
            this.render();
          }
          return this;
        }
        _handleEvent(e, replay, inChartArea) {
          const { _active: lastActive = [], options } = this;
          const useFinalPosition = replay;
          const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);
          const isClick = helpers_segment._isClickEvent(e);
          const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);
          if (inChartArea) {
            this._lastEvent = null;
            helpers_segment.callback(options.onHover, [
              e,
              active,
              this
            ], this);
            if (isClick) {
              helpers_segment.callback(options.onClick, [
                e,
                active,
                this
              ], this);
            }
          }
          const changed = !helpers_segment._elementsEqual(active, lastActive);
          if (changed || replay) {
            this._active = active;
            this._updateHoverStyles(active, lastActive, replay);
          }
          this._lastEvent = lastEvent;
          return changed;
        }
        _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {
          if (e.type === "mouseout") {
            return [];
          }
          if (!inChartArea) {
            return lastActive;
          }
          const hoverOptions = this.options.hover;
          return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);
        }
      };
      __publicField(Chart, "defaults", helpers_segment.defaults);
      __publicField(Chart, "instances", instances);
      __publicField(Chart, "overrides", helpers_segment.overrides);
      __publicField(Chart, "registry", registry);
      __publicField(Chart, "version", version);
      __publicField(Chart, "getChart", getChart);
      function invalidatePlugins() {
        return helpers_segment.each(Chart.instances, (chart) => chart._plugins.invalidate());
      }
      function clipArc(ctx, element, endAngle) {
        const { startAngle, pixelMargin, x, y, outerRadius, innerRadius } = element;
        let angleMargin = pixelMargin / outerRadius;
        ctx.beginPath();
        ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
        if (innerRadius > pixelMargin) {
          angleMargin = pixelMargin / innerRadius;
          ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
        } else {
          ctx.arc(x, y, pixelMargin, endAngle + helpers_segment.HALF_PI, startAngle - helpers_segment.HALF_PI);
        }
        ctx.closePath();
        ctx.clip();
      }
      function toRadiusCorners(value) {
        return helpers_segment._readValueToProps(value, [
          "outerStart",
          "outerEnd",
          "innerStart",
          "innerEnd"
        ]);
      }
      function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
        const o = toRadiusCorners(arc.options.borderRadius);
        const halfThickness = (outerRadius - innerRadius) / 2;
        const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
        const computeOuterLimit = (val) => {
          const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
          return helpers_segment._limitValue(val, 0, Math.min(halfThickness, outerArcLimit));
        };
        return {
          outerStart: computeOuterLimit(o.outerStart),
          outerEnd: computeOuterLimit(o.outerEnd),
          innerStart: helpers_segment._limitValue(o.innerStart, 0, innerLimit),
          innerEnd: helpers_segment._limitValue(o.innerEnd, 0, innerLimit)
        };
      }
      function rThetaToXY(r, theta, x, y) {
        return {
          x: x + r * Math.cos(theta),
          y: y + r * Math.sin(theta)
        };
      }
      function pathArc(ctx, element, offset, spacing, end, circular) {
        const { x, y, startAngle: start, pixelMargin, innerRadius: innerR } = element;
        const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);
        const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;
        let spacingOffset = 0;
        const alpha = end - start;
        if (spacing) {
          const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
          const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
          const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
          const adjustedAngle = avNogSpacingRadius !== 0 ? alpha * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha;
          spacingOffset = (alpha - adjustedAngle) / 2;
        }
        const beta = Math.max(1e-3, alpha * outerRadius - offset / helpers_segment.PI) / outerRadius;
        const angleOffset = (alpha - beta) / 2;
        const startAngle = start + angleOffset + spacingOffset;
        const endAngle = end - angleOffset - spacingOffset;
        const { outerStart, outerEnd, innerStart, innerEnd } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);
        const outerStartAdjustedRadius = outerRadius - outerStart;
        const outerEndAdjustedRadius = outerRadius - outerEnd;
        const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
        const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
        const innerStartAdjustedRadius = innerRadius + innerStart;
        const innerEndAdjustedRadius = innerRadius + innerEnd;
        const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
        const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
        ctx.beginPath();
        if (circular) {
          const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;
          ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);
          ctx.arc(x, y, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);
          if (outerEnd > 0) {
            const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);
            ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + helpers_segment.HALF_PI);
          }
          const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);
          ctx.lineTo(p4.x, p4.y);
          if (innerEnd > 0) {
            const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);
            ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + helpers_segment.HALF_PI, innerEndAdjustedAngle + Math.PI);
          }
          const innerMidAdjustedAngle = (endAngle - innerEnd / innerRadius + (startAngle + innerStart / innerRadius)) / 2;
          ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, innerMidAdjustedAngle, true);
          ctx.arc(x, y, innerRadius, innerMidAdjustedAngle, startAngle + innerStart / innerRadius, true);
          if (innerStart > 0) {
            const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);
            ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - helpers_segment.HALF_PI);
          }
          const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);
          ctx.lineTo(p8.x, p8.y);
          if (outerStart > 0) {
            const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);
            ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - helpers_segment.HALF_PI, outerStartAdjustedAngle);
          }
        } else {
          ctx.moveTo(x, y);
          const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;
          const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;
          ctx.lineTo(outerStartX, outerStartY);
          const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;
          const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;
          ctx.lineTo(outerEndX, outerEndY);
        }
        ctx.closePath();
      }
      function drawArc(ctx, element, offset, spacing, circular) {
        const { fullCircles, startAngle, circumference } = element;
        let endAngle = element.endAngle;
        if (fullCircles) {
          pathArc(ctx, element, offset, spacing, endAngle, circular);
          for (let i = 0; i < fullCircles; ++i) {
            ctx.fill();
          }
          if (!isNaN(circumference)) {
            endAngle = startAngle + (circumference % helpers_segment.TAU || helpers_segment.TAU);
          }
        }
        pathArc(ctx, element, offset, spacing, endAngle, circular);
        ctx.fill();
        return endAngle;
      }
      function drawBorder(ctx, element, offset, spacing, circular) {
        const { fullCircles, startAngle, circumference, options } = element;
        const { borderWidth, borderJoinStyle, borderDash, borderDashOffset } = options;
        const inner = options.borderAlign === "inner";
        if (!borderWidth) {
          return;
        }
        ctx.setLineDash(borderDash || []);
        ctx.lineDashOffset = borderDashOffset;
        if (inner) {
          ctx.lineWidth = borderWidth * 2;
          ctx.lineJoin = borderJoinStyle || "round";
        } else {
          ctx.lineWidth = borderWidth;
          ctx.lineJoin = borderJoinStyle || "bevel";
        }
        let endAngle = element.endAngle;
        if (fullCircles) {
          pathArc(ctx, element, offset, spacing, endAngle, circular);
          for (let i = 0; i < fullCircles; ++i) {
            ctx.stroke();
          }
          if (!isNaN(circumference)) {
            endAngle = startAngle + (circumference % helpers_segment.TAU || helpers_segment.TAU);
          }
        }
        if (inner) {
          clipArc(ctx, element, endAngle);
        }
        if (!fullCircles) {
          pathArc(ctx, element, offset, spacing, endAngle, circular);
          ctx.stroke();
        }
      }
      var ArcElement = class extends Element {
        circumference;
        endAngle;
        fullCircles;
        innerRadius;
        outerRadius;
        pixelMargin;
        startAngle;
        constructor(cfg) {
          super();
          this.options = void 0;
          this.circumference = void 0;
          this.startAngle = void 0;
          this.endAngle = void 0;
          this.innerRadius = void 0;
          this.outerRadius = void 0;
          this.pixelMargin = 0;
          this.fullCircles = 0;
          if (cfg) {
            Object.assign(this, cfg);
          }
        }
        inRange(chartX, chartY, useFinalPosition) {
          const point = this.getProps([
            "x",
            "y"
          ], useFinalPosition);
          const { angle, distance } = helpers_segment.getAngleFromPoint(point, {
            x: chartX,
            y: chartY
          });
          const { startAngle, endAngle, innerRadius, outerRadius, circumference } = this.getProps([
            "startAngle",
            "endAngle",
            "innerRadius",
            "outerRadius",
            "circumference"
          ], useFinalPosition);
          const rAdjust = (this.options.spacing + this.options.borderWidth) / 2;
          const _circumference = helpers_segment.valueOrDefault(circumference, endAngle - startAngle);
          const betweenAngles = _circumference >= helpers_segment.TAU || helpers_segment._angleBetween(angle, startAngle, endAngle);
          const withinRadius = helpers_segment._isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);
          return betweenAngles && withinRadius;
        }
        getCenterPoint(useFinalPosition) {
          const { x, y, startAngle, endAngle, innerRadius, outerRadius } = this.getProps([
            "x",
            "y",
            "startAngle",
            "endAngle",
            "innerRadius",
            "outerRadius"
          ], useFinalPosition);
          const { offset, spacing } = this.options;
          const halfAngle = (startAngle + endAngle) / 2;
          const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;
          return {
            x: x + Math.cos(halfAngle) * halfRadius,
            y: y + Math.sin(halfAngle) * halfRadius
          };
        }
        tooltipPosition(useFinalPosition) {
          return this.getCenterPoint(useFinalPosition);
        }
        draw(ctx) {
          const { options, circumference } = this;
          const offset = (options.offset || 0) / 4;
          const spacing = (options.spacing || 0) / 2;
          const circular = options.circular;
          this.pixelMargin = options.borderAlign === "inner" ? 0.33 : 0;
          this.fullCircles = circumference > helpers_segment.TAU ? Math.floor(circumference / helpers_segment.TAU) : 0;
          if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {
            return;
          }
          ctx.save();
          const halfAngle = (this.startAngle + this.endAngle) / 2;
          ctx.translate(Math.cos(halfAngle) * offset, Math.sin(halfAngle) * offset);
          const fix = 1 - Math.sin(Math.min(helpers_segment.PI, circumference || 0));
          const radiusOffset = offset * fix;
          ctx.fillStyle = options.backgroundColor;
          ctx.strokeStyle = options.borderColor;
          drawArc(ctx, this, radiusOffset, spacing, circular);
          drawBorder(ctx, this, radiusOffset, spacing, circular);
          ctx.restore();
        }
      };
      __publicField(ArcElement, "id", "arc");
      __publicField(ArcElement, "defaults", {
        borderAlign: "center",
        borderColor: "#fff",
        borderDash: [],
        borderDashOffset: 0,
        borderJoinStyle: void 0,
        borderRadius: 0,
        borderWidth: 2,
        offset: 0,
        spacing: 0,
        angle: void 0,
        circular: true
      });
      __publicField(ArcElement, "defaultRoutes", {
        backgroundColor: "backgroundColor"
      });
      __publicField(ArcElement, "descriptors", {
        _scriptable: true,
        _indexable: (name) => name !== "borderDash"
      });
      function setStyle(ctx, options, style = options) {
        ctx.lineCap = helpers_segment.valueOrDefault(style.borderCapStyle, options.borderCapStyle);
        ctx.setLineDash(helpers_segment.valueOrDefault(style.borderDash, options.borderDash));
        ctx.lineDashOffset = helpers_segment.valueOrDefault(style.borderDashOffset, options.borderDashOffset);
        ctx.lineJoin = helpers_segment.valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);
        ctx.lineWidth = helpers_segment.valueOrDefault(style.borderWidth, options.borderWidth);
        ctx.strokeStyle = helpers_segment.valueOrDefault(style.borderColor, options.borderColor);
      }
      function lineTo(ctx, previous, target) {
        ctx.lineTo(target.x, target.y);
      }
      function getLineMethod(options) {
        if (options.stepped) {
          return helpers_segment._steppedLineTo;
        }
        if (options.tension || options.cubicInterpolationMode === "monotone") {
          return helpers_segment._bezierCurveTo;
        }
        return lineTo;
      }
      function pathVars(points, segment, params = {}) {
        const count = points.length;
        const { start: paramsStart = 0, end: paramsEnd = count - 1 } = params;
        const { start: segmentStart, end: segmentEnd } = segment;
        const start = Math.max(paramsStart, segmentStart);
        const end = Math.min(paramsEnd, segmentEnd);
        const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
        return {
          count,
          start,
          loop: segment.loop,
          ilen: end < start && !outside ? count + end - start : end - start
        };
      }
      function pathSegment(ctx, line, segment, params) {
        const { points, options } = line;
        const { count, start, loop, ilen } = pathVars(points, segment, params);
        const lineMethod = getLineMethod(options);
        let { move = true, reverse } = params || {};
        let i, point, prev;
        for (i = 0; i <= ilen; ++i) {
          point = points[(start + (reverse ? ilen - i : i)) % count];
          if (point.skip) {
            continue;
          } else if (move) {
            ctx.moveTo(point.x, point.y);
            move = false;
          } else {
            lineMethod(ctx, prev, point, reverse, options.stepped);
          }
          prev = point;
        }
        if (loop) {
          point = points[(start + (reverse ? ilen : 0)) % count];
          lineMethod(ctx, prev, point, reverse, options.stepped);
        }
        return !!loop;
      }
      function fastPathSegment(ctx, line, segment, params) {
        const points = line.points;
        const { count, start, ilen } = pathVars(points, segment, params);
        const { move = true, reverse } = params || {};
        let avgX = 0;
        let countX = 0;
        let i, point, prevX, minY, maxY, lastY;
        const pointIndex = (index2) => (start + (reverse ? ilen - index2 : index2)) % count;
        const drawX = () => {
          if (minY !== maxY) {
            ctx.lineTo(avgX, maxY);
            ctx.lineTo(avgX, minY);
            ctx.lineTo(avgX, lastY);
          }
        };
        if (move) {
          point = points[pointIndex(0)];
          ctx.moveTo(point.x, point.y);
        }
        for (i = 0; i <= ilen; ++i) {
          point = points[pointIndex(i)];
          if (point.skip) {
            continue;
          }
          const x = point.x;
          const y = point.y;
          const truncX = x | 0;
          if (truncX === prevX) {
            if (y < minY) {
              minY = y;
            } else if (y > maxY) {
              maxY = y;
            }
            avgX = (countX * avgX + x) / ++countX;
          } else {
            drawX();
            ctx.lineTo(x, y);
            prevX = truncX;
            countX = 0;
            minY = maxY = y;
          }
          lastY = y;
        }
        drawX();
      }
      function _getSegmentMethod(line) {
        const opts = line.options;
        const borderDash = opts.borderDash && opts.borderDash.length;
        const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== "monotone" && !opts.stepped && !borderDash;
        return useFastPath ? fastPathSegment : pathSegment;
      }
      function _getInterpolationMethod(options) {
        if (options.stepped) {
          return helpers_segment._steppedInterpolation;
        }
        if (options.tension || options.cubicInterpolationMode === "monotone") {
          return helpers_segment._bezierInterpolation;
        }
        return helpers_segment._pointInLine;
      }
      function strokePathWithCache(ctx, line, start, count) {
        let path = line._path;
        if (!path) {
          path = line._path = new Path2D();
          if (line.path(path, start, count)) {
            path.closePath();
          }
        }
        setStyle(ctx, line.options);
        ctx.stroke(path);
      }
      function strokePathDirect(ctx, line, start, count) {
        const { segments, options } = line;
        const segmentMethod = _getSegmentMethod(line);
        for (const segment of segments) {
          setStyle(ctx, options, segment.style);
          ctx.beginPath();
          if (segmentMethod(ctx, line, segment, {
            start,
            end: start + count - 1
          })) {
            ctx.closePath();
          }
          ctx.stroke();
        }
      }
      var usePath2D = typeof Path2D === "function";
      function draw(ctx, line, start, count) {
        if (usePath2D && !line.options.segment) {
          strokePathWithCache(ctx, line, start, count);
        } else {
          strokePathDirect(ctx, line, start, count);
        }
      }
      var LineElement = class extends Element {
        constructor(cfg) {
          super();
          this.animated = true;
          this.options = void 0;
          this._chart = void 0;
          this._loop = void 0;
          this._fullLoop = void 0;
          this._path = void 0;
          this._points = void 0;
          this._segments = void 0;
          this._decimated = false;
          this._pointsUpdated = false;
          this._datasetIndex = void 0;
          if (cfg) {
            Object.assign(this, cfg);
          }
        }
        updateControlPoints(chartArea, indexAxis) {
          const options = this.options;
          if ((options.tension || options.cubicInterpolationMode === "monotone") && !options.stepped && !this._pointsUpdated) {
            const loop = options.spanGaps ? this._loop : this._fullLoop;
            helpers_segment._updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);
            this._pointsUpdated = true;
          }
        }
        set points(points) {
          this._points = points;
          delete this._segments;
          delete this._path;
          this._pointsUpdated = false;
        }
        get points() {
          return this._points;
        }
        get segments() {
          return this._segments || (this._segments = helpers_segment._computeSegments(this, this.options.segment));
        }
        first() {
          const segments = this.segments;
          const points = this.points;
          return segments.length && points[segments[0].start];
        }
        last() {
          const segments = this.segments;
          const points = this.points;
          const count = segments.length;
          return count && points[segments[count - 1].end];
        }
        interpolate(point, property) {
          const options = this.options;
          const value = point[property];
          const points = this.points;
          const segments = helpers_segment._boundSegments(this, {
            property,
            start: value,
            end: value
          });
          if (!segments.length) {
            return;
          }
          const result = [];
          const _interpolate = _getInterpolationMethod(options);
          let i, ilen;
          for (i = 0, ilen = segments.length; i < ilen; ++i) {
            const { start, end } = segments[i];
            const p1 = points[start];
            const p2 = points[end];
            if (p1 === p2) {
              result.push(p1);
              continue;
            }
            const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));
            const interpolated = _interpolate(p1, p2, t, options.stepped);
            interpolated[property] = point[property];
            result.push(interpolated);
          }
          return result.length === 1 ? result[0] : result;
        }
        pathSegment(ctx, segment, params) {
          const segmentMethod = _getSegmentMethod(this);
          return segmentMethod(ctx, this, segment, params);
        }
        path(ctx, start, count) {
          const segments = this.segments;
          const segmentMethod = _getSegmentMethod(this);
          let loop = this._loop;
          start = start || 0;
          count = count || this.points.length - start;
          for (const segment of segments) {
            loop &= segmentMethod(ctx, this, segment, {
              start,
              end: start + count - 1
            });
          }
          return !!loop;
        }
        draw(ctx, chartArea, start, count) {
          const options = this.options || {};
          const points = this.points || [];
          if (points.length && options.borderWidth) {
            ctx.save();
            draw(ctx, this, start, count);
            ctx.restore();
          }
          if (this.animated) {
            this._pointsUpdated = false;
            this._path = void 0;
          }
        }
      };
      __publicField(LineElement, "id", "line");
      __publicField(LineElement, "defaults", {
        borderCapStyle: "butt",
        borderDash: [],
        borderDashOffset: 0,
        borderJoinStyle: "miter",
        borderWidth: 3,
        capBezierPoints: true,
        cubicInterpolationMode: "default",
        fill: false,
        spanGaps: false,
        stepped: false,
        tension: 0
      });
      __publicField(LineElement, "defaultRoutes", {
        backgroundColor: "backgroundColor",
        borderColor: "borderColor"
      });
      __publicField(LineElement, "descriptors", {
        _scriptable: true,
        _indexable: (name) => name !== "borderDash" && name !== "fill"
      });
      function inRange$1(el, pos, axis, useFinalPosition) {
        const options = el.options;
        const { [axis]: value } = el.getProps([
          axis
        ], useFinalPosition);
        return Math.abs(pos - value) < options.radius + options.hitRadius;
      }
      var PointElement = class extends Element {
        parsed;
        skip;
        stop;
        constructor(cfg) {
          super();
          this.options = void 0;
          this.parsed = void 0;
          this.skip = void 0;
          this.stop = void 0;
          if (cfg) {
            Object.assign(this, cfg);
          }
        }
        inRange(mouseX, mouseY, useFinalPosition) {
          const options = this.options;
          const { x, y } = this.getProps([
            "x",
            "y"
          ], useFinalPosition);
          return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2);
        }
        inXRange(mouseX, useFinalPosition) {
          return inRange$1(this, mouseX, "x", useFinalPosition);
        }
        inYRange(mouseY, useFinalPosition) {
          return inRange$1(this, mouseY, "y", useFinalPosition);
        }
        getCenterPoint(useFinalPosition) {
          const { x, y } = this.getProps([
            "x",
            "y"
          ], useFinalPosition);
          return {
            x,
            y
          };
        }
        size(options) {
          options = options || this.options || {};
          let radius = options.radius || 0;
          radius = Math.max(radius, radius && options.hoverRadius || 0);
          const borderWidth = radius && options.borderWidth || 0;
          return (radius + borderWidth) * 2;
        }
        draw(ctx, area) {
          const options = this.options;
          if (this.skip || options.radius < 0.1 || !helpers_segment._isPointInArea(this, area, this.size(options) / 2)) {
            return;
          }
          ctx.strokeStyle = options.borderColor;
          ctx.lineWidth = options.borderWidth;
          ctx.fillStyle = options.backgroundColor;
          helpers_segment.drawPoint(ctx, options, this.x, this.y);
        }
        getRange() {
          const options = this.options || {};
          return options.radius + options.hitRadius;
        }
      };
      __publicField(PointElement, "id", "point");
      /**
      * @type {any}
      */
      __publicField(PointElement, "defaults", {
        borderWidth: 1,
        hitRadius: 1,
        hoverBorderWidth: 1,
        hoverRadius: 4,
        pointStyle: "circle",
        radius: 3,
        rotation: 0
      });
      /**
      * @type {any}
      */
      __publicField(PointElement, "defaultRoutes", {
        backgroundColor: "backgroundColor",
        borderColor: "borderColor"
      });
      function getBarBounds(bar, useFinalPosition) {
        const { x, y, base, width, height } = bar.getProps([
          "x",
          "y",
          "base",
          "width",
          "height"
        ], useFinalPosition);
        let left, right, top, bottom, half;
        if (bar.horizontal) {
          half = height / 2;
          left = Math.min(x, base);
          right = Math.max(x, base);
          top = y - half;
          bottom = y + half;
        } else {
          half = width / 2;
          left = x - half;
          right = x + half;
          top = Math.min(y, base);
          bottom = Math.max(y, base);
        }
        return {
          left,
          top,
          right,
          bottom
        };
      }
      function skipOrLimit(skip2, value, min, max) {
        return skip2 ? 0 : helpers_segment._limitValue(value, min, max);
      }
      function parseBorderWidth(bar, maxW, maxH) {
        const value = bar.options.borderWidth;
        const skip2 = bar.borderSkipped;
        const o = helpers_segment.toTRBL(value);
        return {
          t: skipOrLimit(skip2.top, o.top, 0, maxH),
          r: skipOrLimit(skip2.right, o.right, 0, maxW),
          b: skipOrLimit(skip2.bottom, o.bottom, 0, maxH),
          l: skipOrLimit(skip2.left, o.left, 0, maxW)
        };
      }
      function parseBorderRadius(bar, maxW, maxH) {
        const { enableBorderRadius } = bar.getProps([
          "enableBorderRadius"
        ]);
        const value = bar.options.borderRadius;
        const o = helpers_segment.toTRBLCorners(value);
        const maxR = Math.min(maxW, maxH);
        const skip2 = bar.borderSkipped;
        const enableBorder = enableBorderRadius || helpers_segment.isObject(value);
        return {
          topLeft: skipOrLimit(!enableBorder || skip2.top || skip2.left, o.topLeft, 0, maxR),
          topRight: skipOrLimit(!enableBorder || skip2.top || skip2.right, o.topRight, 0, maxR),
          bottomLeft: skipOrLimit(!enableBorder || skip2.bottom || skip2.left, o.bottomLeft, 0, maxR),
          bottomRight: skipOrLimit(!enableBorder || skip2.bottom || skip2.right, o.bottomRight, 0, maxR)
        };
      }
      function boundingRects(bar) {
        const bounds = getBarBounds(bar);
        const width = bounds.right - bounds.left;
        const height = bounds.bottom - bounds.top;
        const border = parseBorderWidth(bar, width / 2, height / 2);
        const radius = parseBorderRadius(bar, width / 2, height / 2);
        return {
          outer: {
            x: bounds.left,
            y: bounds.top,
            w: width,
            h: height,
            radius
          },
          inner: {
            x: bounds.left + border.l,
            y: bounds.top + border.t,
            w: width - border.l - border.r,
            h: height - border.t - border.b,
            radius: {
              topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
              topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
              bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
              bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
            }
          }
        };
      }
      function inRange(bar, x, y, useFinalPosition) {
        const skipX = x === null;
        const skipY = y === null;
        const skipBoth = skipX && skipY;
        const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
        return bounds && (skipX || helpers_segment._isBetween(x, bounds.left, bounds.right)) && (skipY || helpers_segment._isBetween(y, bounds.top, bounds.bottom));
      }
      function hasRadius(radius) {
        return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
      }
      function addNormalRectPath(ctx, rect) {
        ctx.rect(rect.x, rect.y, rect.w, rect.h);
      }
      function inflateRect(rect, amount, refRect = {}) {
        const x = rect.x !== refRect.x ? -amount : 0;
        const y = rect.y !== refRect.y ? -amount : 0;
        const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;
        const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;
        return {
          x: rect.x + x,
          y: rect.y + y,
          w: rect.w + w,
          h: rect.h + h,
          radius: rect.radius
        };
      }
      var BarElement = class extends Element {
        constructor(cfg) {
          super();
          this.options = void 0;
          this.horizontal = void 0;
          this.base = void 0;
          this.width = void 0;
          this.height = void 0;
          this.inflateAmount = void 0;
          if (cfg) {
            Object.assign(this, cfg);
          }
        }
        draw(ctx) {
          const { inflateAmount, options: { borderColor, backgroundColor } } = this;
          const { inner, outer } = boundingRects(this);
          const addRectPath = hasRadius(outer.radius) ? helpers_segment.addRoundedRectPath : addNormalRectPath;
          ctx.save();
          if (outer.w !== inner.w || outer.h !== inner.h) {
            ctx.beginPath();
            addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
            ctx.clip();
            addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
            ctx.fillStyle = borderColor;
            ctx.fill("evenodd");
          }
          ctx.beginPath();
          addRectPath(ctx, inflateRect(inner, inflateAmount));
          ctx.fillStyle = backgroundColor;
          ctx.fill();
          ctx.restore();
        }
        inRange(mouseX, mouseY, useFinalPosition) {
          return inRange(this, mouseX, mouseY, useFinalPosition);
        }
        inXRange(mouseX, useFinalPosition) {
          return inRange(this, mouseX, null, useFinalPosition);
        }
        inYRange(mouseY, useFinalPosition) {
          return inRange(this, null, mouseY, useFinalPosition);
        }
        getCenterPoint(useFinalPosition) {
          const { x, y, base, horizontal } = this.getProps([
            "x",
            "y",
            "base",
            "horizontal"
          ], useFinalPosition);
          return {
            x: horizontal ? (x + base) / 2 : x,
            y: horizontal ? y : (y + base) / 2
          };
        }
        getRange(axis) {
          return axis === "x" ? this.width / 2 : this.height / 2;
        }
      };
      __publicField(BarElement, "id", "bar");
      __publicField(BarElement, "defaults", {
        borderSkipped: "start",
        borderWidth: 0,
        borderRadius: 0,
        inflateAmount: "auto",
        pointStyle: void 0
      });
      __publicField(BarElement, "defaultRoutes", {
        backgroundColor: "backgroundColor",
        borderColor: "borderColor"
      });
      var elements = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        ArcElement,
        BarElement,
        LineElement,
        PointElement
      });
      var BORDER_COLORS = [
        "rgb(54, 162, 235)",
        "rgb(255, 99, 132)",
        "rgb(255, 159, 64)",
        "rgb(255, 205, 86)",
        "rgb(75, 192, 192)",
        "rgb(153, 102, 255)",
        "rgb(201, 203, 207)"
        // grey
      ];
      var BACKGROUND_COLORS = /* @__PURE__ */ BORDER_COLORS.map((color) => color.replace("rgb(", "rgba(").replace(")", ", 0.5)"));
      function getBorderColor(i) {
        return BORDER_COLORS[i % BORDER_COLORS.length];
      }
      function getBackgroundColor(i) {
        return BACKGROUND_COLORS[i % BACKGROUND_COLORS.length];
      }
      function colorizeDefaultDataset(dataset, i) {
        dataset.borderColor = getBorderColor(i);
        dataset.backgroundColor = getBackgroundColor(i);
        return ++i;
      }
      function colorizeDoughnutDataset(dataset, i) {
        dataset.backgroundColor = dataset.data.map(() => getBorderColor(i++));
        return i;
      }
      function colorizePolarAreaDataset(dataset, i) {
        dataset.backgroundColor = dataset.data.map(() => getBackgroundColor(i++));
        return i;
      }
      function getColorizer(chart) {
        let i = 0;
        return (dataset, datasetIndex) => {
          const controller = chart.getDatasetMeta(datasetIndex).controller;
          if (controller instanceof DoughnutController) {
            i = colorizeDoughnutDataset(dataset, i);
          } else if (controller instanceof PolarAreaController) {
            i = colorizePolarAreaDataset(dataset, i);
          } else if (controller) {
            i = colorizeDefaultDataset(dataset, i);
          }
        };
      }
      function containsColorsDefinitions(descriptors) {
        let k;
        for (k in descriptors) {
          if (descriptors[k].borderColor || descriptors[k].backgroundColor) {
            return true;
          }
        }
        return false;
      }
      function containsColorsDefinition(descriptor) {
        return descriptor && (descriptor.borderColor || descriptor.backgroundColor);
      }
      var plugin_colors = {
        id: "colors",
        defaults: {
          enabled: true,
          forceOverride: false
        },
        beforeLayout(chart, _args, options) {
          if (!options.enabled) {
            return;
          }
          const { data: { datasets }, options: chartOptions } = chart.config;
          const { elements: elements2 } = chartOptions;
          if (!options.forceOverride && (containsColorsDefinitions(datasets) || containsColorsDefinition(chartOptions) || elements2 && containsColorsDefinitions(elements2))) {
            return;
          }
          const colorizer = getColorizer(chart);
          datasets.forEach(colorizer);
        }
      };
      function lttbDecimation(data, start, count, availableWidth, options) {
        const samples = options.samples || availableWidth;
        if (samples >= count) {
          return data.slice(start, start + count);
        }
        const decimated = [];
        const bucketWidth = (count - 2) / (samples - 2);
        let sampledIndex = 0;
        const endIndex = start + count - 1;
        let a = start;
        let i, maxAreaPoint, maxArea, area, nextA;
        decimated[sampledIndex++] = data[a];
        for (i = 0; i < samples - 2; i++) {
          let avgX = 0;
          let avgY = 0;
          let j;
          const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;
          const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;
          const avgRangeLength = avgRangeEnd - avgRangeStart;
          for (j = avgRangeStart; j < avgRangeEnd; j++) {
            avgX += data[j].x;
            avgY += data[j].y;
          }
          avgX /= avgRangeLength;
          avgY /= avgRangeLength;
          const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;
          const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;
          const { x: pointAx, y: pointAy } = data[a];
          maxArea = area = -1;
          for (j = rangeOffs; j < rangeTo; j++) {
            area = 0.5 * Math.abs((pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy));
            if (area > maxArea) {
              maxArea = area;
              maxAreaPoint = data[j];
              nextA = j;
            }
          }
          decimated[sampledIndex++] = maxAreaPoint;
          a = nextA;
        }
        decimated[sampledIndex++] = data[endIndex];
        return decimated;
      }
      function minMaxDecimation(data, start, count, availableWidth) {
        let avgX = 0;
        let countX = 0;
        let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;
        const decimated = [];
        const endIndex = start + count - 1;
        const xMin = data[start].x;
        const xMax = data[endIndex].x;
        const dx = xMax - xMin;
        for (i = start; i < start + count; ++i) {
          point = data[i];
          x = (point.x - xMin) / dx * availableWidth;
          y = point.y;
          const truncX = x | 0;
          if (truncX === prevX) {
            if (y < minY) {
              minY = y;
              minIndex = i;
            } else if (y > maxY) {
              maxY = y;
              maxIndex = i;
            }
            avgX = (countX * avgX + point.x) / ++countX;
          } else {
            const lastIndex = i - 1;
            if (!helpers_segment.isNullOrUndef(minIndex) && !helpers_segment.isNullOrUndef(maxIndex)) {
              const intermediateIndex1 = Math.min(minIndex, maxIndex);
              const intermediateIndex2 = Math.max(minIndex, maxIndex);
              if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {
                decimated.push({
                  ...data[intermediateIndex1],
                  x: avgX
                });
              }
              if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {
                decimated.push({
                  ...data[intermediateIndex2],
                  x: avgX
                });
              }
            }
            if (i > 0 && lastIndex !== startIndex) {
              decimated.push(data[lastIndex]);
            }
            decimated.push(point);
            prevX = truncX;
            countX = 0;
            minY = maxY = y;
            minIndex = maxIndex = startIndex = i;
          }
        }
        return decimated;
      }
      function cleanDecimatedDataset(dataset) {
        if (dataset._decimated) {
          const data = dataset._data;
          delete dataset._decimated;
          delete dataset._data;
          Object.defineProperty(dataset, "data", {
            configurable: true,
            enumerable: true,
            writable: true,
            value: data
          });
        }
      }
      function cleanDecimatedData(chart) {
        chart.data.datasets.forEach((dataset) => {
          cleanDecimatedDataset(dataset);
        });
      }
      function getStartAndCountOfVisiblePointsSimplified(meta, points) {
        const pointCount = points.length;
        let start = 0;
        let count;
        const { iScale } = meta;
        const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
        if (minDefined) {
          start = helpers_segment._limitValue(helpers_segment._lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);
        }
        if (maxDefined) {
          count = helpers_segment._limitValue(helpers_segment._lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;
        } else {
          count = pointCount - start;
        }
        return {
          start,
          count
        };
      }
      var plugin_decimation = {
        id: "decimation",
        defaults: {
          algorithm: "min-max",
          enabled: false
        },
        beforeElementsUpdate: (chart, args, options) => {
          if (!options.enabled) {
            cleanDecimatedData(chart);
            return;
          }
          const availableWidth = chart.width;
          chart.data.datasets.forEach((dataset, datasetIndex) => {
            const { _data, indexAxis } = dataset;
            const meta = chart.getDatasetMeta(datasetIndex);
            const data = _data || dataset.data;
            if (helpers_segment.resolve([
              indexAxis,
              chart.options.indexAxis
            ]) === "y") {
              return;
            }
            if (!meta.controller.supportsDecimation) {
              return;
            }
            const xAxis = chart.scales[meta.xAxisID];
            if (xAxis.type !== "linear" && xAxis.type !== "time") {
              return;
            }
            if (chart.options.parsing) {
              return;
            }
            let { start, count } = getStartAndCountOfVisiblePointsSimplified(meta, data);
            const threshold = options.threshold || 4 * availableWidth;
            if (count <= threshold) {
              cleanDecimatedDataset(dataset);
              return;
            }
            if (helpers_segment.isNullOrUndef(_data)) {
              dataset._data = data;
              delete dataset.data;
              Object.defineProperty(dataset, "data", {
                configurable: true,
                enumerable: true,
                get: function() {
                  return this._decimated;
                },
                set: function(d) {
                  this._data = d;
                }
              });
            }
            let decimated;
            switch (options.algorithm) {
              case "lttb":
                decimated = lttbDecimation(data, start, count, availableWidth, options);
                break;
              case "min-max":
                decimated = minMaxDecimation(data, start, count, availableWidth);
                break;
              default:
                throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);
            }
            dataset._decimated = decimated;
          });
        },
        destroy(chart) {
          cleanDecimatedData(chart);
        }
      };
      function _segments(line, target, property) {
        const segments = line.segments;
        const points = line.points;
        const tpoints = target.points;
        const parts = [];
        for (const segment of segments) {
          let { start, end } = segment;
          end = _findSegmentEnd(start, end, points);
          const bounds = _getBounds(property, points[start], points[end], segment.loop);
          if (!target.segments) {
            parts.push({
              source: segment,
              target: bounds,
              start: points[start],
              end: points[end]
            });
            continue;
          }
          const targetSegments = helpers_segment._boundSegments(target, bounds);
          for (const tgt of targetSegments) {
            const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);
            const fillSources = helpers_segment._boundSegment(segment, points, subBounds);
            for (const fillSource of fillSources) {
              parts.push({
                source: fillSource,
                target: tgt,
                start: {
                  [property]: _getEdge(bounds, subBounds, "start", Math.max)
                },
                end: {
                  [property]: _getEdge(bounds, subBounds, "end", Math.min)
                }
              });
            }
          }
        }
        return parts;
      }
      function _getBounds(property, first, last, loop) {
        if (loop) {
          return;
        }
        let start = first[property];
        let end = last[property];
        if (property === "angle") {
          start = helpers_segment._normalizeAngle(start);
          end = helpers_segment._normalizeAngle(end);
        }
        return {
          property,
          start,
          end
        };
      }
      function _pointsFromSegments(boundary, line) {
        const { x = null, y = null } = boundary || {};
        const linePoints = line.points;
        const points = [];
        line.segments.forEach(({ start, end }) => {
          end = _findSegmentEnd(start, end, linePoints);
          const first = linePoints[start];
          const last = linePoints[end];
          if (y !== null) {
            points.push({
              x: first.x,
              y
            });
            points.push({
              x: last.x,
              y
            });
          } else if (x !== null) {
            points.push({
              x,
              y: first.y
            });
            points.push({
              x,
              y: last.y
            });
          }
        });
        return points;
      }
      function _findSegmentEnd(start, end, points) {
        for (; end > start; end--) {
          const point = points[end];
          if (!isNaN(point.x) && !isNaN(point.y)) {
            break;
          }
        }
        return end;
      }
      function _getEdge(a, b, prop, fn) {
        if (a && b) {
          return fn(a[prop], b[prop]);
        }
        return a ? a[prop] : b ? b[prop] : 0;
      }
      function _createBoundaryLine(boundary, line) {
        let points = [];
        let _loop = false;
        if (helpers_segment.isArray(boundary)) {
          _loop = true;
          points = boundary;
        } else {
          points = _pointsFromSegments(boundary, line);
        }
        return points.length ? new LineElement({
          points,
          options: {
            tension: 0
          },
          _loop,
          _fullLoop: _loop
        }) : null;
      }
      function _shouldApplyFill(source) {
        return source && source.fill !== false;
      }
      function _resolveTarget(sources, index2, propagate) {
        const source = sources[index2];
        let fill2 = source.fill;
        const visited = [
          index2
        ];
        let target;
        if (!propagate) {
          return fill2;
        }
        while (fill2 !== false && visited.indexOf(fill2) === -1) {
          if (!helpers_segment.isNumberFinite(fill2)) {
            return fill2;
          }
          target = sources[fill2];
          if (!target) {
            return false;
          }
          if (target.visible) {
            return fill2;
          }
          visited.push(fill2);
          fill2 = target.fill;
        }
        return false;
      }
      function _decodeFill(line, index2, count) {
        const fill2 = parseFillOption(line);
        if (helpers_segment.isObject(fill2)) {
          return isNaN(fill2.value) ? false : fill2;
        }
        let target = parseFloat(fill2);
        if (helpers_segment.isNumberFinite(target) && Math.floor(target) === target) {
          return decodeTargetIndex(fill2[0], index2, target, count);
        }
        return [
          "origin",
          "start",
          "end",
          "stack",
          "shape"
        ].indexOf(fill2) >= 0 && fill2;
      }
      function decodeTargetIndex(firstCh, index2, target, count) {
        if (firstCh === "-" || firstCh === "+") {
          target = index2 + target;
        }
        if (target === index2 || target < 0 || target >= count) {
          return false;
        }
        return target;
      }
      function _getTargetPixel(fill2, scale) {
        let pixel = null;
        if (fill2 === "start") {
          pixel = scale.bottom;
        } else if (fill2 === "end") {
          pixel = scale.top;
        } else if (helpers_segment.isObject(fill2)) {
          pixel = scale.getPixelForValue(fill2.value);
        } else if (scale.getBasePixel) {
          pixel = scale.getBasePixel();
        }
        return pixel;
      }
      function _getTargetValue(fill2, scale, startValue) {
        let value;
        if (fill2 === "start") {
          value = startValue;
        } else if (fill2 === "end") {
          value = scale.options.reverse ? scale.min : scale.max;
        } else if (helpers_segment.isObject(fill2)) {
          value = fill2.value;
        } else {
          value = scale.getBaseValue();
        }
        return value;
      }
      function parseFillOption(line) {
        const options = line.options;
        const fillOption = options.fill;
        let fill2 = helpers_segment.valueOrDefault(fillOption && fillOption.target, fillOption);
        if (fill2 === void 0) {
          fill2 = !!options.backgroundColor;
        }
        if (fill2 === false || fill2 === null) {
          return false;
        }
        if (fill2 === true) {
          return "origin";
        }
        return fill2;
      }
      function _buildStackLine(source) {
        const { scale, index: index2, line } = source;
        const points = [];
        const segments = line.segments;
        const sourcePoints = line.points;
        const linesBelow = getLinesBelow(scale, index2);
        linesBelow.push(_createBoundaryLine({
          x: null,
          y: scale.bottom
        }, line));
        for (let i = 0; i < segments.length; i++) {
          const segment = segments[i];
          for (let j = segment.start; j <= segment.end; j++) {
            addPointsBelow(points, sourcePoints[j], linesBelow);
          }
        }
        return new LineElement({
          points,
          options: {}
        });
      }
      function getLinesBelow(scale, index2) {
        const below = [];
        const metas = scale.getMatchingVisibleMetas("line");
        for (let i = 0; i < metas.length; i++) {
          const meta = metas[i];
          if (meta.index === index2) {
            break;
          }
          if (!meta.hidden) {
            below.unshift(meta.dataset);
          }
        }
        return below;
      }
      function addPointsBelow(points, sourcePoint, linesBelow) {
        const postponed = [];
        for (let j = 0; j < linesBelow.length; j++) {
          const line = linesBelow[j];
          const { first, last, point } = findPoint(line, sourcePoint, "x");
          if (!point || first && last) {
            continue;
          }
          if (first) {
            postponed.unshift(point);
          } else {
            points.push(point);
            if (!last) {
              break;
            }
          }
        }
        points.push(...postponed);
      }
      function findPoint(line, sourcePoint, property) {
        const point = line.interpolate(sourcePoint, property);
        if (!point) {
          return {};
        }
        const pointValue = point[property];
        const segments = line.segments;
        const linePoints = line.points;
        let first = false;
        let last = false;
        for (let i = 0; i < segments.length; i++) {
          const segment = segments[i];
          const firstValue = linePoints[segment.start][property];
          const lastValue = linePoints[segment.end][property];
          if (helpers_segment._isBetween(pointValue, firstValue, lastValue)) {
            first = pointValue === firstValue;
            last = pointValue === lastValue;
            break;
          }
        }
        return {
          first,
          last,
          point
        };
      }
      var simpleArc = class {
        constructor(opts) {
          this.x = opts.x;
          this.y = opts.y;
          this.radius = opts.radius;
        }
        pathSegment(ctx, bounds, opts) {
          const { x, y, radius } = this;
          bounds = bounds || {
            start: 0,
            end: helpers_segment.TAU
          };
          ctx.arc(x, y, radius, bounds.end, bounds.start, true);
          return !opts.bounds;
        }
        interpolate(point) {
          const { x, y, radius } = this;
          const angle = point.angle;
          return {
            x: x + Math.cos(angle) * radius,
            y: y + Math.sin(angle) * radius,
            angle
          };
        }
      };
      function _getTarget(source) {
        const { chart, fill: fill2, line } = source;
        if (helpers_segment.isNumberFinite(fill2)) {
          return getLineByIndex(chart, fill2);
        }
        if (fill2 === "stack") {
          return _buildStackLine(source);
        }
        if (fill2 === "shape") {
          return true;
        }
        const boundary = computeBoundary(source);
        if (boundary instanceof simpleArc) {
          return boundary;
        }
        return _createBoundaryLine(boundary, line);
      }
      function getLineByIndex(chart, index2) {
        const meta = chart.getDatasetMeta(index2);
        const visible = meta && chart.isDatasetVisible(index2);
        return visible ? meta.dataset : null;
      }
      function computeBoundary(source) {
        const scale = source.scale || {};
        if (scale.getPointPositionForValue) {
          return computeCircularBoundary(source);
        }
        return computeLinearBoundary(source);
      }
      function computeLinearBoundary(source) {
        const { scale = {}, fill: fill2 } = source;
        const pixel = _getTargetPixel(fill2, scale);
        if (helpers_segment.isNumberFinite(pixel)) {
          const horizontal = scale.isHorizontal();
          return {
            x: horizontal ? pixel : null,
            y: horizontal ? null : pixel
          };
        }
        return null;
      }
      function computeCircularBoundary(source) {
        const { scale, fill: fill2 } = source;
        const options = scale.options;
        const length = scale.getLabels().length;
        const start = options.reverse ? scale.max : scale.min;
        const value = _getTargetValue(fill2, scale, start);
        const target = [];
        if (options.grid.circular) {
          const center = scale.getPointPositionForValue(0, start);
          return new simpleArc({
            x: center.x,
            y: center.y,
            radius: scale.getDistanceFromCenterForValue(value)
          });
        }
        for (let i = 0; i < length; ++i) {
          target.push(scale.getPointPositionForValue(i, value));
        }
        return target;
      }
      function _drawfill(ctx, source, area) {
        const target = _getTarget(source);
        const { line, scale, axis } = source;
        const lineOpts = line.options;
        const fillOption = lineOpts.fill;
        const color = lineOpts.backgroundColor;
        const { above = color, below = color } = fillOption || {};
        if (target && line.points.length) {
          helpers_segment.clipArea(ctx, area);
          doFill(ctx, {
            line,
            target,
            above,
            below,
            area,
            scale,
            axis
          });
          helpers_segment.unclipArea(ctx);
        }
      }
      function doFill(ctx, cfg) {
        const { line, target, above, below, area, scale } = cfg;
        const property = line._loop ? "angle" : cfg.axis;
        ctx.save();
        if (property === "x" && below !== above) {
          clipVertical(ctx, target, area.top);
          fill(ctx, {
            line,
            target,
            color: above,
            scale,
            property
          });
          ctx.restore();
          ctx.save();
          clipVertical(ctx, target, area.bottom);
        }
        fill(ctx, {
          line,
          target,
          color: below,
          scale,
          property
        });
        ctx.restore();
      }
      function clipVertical(ctx, target, clipY) {
        const { segments, points } = target;
        let first = true;
        let lineLoop = false;
        ctx.beginPath();
        for (const segment of segments) {
          const { start, end } = segment;
          const firstPoint = points[start];
          const lastPoint = points[_findSegmentEnd(start, end, points)];
          if (first) {
            ctx.moveTo(firstPoint.x, firstPoint.y);
            first = false;
          } else {
            ctx.lineTo(firstPoint.x, clipY);
            ctx.lineTo(firstPoint.x, firstPoint.y);
          }
          lineLoop = !!target.pathSegment(ctx, segment, {
            move: lineLoop
          });
          if (lineLoop) {
            ctx.closePath();
          } else {
            ctx.lineTo(lastPoint.x, clipY);
          }
        }
        ctx.lineTo(target.first().x, clipY);
        ctx.closePath();
        ctx.clip();
      }
      function fill(ctx, cfg) {
        const { line, target, property, color, scale } = cfg;
        const segments = _segments(line, target, property);
        for (const { source: src, target: tgt, start, end } of segments) {
          const { style: { backgroundColor = color } = {} } = src;
          const notShape = target !== true;
          ctx.save();
          ctx.fillStyle = backgroundColor;
          clipBounds(ctx, scale, notShape && _getBounds(property, start, end));
          ctx.beginPath();
          const lineLoop = !!line.pathSegment(ctx, src);
          let loop;
          if (notShape) {
            if (lineLoop) {
              ctx.closePath();
            } else {
              interpolatedLineTo(ctx, target, end, property);
            }
            const targetLoop = !!target.pathSegment(ctx, tgt, {
              move: lineLoop,
              reverse: true
            });
            loop = lineLoop && targetLoop;
            if (!loop) {
              interpolatedLineTo(ctx, target, start, property);
            }
          }
          ctx.closePath();
          ctx.fill(loop ? "evenodd" : "nonzero");
          ctx.restore();
        }
      }
      function clipBounds(ctx, scale, bounds) {
        const { top, bottom } = scale.chart.chartArea;
        const { property, start, end } = bounds || {};
        if (property === "x") {
          ctx.beginPath();
          ctx.rect(start, top, end - start, bottom - top);
          ctx.clip();
        }
      }
      function interpolatedLineTo(ctx, target, point, property) {
        const interpolatedPoint = target.interpolate(point, property);
        if (interpolatedPoint) {
          ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
        }
      }
      var index = {
        id: "filler",
        afterDatasetsUpdate(chart, _args, options) {
          const count = (chart.data.datasets || []).length;
          const sources = [];
          let meta, i, line, source;
          for (i = 0; i < count; ++i) {
            meta = chart.getDatasetMeta(i);
            line = meta.dataset;
            source = null;
            if (line && line.options && line instanceof LineElement) {
              source = {
                visible: chart.isDatasetVisible(i),
                index: i,
                fill: _decodeFill(line, i, count),
                chart,
                axis: meta.controller.options.indexAxis,
                scale: meta.vScale,
                line
              };
            }
            meta.$filler = source;
            sources.push(source);
          }
          for (i = 0; i < count; ++i) {
            source = sources[i];
            if (!source || source.fill === false) {
              continue;
            }
            source.fill = _resolveTarget(sources, i, options.propagate);
          }
        },
        beforeDraw(chart, _args, options) {
          const draw2 = options.drawTime === "beforeDraw";
          const metasets = chart.getSortedVisibleDatasetMetas();
          const area = chart.chartArea;
          for (let i = metasets.length - 1; i >= 0; --i) {
            const source = metasets[i].$filler;
            if (!source) {
              continue;
            }
            source.line.updateControlPoints(area, source.axis);
            if (draw2 && source.fill) {
              _drawfill(chart.ctx, source, area);
            }
          }
        },
        beforeDatasetsDraw(chart, _args, options) {
          if (options.drawTime !== "beforeDatasetsDraw") {
            return;
          }
          const metasets = chart.getSortedVisibleDatasetMetas();
          for (let i = metasets.length - 1; i >= 0; --i) {
            const source = metasets[i].$filler;
            if (_shouldApplyFill(source)) {
              _drawfill(chart.ctx, source, chart.chartArea);
            }
          }
        },
        beforeDatasetDraw(chart, args, options) {
          const source = args.meta.$filler;
          if (!_shouldApplyFill(source) || options.drawTime !== "beforeDatasetDraw") {
            return;
          }
          _drawfill(chart.ctx, source, chart.chartArea);
        },
        defaults: {
          propagate: true,
          drawTime: "beforeDatasetDraw"
        }
      };
      var getBoxSize = (labelOpts, fontSize) => {
        let { boxHeight = fontSize, boxWidth = fontSize } = labelOpts;
        if (labelOpts.usePointStyle) {
          boxHeight = Math.min(boxHeight, fontSize);
          boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);
        }
        return {
          boxWidth,
          boxHeight,
          itemHeight: Math.max(fontSize, boxHeight)
        };
      };
      var itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;
      var Legend = class extends Element {
        constructor(config) {
          super();
          this._added = false;
          this.legendHitBoxes = [];
          this._hoveredItem = null;
          this.doughnutMode = false;
          this.chart = config.chart;
          this.options = config.options;
          this.ctx = config.ctx;
          this.legendItems = void 0;
          this.columnSizes = void 0;
          this.lineWidths = void 0;
          this.maxHeight = void 0;
          this.maxWidth = void 0;
          this.top = void 0;
          this.bottom = void 0;
          this.left = void 0;
          this.right = void 0;
          this.height = void 0;
          this.width = void 0;
          this._margins = void 0;
          this.position = void 0;
          this.weight = void 0;
          this.fullSize = void 0;
        }
        update(maxWidth, maxHeight, margins) {
          this.maxWidth = maxWidth;
          this.maxHeight = maxHeight;
          this._margins = margins;
          this.setDimensions();
          this.buildLabels();
          this.fit();
        }
        setDimensions() {
          if (this.isHorizontal()) {
            this.width = this.maxWidth;
            this.left = this._margins.left;
            this.right = this.width;
          } else {
            this.height = this.maxHeight;
            this.top = this._margins.top;
            this.bottom = this.height;
          }
        }
        buildLabels() {
          const labelOpts = this.options.labels || {};
          let legendItems = helpers_segment.callback(labelOpts.generateLabels, [
            this.chart
          ], this) || [];
          if (labelOpts.filter) {
            legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));
          }
          if (labelOpts.sort) {
            legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));
          }
          if (this.options.reverse) {
            legendItems.reverse();
          }
          this.legendItems = legendItems;
        }
        fit() {
          const { options, ctx } = this;
          if (!options.display) {
            this.width = this.height = 0;
            return;
          }
          const labelOpts = options.labels;
          const labelFont = helpers_segment.toFont(labelOpts.font);
          const fontSize = labelFont.size;
          const titleHeight = this._computeTitleHeight();
          const { boxWidth, itemHeight } = getBoxSize(labelOpts, fontSize);
          let width, height;
          ctx.font = labelFont.string;
          if (this.isHorizontal()) {
            width = this.maxWidth;
            height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
          } else {
            height = this.maxHeight;
            width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;
          }
          this.width = Math.min(width, options.maxWidth || this.maxWidth);
          this.height = Math.min(height, options.maxHeight || this.maxHeight);
        }
        _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
          const { ctx, maxWidth, options: { labels: { padding } } } = this;
          const hitboxes = this.legendHitBoxes = [];
          const lineWidths = this.lineWidths = [
            0
          ];
          const lineHeight = itemHeight + padding;
          let totalHeight = titleHeight;
          ctx.textAlign = "left";
          ctx.textBaseline = "middle";
          let row = -1;
          let top = -lineHeight;
          this.legendItems.forEach((legendItem, i) => {
            const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
            if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
              totalHeight += lineHeight;
              lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
              top += lineHeight;
              row++;
            }
            hitboxes[i] = {
              left: 0,
              top,
              row,
              width: itemWidth,
              height: itemHeight
            };
            lineWidths[lineWidths.length - 1] += itemWidth + padding;
          });
          return totalHeight;
        }
        _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {
          const { ctx, maxHeight, options: { labels: { padding } } } = this;
          const hitboxes = this.legendHitBoxes = [];
          const columnSizes = this.columnSizes = [];
          const heightLimit = maxHeight - titleHeight;
          let totalWidth = padding;
          let currentColWidth = 0;
          let currentColHeight = 0;
          let left = 0;
          let col = 0;
          this.legendItems.forEach((legendItem, i) => {
            const { itemWidth, itemHeight } = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight);
            if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
              totalWidth += currentColWidth + padding;
              columnSizes.push({
                width: currentColWidth,
                height: currentColHeight
              });
              left += currentColWidth + padding;
              col++;
              currentColWidth = currentColHeight = 0;
            }
            hitboxes[i] = {
              left,
              top: currentColHeight,
              col,
              width: itemWidth,
              height: itemHeight
            };
            currentColWidth = Math.max(currentColWidth, itemWidth);
            currentColHeight += itemHeight + padding;
          });
          totalWidth += currentColWidth;
          columnSizes.push({
            width: currentColWidth,
            height: currentColHeight
          });
          return totalWidth;
        }
        adjustHitBoxes() {
          if (!this.options.display) {
            return;
          }
          const titleHeight = this._computeTitleHeight();
          const { legendHitBoxes: hitboxes, options: { align, labels: { padding }, rtl } } = this;
          const rtlHelper = helpers_segment.getRtlAdapter(rtl, this.left, this.width);
          if (this.isHorizontal()) {
            let row = 0;
            let left = helpers_segment._alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
            for (const hitbox of hitboxes) {
              if (row !== hitbox.row) {
                row = hitbox.row;
                left = helpers_segment._alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
              }
              hitbox.top += this.top + titleHeight + padding;
              hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
              left += hitbox.width + padding;
            }
          } else {
            let col = 0;
            let top = helpers_segment._alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
            for (const hitbox of hitboxes) {
              if (hitbox.col !== col) {
                col = hitbox.col;
                top = helpers_segment._alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
              }
              hitbox.top = top;
              hitbox.left += this.left + padding;
              hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
              top += hitbox.height + padding;
            }
          }
        }
        isHorizontal() {
          return this.options.position === "top" || this.options.position === "bottom";
        }
        draw() {
          if (this.options.display) {
            const ctx = this.ctx;
            helpers_segment.clipArea(ctx, this);
            this._draw();
            helpers_segment.unclipArea(ctx);
          }
        }
        _draw() {
          const { options: opts, columnSizes, lineWidths, ctx } = this;
          const { align, labels: labelOpts } = opts;
          const defaultColor = helpers_segment.defaults.color;
          const rtlHelper = helpers_segment.getRtlAdapter(opts.rtl, this.left, this.width);
          const labelFont = helpers_segment.toFont(labelOpts.font);
          const { padding } = labelOpts;
          const fontSize = labelFont.size;
          const halfFontSize = fontSize / 2;
          let cursor;
          this.drawTitle();
          ctx.textAlign = rtlHelper.textAlign("left");
          ctx.textBaseline = "middle";
          ctx.lineWidth = 0.5;
          ctx.font = labelFont.string;
          const { boxWidth, boxHeight, itemHeight } = getBoxSize(labelOpts, fontSize);
          const drawLegendBox = function(x, y, legendItem) {
            if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
              return;
            }
            ctx.save();
            const lineWidth = helpers_segment.valueOrDefault(legendItem.lineWidth, 1);
            ctx.fillStyle = helpers_segment.valueOrDefault(legendItem.fillStyle, defaultColor);
            ctx.lineCap = helpers_segment.valueOrDefault(legendItem.lineCap, "butt");
            ctx.lineDashOffset = helpers_segment.valueOrDefault(legendItem.lineDashOffset, 0);
            ctx.lineJoin = helpers_segment.valueOrDefault(legendItem.lineJoin, "miter");
            ctx.lineWidth = lineWidth;
            ctx.strokeStyle = helpers_segment.valueOrDefault(legendItem.strokeStyle, defaultColor);
            ctx.setLineDash(helpers_segment.valueOrDefault(legendItem.lineDash, []));
            if (labelOpts.usePointStyle) {
              const drawOptions = {
                radius: boxHeight * Math.SQRT2 / 2,
                pointStyle: legendItem.pointStyle,
                rotation: legendItem.rotation,
                borderWidth: lineWidth
              };
              const centerX = rtlHelper.xPlus(x, boxWidth / 2);
              const centerY = y + halfFontSize;
              helpers_segment.drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);
            } else {
              const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);
              const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);
              const borderRadius = helpers_segment.toTRBLCorners(legendItem.borderRadius);
              ctx.beginPath();
              if (Object.values(borderRadius).some((v) => v !== 0)) {
                helpers_segment.addRoundedRectPath(ctx, {
                  x: xBoxLeft,
                  y: yBoxTop,
                  w: boxWidth,
                  h: boxHeight,
                  radius: borderRadius
                });
              } else {
                ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
              }
              ctx.fill();
              if (lineWidth !== 0) {
                ctx.stroke();
              }
            }
            ctx.restore();
          };
          const fillText = function(x, y, legendItem) {
            helpers_segment.renderText(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {
              strikethrough: legendItem.hidden,
              textAlign: rtlHelper.textAlign(legendItem.textAlign)
            });
          };
          const isHorizontal = this.isHorizontal();
          const titleHeight = this._computeTitleHeight();
          if (isHorizontal) {
            cursor = {
              x: helpers_segment._alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
              y: this.top + padding + titleHeight,
              line: 0
            };
          } else {
            cursor = {
              x: this.left + padding,
              y: helpers_segment._alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
              line: 0
            };
          }
          helpers_segment.overrideTextDirection(this.ctx, opts.textDirection);
          const lineHeight = itemHeight + padding;
          this.legendItems.forEach((legendItem, i) => {
            ctx.strokeStyle = legendItem.fontColor;
            ctx.fillStyle = legendItem.fontColor;
            const textWidth = ctx.measureText(legendItem.text).width;
            const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
            const width = boxWidth + halfFontSize + textWidth;
            let x = cursor.x;
            let y = cursor.y;
            rtlHelper.setWidth(this.width);
            if (isHorizontal) {
              if (i > 0 && x + width + padding > this.right) {
                y = cursor.y += lineHeight;
                cursor.line++;
                x = cursor.x = helpers_segment._alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);
              }
            } else if (i > 0 && y + lineHeight > this.bottom) {
              x = cursor.x = x + columnSizes[cursor.line].width + padding;
              cursor.line++;
              y = cursor.y = helpers_segment._alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
            }
            const realX = rtlHelper.x(x);
            drawLegendBox(realX, y, legendItem);
            x = helpers_segment._textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);
            fillText(rtlHelper.x(x), y, legendItem);
            if (isHorizontal) {
              cursor.x += width + padding;
            } else if (typeof legendItem.text !== "string") {
              const fontLineHeight = labelFont.lineHeight;
              cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight);
            } else {
              cursor.y += lineHeight;
            }
          });
          helpers_segment.restoreTextDirection(this.ctx, opts.textDirection);
        }
        drawTitle() {
          const opts = this.options;
          const titleOpts = opts.title;
          const titleFont = helpers_segment.toFont(titleOpts.font);
          const titlePadding = helpers_segment.toPadding(titleOpts.padding);
          if (!titleOpts.display) {
            return;
          }
          const rtlHelper = helpers_segment.getRtlAdapter(opts.rtl, this.left, this.width);
          const ctx = this.ctx;
          const position = titleOpts.position;
          const halfFontSize = titleFont.size / 2;
          const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
          let y;
          let left = this.left;
          let maxWidth = this.width;
          if (this.isHorizontal()) {
            maxWidth = Math.max(...this.lineWidths);
            y = this.top + topPaddingPlusHalfFontSize;
            left = helpers_segment._alignStartEnd(opts.align, left, this.right - maxWidth);
          } else {
            const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);
            y = topPaddingPlusHalfFontSize + helpers_segment._alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
          }
          const x = helpers_segment._alignStartEnd(position, left, left + maxWidth);
          ctx.textAlign = rtlHelper.textAlign(helpers_segment._toLeftRightCenter(position));
          ctx.textBaseline = "middle";
          ctx.strokeStyle = titleOpts.color;
          ctx.fillStyle = titleOpts.color;
          ctx.font = titleFont.string;
          helpers_segment.renderText(ctx, titleOpts.text, x, y, titleFont);
        }
        _computeTitleHeight() {
          const titleOpts = this.options.title;
          const titleFont = helpers_segment.toFont(titleOpts.font);
          const titlePadding = helpers_segment.toPadding(titleOpts.padding);
          return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
        }
        _getLegendItemAt(x, y) {
          let i, hitBox, lh;
          if (helpers_segment._isBetween(x, this.left, this.right) && helpers_segment._isBetween(y, this.top, this.bottom)) {
            lh = this.legendHitBoxes;
            for (i = 0; i < lh.length; ++i) {
              hitBox = lh[i];
              if (helpers_segment._isBetween(x, hitBox.left, hitBox.left + hitBox.width) && helpers_segment._isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {
                return this.legendItems[i];
              }
            }
          }
          return null;
        }
        handleEvent(e) {
          const opts = this.options;
          if (!isListened(e.type, opts)) {
            return;
          }
          const hoveredItem = this._getLegendItemAt(e.x, e.y);
          if (e.type === "mousemove" || e.type === "mouseout") {
            const previous = this._hoveredItem;
            const sameItem = itemsEqual(previous, hoveredItem);
            if (previous && !sameItem) {
              helpers_segment.callback(opts.onLeave, [
                e,
                previous,
                this
              ], this);
            }
            this._hoveredItem = hoveredItem;
            if (hoveredItem && !sameItem) {
              helpers_segment.callback(opts.onHover, [
                e,
                hoveredItem,
                this
              ], this);
            }
          } else if (hoveredItem) {
            helpers_segment.callback(opts.onClick, [
              e,
              hoveredItem,
              this
            ], this);
          }
        }
      };
      function calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {
        const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);
        const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);
        return {
          itemWidth,
          itemHeight
        };
      }
      function calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {
        let legendItemText = legendItem.text;
        if (legendItemText && typeof legendItemText !== "string") {
          legendItemText = legendItemText.reduce((a, b) => a.length > b.length ? a : b);
        }
        return boxWidth + labelFont.size / 2 + ctx.measureText(legendItemText).width;
      }
      function calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {
        let itemHeight = _itemHeight;
        if (typeof legendItem.text !== "string") {
          itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);
        }
        return itemHeight;
      }
      function calculateLegendItemHeight(legendItem, fontLineHeight) {
        const labelHeight = legendItem.text ? legendItem.text.length + 0.5 : 0;
        return fontLineHeight * labelHeight;
      }
      function isListened(type, opts) {
        if ((type === "mousemove" || type === "mouseout") && (opts.onHover || opts.onLeave)) {
          return true;
        }
        if (opts.onClick && (type === "click" || type === "mouseup")) {
          return true;
        }
        return false;
      }
      var plugin_legend = {
        id: "legend",
        _element: Legend,
        start(chart, _args, options) {
          const legend = chart.legend = new Legend({
            ctx: chart.ctx,
            options,
            chart
          });
          layouts.configure(chart, legend, options);
          layouts.addBox(chart, legend);
        },
        stop(chart) {
          layouts.removeBox(chart, chart.legend);
          delete chart.legend;
        },
        beforeUpdate(chart, _args, options) {
          const legend = chart.legend;
          layouts.configure(chart, legend, options);
          legend.options = options;
        },
        afterUpdate(chart) {
          const legend = chart.legend;
          legend.buildLabels();
          legend.adjustHitBoxes();
        },
        afterEvent(chart, args) {
          if (!args.replay) {
            chart.legend.handleEvent(args.event);
          }
        },
        defaults: {
          display: true,
          position: "top",
          align: "center",
          fullSize: true,
          reverse: false,
          weight: 1e3,
          onClick(e, legendItem, legend) {
            const index2 = legendItem.datasetIndex;
            const ci = legend.chart;
            if (ci.isDatasetVisible(index2)) {
              ci.hide(index2);
              legendItem.hidden = true;
            } else {
              ci.show(index2);
              legendItem.hidden = false;
            }
          },
          onHover: null,
          onLeave: null,
          labels: {
            color: (ctx) => ctx.chart.options.color,
            boxWidth: 40,
            padding: 10,
            generateLabels(chart) {
              const datasets = chart.data.datasets;
              const { labels: { usePointStyle, pointStyle, textAlign, color, useBorderRadius, borderRadius } } = chart.legend.options;
              return chart._getSortedDatasetMetas().map((meta) => {
                const style = meta.controller.getStyle(usePointStyle ? 0 : void 0);
                const borderWidth = helpers_segment.toPadding(style.borderWidth);
                return {
                  text: datasets[meta.index].label,
                  fillStyle: style.backgroundColor,
                  fontColor: color,
                  hidden: !meta.visible,
                  lineCap: style.borderCapStyle,
                  lineDash: style.borderDash,
                  lineDashOffset: style.borderDashOffset,
                  lineJoin: style.borderJoinStyle,
                  lineWidth: (borderWidth.width + borderWidth.height) / 4,
                  strokeStyle: style.borderColor,
                  pointStyle: pointStyle || style.pointStyle,
                  rotation: style.rotation,
                  textAlign: textAlign || style.textAlign,
                  borderRadius: useBorderRadius && (borderRadius || style.borderRadius),
                  datasetIndex: meta.index
                };
              }, this);
            }
          },
          title: {
            color: (ctx) => ctx.chart.options.color,
            display: false,
            position: "center",
            text: ""
          }
        },
        descriptors: {
          _scriptable: (name) => !name.startsWith("on"),
          labels: {
            _scriptable: (name) => ![
              "generateLabels",
              "filter",
              "sort"
            ].includes(name)
          }
        }
      };
      var Title = class extends Element {
        constructor(config) {
          super();
          this.chart = config.chart;
          this.options = config.options;
          this.ctx = config.ctx;
          this._padding = void 0;
          this.top = void 0;
          this.bottom = void 0;
          this.left = void 0;
          this.right = void 0;
          this.width = void 0;
          this.height = void 0;
          this.position = void 0;
          this.weight = void 0;
          this.fullSize = void 0;
        }
        update(maxWidth, maxHeight) {
          const opts = this.options;
          this.left = 0;
          this.top = 0;
          if (!opts.display) {
            this.width = this.height = this.right = this.bottom = 0;
            return;
          }
          this.width = this.right = maxWidth;
          this.height = this.bottom = maxHeight;
          const lineCount = helpers_segment.isArray(opts.text) ? opts.text.length : 1;
          this._padding = helpers_segment.toPadding(opts.padding);
          const textSize = lineCount * helpers_segment.toFont(opts.font).lineHeight + this._padding.height;
          if (this.isHorizontal()) {
            this.height = textSize;
          } else {
            this.width = textSize;
          }
        }
        isHorizontal() {
          const pos = this.options.position;
          return pos === "top" || pos === "bottom";
        }
        _drawArgs(offset) {
          const { top, left, bottom, right, options } = this;
          const align = options.align;
          let rotation = 0;
          let maxWidth, titleX, titleY;
          if (this.isHorizontal()) {
            titleX = helpers_segment._alignStartEnd(align, left, right);
            titleY = top + offset;
            maxWidth = right - left;
          } else {
            if (options.position === "left") {
              titleX = left + offset;
              titleY = helpers_segment._alignStartEnd(align, bottom, top);
              rotation = helpers_segment.PI * -0.5;
            } else {
              titleX = right - offset;
              titleY = helpers_segment._alignStartEnd(align, top, bottom);
              rotation = helpers_segment.PI * 0.5;
            }
            maxWidth = bottom - top;
          }
          return {
            titleX,
            titleY,
            maxWidth,
            rotation
          };
        }
        draw() {
          const ctx = this.ctx;
          const opts = this.options;
          if (!opts.display) {
            return;
          }
          const fontOpts = helpers_segment.toFont(opts.font);
          const lineHeight = fontOpts.lineHeight;
          const offset = lineHeight / 2 + this._padding.top;
          const { titleX, titleY, maxWidth, rotation } = this._drawArgs(offset);
          helpers_segment.renderText(ctx, opts.text, 0, 0, fontOpts, {
            color: opts.color,
            maxWidth,
            rotation,
            textAlign: helpers_segment._toLeftRightCenter(opts.align),
            textBaseline: "middle",
            translation: [
              titleX,
              titleY
            ]
          });
        }
      };
      function createTitle(chart, titleOpts) {
        const title = new Title({
          ctx: chart.ctx,
          options: titleOpts,
          chart
        });
        layouts.configure(chart, title, titleOpts);
        layouts.addBox(chart, title);
        chart.titleBlock = title;
      }
      var plugin_title = {
        id: "title",
        _element: Title,
        start(chart, _args, options) {
          createTitle(chart, options);
        },
        stop(chart) {
          const titleBlock = chart.titleBlock;
          layouts.removeBox(chart, titleBlock);
          delete chart.titleBlock;
        },
        beforeUpdate(chart, _args, options) {
          const title = chart.titleBlock;
          layouts.configure(chart, title, options);
          title.options = options;
        },
        defaults: {
          align: "center",
          display: false,
          font: {
            weight: "bold"
          },
          fullSize: true,
          padding: 10,
          position: "top",
          text: "",
          weight: 2e3
        },
        defaultRoutes: {
          color: "color"
        },
        descriptors: {
          _scriptable: true,
          _indexable: false
        }
      };
      var map = /* @__PURE__ */ new WeakMap();
      var plugin_subtitle = {
        id: "subtitle",
        start(chart, _args, options) {
          const title = new Title({
            ctx: chart.ctx,
            options,
            chart
          });
          layouts.configure(chart, title, options);
          layouts.addBox(chart, title);
          map.set(chart, title);
        },
        stop(chart) {
          layouts.removeBox(chart, map.get(chart));
          map.delete(chart);
        },
        beforeUpdate(chart, _args, options) {
          const title = map.get(chart);
          layouts.configure(chart, title, options);
          title.options = options;
        },
        defaults: {
          align: "center",
          display: false,
          font: {
            weight: "normal"
          },
          fullSize: true,
          padding: 0,
          position: "top",
          text: "",
          weight: 1500
        },
        defaultRoutes: {
          color: "color"
        },
        descriptors: {
          _scriptable: true,
          _indexable: false
        }
      };
      var positioners = {
        average(items) {
          if (!items.length) {
            return false;
          }
          let i, len;
          let x = 0;
          let y = 0;
          let count = 0;
          for (i = 0, len = items.length; i < len; ++i) {
            const el = items[i].element;
            if (el && el.hasValue()) {
              const pos = el.tooltipPosition();
              x += pos.x;
              y += pos.y;
              ++count;
            }
          }
          return {
            x: x / count,
            y: y / count
          };
        },
        nearest(items, eventPosition) {
          if (!items.length) {
            return false;
          }
          let x = eventPosition.x;
          let y = eventPosition.y;
          let minDistance = Number.POSITIVE_INFINITY;
          let i, len, nearestElement;
          for (i = 0, len = items.length; i < len; ++i) {
            const el = items[i].element;
            if (el && el.hasValue()) {
              const center = el.getCenterPoint();
              const d = helpers_segment.distanceBetweenPoints(eventPosition, center);
              if (d < minDistance) {
                minDistance = d;
                nearestElement = el;
              }
            }
          }
          if (nearestElement) {
            const tp = nearestElement.tooltipPosition();
            x = tp.x;
            y = tp.y;
          }
          return {
            x,
            y
          };
        }
      };
      function pushOrConcat(base, toPush) {
        if (toPush) {
          if (helpers_segment.isArray(toPush)) {
            Array.prototype.push.apply(base, toPush);
          } else {
            base.push(toPush);
          }
        }
        return base;
      }
      function splitNewlines(str) {
        if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) {
          return str.split("\n");
        }
        return str;
      }
      function createTooltipItem(chart, item) {
        const { element, datasetIndex, index: index2 } = item;
        const controller = chart.getDatasetMeta(datasetIndex).controller;
        const { label, value } = controller.getLabelAndValue(index2);
        return {
          chart,
          label,
          parsed: controller.getParsed(index2),
          raw: chart.data.datasets[datasetIndex].data[index2],
          formattedValue: value,
          dataset: controller.getDataset(),
          dataIndex: index2,
          datasetIndex,
          element
        };
      }
      function getTooltipSize(tooltip, options) {
        const ctx = tooltip.chart.ctx;
        const { body, footer, title } = tooltip;
        const { boxWidth, boxHeight } = options;
        const bodyFont = helpers_segment.toFont(options.bodyFont);
        const titleFont = helpers_segment.toFont(options.titleFont);
        const footerFont = helpers_segment.toFont(options.footerFont);
        const titleLineCount = title.length;
        const footerLineCount = footer.length;
        const bodyLineItemCount = body.length;
        const padding = helpers_segment.toPadding(options.padding);
        let height = padding.height;
        let width = 0;
        let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
        combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
        if (titleLineCount) {
          height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;
        }
        if (combinedBodyLength) {
          const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
          height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;
        }
        if (footerLineCount) {
          height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;
        }
        let widthPadding = 0;
        const maxLineWidth = function(line) {
          width = Math.max(width, ctx.measureText(line).width + widthPadding);
        };
        ctx.save();
        ctx.font = titleFont.string;
        helpers_segment.each(tooltip.title, maxLineWidth);
        ctx.font = bodyFont.string;
        helpers_segment.each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
        widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
        helpers_segment.each(body, (bodyItem) => {
          helpers_segment.each(bodyItem.before, maxLineWidth);
          helpers_segment.each(bodyItem.lines, maxLineWidth);
          helpers_segment.each(bodyItem.after, maxLineWidth);
        });
        widthPadding = 0;
        ctx.font = footerFont.string;
        helpers_segment.each(tooltip.footer, maxLineWidth);
        ctx.restore();
        width += padding.width;
        return {
          width,
          height
        };
      }
      function determineYAlign(chart, size) {
        const { y, height } = size;
        if (y < height / 2) {
          return "top";
        } else if (y > chart.height - height / 2) {
          return "bottom";
        }
        return "center";
      }
      function doesNotFitWithAlign(xAlign, chart, options, size) {
        const { x, width } = size;
        const caret = options.caretSize + options.caretPadding;
        if (xAlign === "left" && x + width + caret > chart.width) {
          return true;
        }
        if (xAlign === "right" && x - width - caret < 0) {
          return true;
        }
      }
      function determineXAlign(chart, options, size, yAlign) {
        const { x, width } = size;
        const { width: chartWidth, chartArea: { left, right } } = chart;
        let xAlign = "center";
        if (yAlign === "center") {
          xAlign = x <= (left + right) / 2 ? "left" : "right";
        } else if (x <= width / 2) {
          xAlign = "left";
        } else if (x >= chartWidth - width / 2) {
          xAlign = "right";
        }
        if (doesNotFitWithAlign(xAlign, chart, options, size)) {
          xAlign = "center";
        }
        return xAlign;
      }
      function determineAlignment(chart, options, size) {
        const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);
        return {
          xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),
          yAlign
        };
      }
      function alignX(size, xAlign) {
        let { x, width } = size;
        if (xAlign === "right") {
          x -= width;
        } else if (xAlign === "center") {
          x -= width / 2;
        }
        return x;
      }
      function alignY(size, yAlign, paddingAndSize) {
        let { y, height } = size;
        if (yAlign === "top") {
          y += paddingAndSize;
        } else if (yAlign === "bottom") {
          y -= height + paddingAndSize;
        } else {
          y -= height / 2;
        }
        return y;
      }
      function getBackgroundPoint(options, size, alignment, chart) {
        const { caretSize, caretPadding, cornerRadius } = options;
        const { xAlign, yAlign } = alignment;
        const paddingAndSize = caretSize + caretPadding;
        const { topLeft, topRight, bottomLeft, bottomRight } = helpers_segment.toTRBLCorners(cornerRadius);
        let x = alignX(size, xAlign);
        const y = alignY(size, yAlign, paddingAndSize);
        if (yAlign === "center") {
          if (xAlign === "left") {
            x += paddingAndSize;
          } else if (xAlign === "right") {
            x -= paddingAndSize;
          }
        } else if (xAlign === "left") {
          x -= Math.max(topLeft, bottomLeft) + caretSize;
        } else if (xAlign === "right") {
          x += Math.max(topRight, bottomRight) + caretSize;
        }
        return {
          x: helpers_segment._limitValue(x, 0, chart.width - size.width),
          y: helpers_segment._limitValue(y, 0, chart.height - size.height)
        };
      }
      function getAlignedX(tooltip, align, options) {
        const padding = helpers_segment.toPadding(options.padding);
        return align === "center" ? tooltip.x + tooltip.width / 2 : align === "right" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
      }
      function getBeforeAfterBodyLines(callback) {
        return pushOrConcat([], splitNewlines(callback));
      }
      function createTooltipContext(parent, tooltip, tooltipItems) {
        return helpers_segment.createContext(parent, {
          tooltip,
          tooltipItems,
          type: "tooltip"
        });
      }
      function overrideCallbacks(callbacks, context) {
        const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
        return override ? callbacks.override(override) : callbacks;
      }
      var defaultCallbacks = {
        beforeTitle: helpers_segment.noop,
        title(tooltipItems) {
          if (tooltipItems.length > 0) {
            const item = tooltipItems[0];
            const labels = item.chart.data.labels;
            const labelCount = labels ? labels.length : 0;
            if (this && this.options && this.options.mode === "dataset") {
              return item.dataset.label || "";
            } else if (item.label) {
              return item.label;
            } else if (labelCount > 0 && item.dataIndex < labelCount) {
              return labels[item.dataIndex];
            }
          }
          return "";
        },
        afterTitle: helpers_segment.noop,
        beforeBody: helpers_segment.noop,
        beforeLabel: helpers_segment.noop,
        label(tooltipItem) {
          if (this && this.options && this.options.mode === "dataset") {
            return tooltipItem.label + ": " + tooltipItem.formattedValue || tooltipItem.formattedValue;
          }
          let label = tooltipItem.dataset.label || "";
          if (label) {
            label += ": ";
          }
          const value = tooltipItem.formattedValue;
          if (!helpers_segment.isNullOrUndef(value)) {
            label += value;
          }
          return label;
        },
        labelColor(tooltipItem) {
          const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
          const options = meta.controller.getStyle(tooltipItem.dataIndex);
          return {
            borderColor: options.borderColor,
            backgroundColor: options.backgroundColor,
            borderWidth: options.borderWidth,
            borderDash: options.borderDash,
            borderDashOffset: options.borderDashOffset,
            borderRadius: 0
          };
        },
        labelTextColor() {
          return this.options.bodyColor;
        },
        labelPointStyle(tooltipItem) {
          const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
          const options = meta.controller.getStyle(tooltipItem.dataIndex);
          return {
            pointStyle: options.pointStyle,
            rotation: options.rotation
          };
        },
        afterLabel: helpers_segment.noop,
        afterBody: helpers_segment.noop,
        beforeFooter: helpers_segment.noop,
        footer: helpers_segment.noop,
        afterFooter: helpers_segment.noop
      };
      function invokeCallbackWithFallback(callbacks, name, ctx, arg) {
        const result = callbacks[name].call(ctx, arg);
        if (typeof result === "undefined") {
          return defaultCallbacks[name].call(ctx, arg);
        }
        return result;
      }
      var Tooltip = class extends Element {
        constructor(config) {
          super();
          this.opacity = 0;
          this._active = [];
          this._eventPosition = void 0;
          this._size = void 0;
          this._cachedAnimations = void 0;
          this._tooltipItems = [];
          this.$animations = void 0;
          this.$context = void 0;
          this.chart = config.chart;
          this.options = config.options;
          this.dataPoints = void 0;
          this.title = void 0;
          this.beforeBody = void 0;
          this.body = void 0;
          this.afterBody = void 0;
          this.footer = void 0;
          this.xAlign = void 0;
          this.yAlign = void 0;
          this.x = void 0;
          this.y = void 0;
          this.height = void 0;
          this.width = void 0;
          this.caretX = void 0;
          this.caretY = void 0;
          this.labelColors = void 0;
          this.labelPointStyles = void 0;
          this.labelTextColors = void 0;
        }
        initialize(options) {
          this.options = options;
          this._cachedAnimations = void 0;
          this.$context = void 0;
        }
        _resolveAnimations() {
          const cached = this._cachedAnimations;
          if (cached) {
            return cached;
          }
          const chart = this.chart;
          const options = this.options.setContext(this.getContext());
          const opts = options.enabled && chart.options.animation && options.animations;
          const animations = new Animations(this.chart, opts);
          if (opts._cacheable) {
            this._cachedAnimations = Object.freeze(animations);
          }
          return animations;
        }
        getContext() {
          return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
        }
        getTitle(context, options) {
          const { callbacks } = options;
          const beforeTitle = invokeCallbackWithFallback(callbacks, "beforeTitle", this, context);
          const title = invokeCallbackWithFallback(callbacks, "title", this, context);
          const afterTitle = invokeCallbackWithFallback(callbacks, "afterTitle", this, context);
          let lines = [];
          lines = pushOrConcat(lines, splitNewlines(beforeTitle));
          lines = pushOrConcat(lines, splitNewlines(title));
          lines = pushOrConcat(lines, splitNewlines(afterTitle));
          return lines;
        }
        getBeforeBody(tooltipItems, options) {
          return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "beforeBody", this, tooltipItems));
        }
        getBody(tooltipItems, options) {
          const { callbacks } = options;
          const bodyItems = [];
          helpers_segment.each(tooltipItems, (context) => {
            const bodyItem = {
              before: [],
              lines: [],
              after: []
            };
            const scoped = overrideCallbacks(callbacks, context);
            pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, "beforeLabel", this, context)));
            pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, "label", this, context));
            pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, "afterLabel", this, context)));
            bodyItems.push(bodyItem);
          });
          return bodyItems;
        }
        getAfterBody(tooltipItems, options) {
          return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "afterBody", this, tooltipItems));
        }
        getFooter(tooltipItems, options) {
          const { callbacks } = options;
          const beforeFooter = invokeCallbackWithFallback(callbacks, "beforeFooter", this, tooltipItems);
          const footer = invokeCallbackWithFallback(callbacks, "footer", this, tooltipItems);
          const afterFooter = invokeCallbackWithFallback(callbacks, "afterFooter", this, tooltipItems);
          let lines = [];
          lines = pushOrConcat(lines, splitNewlines(beforeFooter));
          lines = pushOrConcat(lines, splitNewlines(footer));
          lines = pushOrConcat(lines, splitNewlines(afterFooter));
          return lines;
        }
        _createItems(options) {
          const active = this._active;
          const data = this.chart.data;
          const labelColors = [];
          const labelPointStyles = [];
          const labelTextColors = [];
          let tooltipItems = [];
          let i, len;
          for (i = 0, len = active.length; i < len; ++i) {
            tooltipItems.push(createTooltipItem(this.chart, active[i]));
          }
          if (options.filter) {
            tooltipItems = tooltipItems.filter((element, index2, array) => options.filter(element, index2, array, data));
          }
          if (options.itemSort) {
            tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));
          }
          helpers_segment.each(tooltipItems, (context) => {
            const scoped = overrideCallbacks(options.callbacks, context);
            labelColors.push(invokeCallbackWithFallback(scoped, "labelColor", this, context));
            labelPointStyles.push(invokeCallbackWithFallback(scoped, "labelPointStyle", this, context));
            labelTextColors.push(invokeCallbackWithFallback(scoped, "labelTextColor", this, context));
          });
          this.labelColors = labelColors;
          this.labelPointStyles = labelPointStyles;
          this.labelTextColors = labelTextColors;
          this.dataPoints = tooltipItems;
          return tooltipItems;
        }
        update(changed, replay) {
          const options = this.options.setContext(this.getContext());
          const active = this._active;
          let properties;
          let tooltipItems = [];
          if (!active.length) {
            if (this.opacity !== 0) {
              properties = {
                opacity: 0
              };
            }
          } else {
            const position = positioners[options.position].call(this, active, this._eventPosition);
            tooltipItems = this._createItems(options);
            this.title = this.getTitle(tooltipItems, options);
            this.beforeBody = this.getBeforeBody(tooltipItems, options);
            this.body = this.getBody(tooltipItems, options);
            this.afterBody = this.getAfterBody(tooltipItems, options);
            this.footer = this.getFooter(tooltipItems, options);
            const size = this._size = getTooltipSize(this, options);
            const positionAndSize = Object.assign({}, position, size);
            const alignment = determineAlignment(this.chart, options, positionAndSize);
            const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
            this.xAlign = alignment.xAlign;
            this.yAlign = alignment.yAlign;
            properties = {
              opacity: 1,
              x: backgroundPoint.x,
              y: backgroundPoint.y,
              width: size.width,
              height: size.height,
              caretX: position.x,
              caretY: position.y
            };
          }
          this._tooltipItems = tooltipItems;
          this.$context = void 0;
          if (properties) {
            this._resolveAnimations().update(this, properties);
          }
          if (changed && options.external) {
            options.external.call(this, {
              chart: this.chart,
              tooltip: this,
              replay
            });
          }
        }
        drawCaret(tooltipPoint, ctx, size, options) {
          const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
          ctx.lineTo(caretPosition.x1, caretPosition.y1);
          ctx.lineTo(caretPosition.x2, caretPosition.y2);
          ctx.lineTo(caretPosition.x3, caretPosition.y3);
        }
        getCaretPosition(tooltipPoint, size, options) {
          const { xAlign, yAlign } = this;
          const { caretSize, cornerRadius } = options;
          const { topLeft, topRight, bottomLeft, bottomRight } = helpers_segment.toTRBLCorners(cornerRadius);
          const { x: ptX, y: ptY } = tooltipPoint;
          const { width, height } = size;
          let x1, x2, x3, y1, y2, y3;
          if (yAlign === "center") {
            y2 = ptY + height / 2;
            if (xAlign === "left") {
              x1 = ptX;
              x2 = x1 - caretSize;
              y1 = y2 + caretSize;
              y3 = y2 - caretSize;
            } else {
              x1 = ptX + width;
              x2 = x1 + caretSize;
              y1 = y2 - caretSize;
              y3 = y2 + caretSize;
            }
            x3 = x1;
          } else {
            if (xAlign === "left") {
              x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
            } else if (xAlign === "right") {
              x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
            } else {
              x2 = this.caretX;
            }
            if (yAlign === "top") {
              y1 = ptY;
              y2 = y1 - caretSize;
              x1 = x2 - caretSize;
              x3 = x2 + caretSize;
            } else {
              y1 = ptY + height;
              y2 = y1 + caretSize;
              x1 = x2 + caretSize;
              x3 = x2 - caretSize;
            }
            y3 = y1;
          }
          return {
            x1,
            x2,
            x3,
            y1,
            y2,
            y3
          };
        }
        drawTitle(pt, ctx, options) {
          const title = this.title;
          const length = title.length;
          let titleFont, titleSpacing, i;
          if (length) {
            const rtlHelper = helpers_segment.getRtlAdapter(options.rtl, this.x, this.width);
            pt.x = getAlignedX(this, options.titleAlign, options);
            ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
            ctx.textBaseline = "middle";
            titleFont = helpers_segment.toFont(options.titleFont);
            titleSpacing = options.titleSpacing;
            ctx.fillStyle = options.titleColor;
            ctx.font = titleFont.string;
            for (i = 0; i < length; ++i) {
              ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
              pt.y += titleFont.lineHeight + titleSpacing;
              if (i + 1 === length) {
                pt.y += options.titleMarginBottom - titleSpacing;
              }
            }
          }
        }
        _drawColorBox(ctx, pt, i, rtlHelper, options) {
          const labelColor = this.labelColors[i];
          const labelPointStyle = this.labelPointStyles[i];
          const { boxHeight, boxWidth } = options;
          const bodyFont = helpers_segment.toFont(options.bodyFont);
          const colorX = getAlignedX(this, "left", options);
          const rtlColorX = rtlHelper.x(colorX);
          const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
          const colorY = pt.y + yOffSet;
          if (options.usePointStyle) {
            const drawOptions = {
              radius: Math.min(boxWidth, boxHeight) / 2,
              pointStyle: labelPointStyle.pointStyle,
              rotation: labelPointStyle.rotation,
              borderWidth: 1
            };
            const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
            const centerY = colorY + boxHeight / 2;
            ctx.strokeStyle = options.multiKeyBackground;
            ctx.fillStyle = options.multiKeyBackground;
            helpers_segment.drawPoint(ctx, drawOptions, centerX, centerY);
            ctx.strokeStyle = labelColor.borderColor;
            ctx.fillStyle = labelColor.backgroundColor;
            helpers_segment.drawPoint(ctx, drawOptions, centerX, centerY);
          } else {
            ctx.lineWidth = helpers_segment.isObject(labelColor.borderWidth) ? Math.max(...Object.values(labelColor.borderWidth)) : labelColor.borderWidth || 1;
            ctx.strokeStyle = labelColor.borderColor;
            ctx.setLineDash(labelColor.borderDash || []);
            ctx.lineDashOffset = labelColor.borderDashOffset || 0;
            const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);
            const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);
            const borderRadius = helpers_segment.toTRBLCorners(labelColor.borderRadius);
            if (Object.values(borderRadius).some((v) => v !== 0)) {
              ctx.beginPath();
              ctx.fillStyle = options.multiKeyBackground;
              helpers_segment.addRoundedRectPath(ctx, {
                x: outerX,
                y: colorY,
                w: boxWidth,
                h: boxHeight,
                radius: borderRadius
              });
              ctx.fill();
              ctx.stroke();
              ctx.fillStyle = labelColor.backgroundColor;
              ctx.beginPath();
              helpers_segment.addRoundedRectPath(ctx, {
                x: innerX,
                y: colorY + 1,
                w: boxWidth - 2,
                h: boxHeight - 2,
                radius: borderRadius
              });
              ctx.fill();
            } else {
              ctx.fillStyle = options.multiKeyBackground;
              ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
              ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
              ctx.fillStyle = labelColor.backgroundColor;
              ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
            }
          }
          ctx.fillStyle = this.labelTextColors[i];
        }
        drawBody(pt, ctx, options) {
          const { body } = this;
          const { bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding } = options;
          const bodyFont = helpers_segment.toFont(options.bodyFont);
          let bodyLineHeight = bodyFont.lineHeight;
          let xLinePadding = 0;
          const rtlHelper = helpers_segment.getRtlAdapter(options.rtl, this.x, this.width);
          const fillLineOfText = function(line) {
            ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
            pt.y += bodyLineHeight + bodySpacing;
          };
          const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
          let bodyItem, textColor, lines, i, j, ilen, jlen;
          ctx.textAlign = bodyAlign;
          ctx.textBaseline = "middle";
          ctx.font = bodyFont.string;
          pt.x = getAlignedX(this, bodyAlignForCalculation, options);
          ctx.fillStyle = options.bodyColor;
          helpers_segment.each(this.beforeBody, fillLineOfText);
          xLinePadding = displayColors && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
          for (i = 0, ilen = body.length; i < ilen; ++i) {
            bodyItem = body[i];
            textColor = this.labelTextColors[i];
            ctx.fillStyle = textColor;
            helpers_segment.each(bodyItem.before, fillLineOfText);
            lines = bodyItem.lines;
            if (displayColors && lines.length) {
              this._drawColorBox(ctx, pt, i, rtlHelper, options);
              bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
            }
            for (j = 0, jlen = lines.length; j < jlen; ++j) {
              fillLineOfText(lines[j]);
              bodyLineHeight = bodyFont.lineHeight;
            }
            helpers_segment.each(bodyItem.after, fillLineOfText);
          }
          xLinePadding = 0;
          bodyLineHeight = bodyFont.lineHeight;
          helpers_segment.each(this.afterBody, fillLineOfText);
          pt.y -= bodySpacing;
        }
        drawFooter(pt, ctx, options) {
          const footer = this.footer;
          const length = footer.length;
          let footerFont, i;
          if (length) {
            const rtlHelper = helpers_segment.getRtlAdapter(options.rtl, this.x, this.width);
            pt.x = getAlignedX(this, options.footerAlign, options);
            pt.y += options.footerMarginTop;
            ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
            ctx.textBaseline = "middle";
            footerFont = helpers_segment.toFont(options.footerFont);
            ctx.fillStyle = options.footerColor;
            ctx.font = footerFont.string;
            for (i = 0; i < length; ++i) {
              ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
              pt.y += footerFont.lineHeight + options.footerSpacing;
            }
          }
        }
        drawBackground(pt, ctx, tooltipSize, options) {
          const { xAlign, yAlign } = this;
          const { x, y } = pt;
          const { width, height } = tooltipSize;
          const { topLeft, topRight, bottomLeft, bottomRight } = helpers_segment.toTRBLCorners(options.cornerRadius);
          ctx.fillStyle = options.backgroundColor;
          ctx.strokeStyle = options.borderColor;
          ctx.lineWidth = options.borderWidth;
          ctx.beginPath();
          ctx.moveTo(x + topLeft, y);
          if (yAlign === "top") {
            this.drawCaret(pt, ctx, tooltipSize, options);
          }
          ctx.lineTo(x + width - topRight, y);
          ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);
          if (yAlign === "center" && xAlign === "right") {
            this.drawCaret(pt, ctx, tooltipSize, options);
          }
          ctx.lineTo(x + width, y + height - bottomRight);
          ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);
          if (yAlign === "bottom") {
            this.drawCaret(pt, ctx, tooltipSize, options);
          }
          ctx.lineTo(x + bottomLeft, y + height);
          ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);
          if (yAlign === "center" && xAlign === "left") {
            this.drawCaret(pt, ctx, tooltipSize, options);
          }
          ctx.lineTo(x, y + topLeft);
          ctx.quadraticCurveTo(x, y, x + topLeft, y);
          ctx.closePath();
          ctx.fill();
          if (options.borderWidth > 0) {
            ctx.stroke();
          }
        }
        _updateAnimationTarget(options) {
          const chart = this.chart;
          const anims = this.$animations;
          const animX = anims && anims.x;
          const animY = anims && anims.y;
          if (animX || animY) {
            const position = positioners[options.position].call(this, this._active, this._eventPosition);
            if (!position) {
              return;
            }
            const size = this._size = getTooltipSize(this, options);
            const positionAndSize = Object.assign({}, position, this._size);
            const alignment = determineAlignment(chart, options, positionAndSize);
            const point = getBackgroundPoint(options, positionAndSize, alignment, chart);
            if (animX._to !== point.x || animY._to !== point.y) {
              this.xAlign = alignment.xAlign;
              this.yAlign = alignment.yAlign;
              this.width = size.width;
              this.height = size.height;
              this.caretX = position.x;
              this.caretY = position.y;
              this._resolveAnimations().update(this, point);
            }
          }
        }
        _willRender() {
          return !!this.opacity;
        }
        draw(ctx) {
          const options = this.options.setContext(this.getContext());
          let opacity = this.opacity;
          if (!opacity) {
            return;
          }
          this._updateAnimationTarget(options);
          const tooltipSize = {
            width: this.width,
            height: this.height
          };
          const pt = {
            x: this.x,
            y: this.y
          };
          opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
          const padding = helpers_segment.toPadding(options.padding);
          const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
          if (options.enabled && hasTooltipContent) {
            ctx.save();
            ctx.globalAlpha = opacity;
            this.drawBackground(pt, ctx, tooltipSize, options);
            helpers_segment.overrideTextDirection(ctx, options.textDirection);
            pt.y += padding.top;
            this.drawTitle(pt, ctx, options);
            this.drawBody(pt, ctx, options);
            this.drawFooter(pt, ctx, options);
            helpers_segment.restoreTextDirection(ctx, options.textDirection);
            ctx.restore();
          }
        }
        getActiveElements() {
          return this._active || [];
        }
        setActiveElements(activeElements, eventPosition) {
          const lastActive = this._active;
          const active = activeElements.map(({ datasetIndex, index: index2 }) => {
            const meta = this.chart.getDatasetMeta(datasetIndex);
            if (!meta) {
              throw new Error("Cannot find a dataset at index " + datasetIndex);
            }
            return {
              datasetIndex,
              element: meta.data[index2],
              index: index2
            };
          });
          const changed = !helpers_segment._elementsEqual(lastActive, active);
          const positionChanged = this._positionChanged(active, eventPosition);
          if (changed || positionChanged) {
            this._active = active;
            this._eventPosition = eventPosition;
            this._ignoreReplayEvents = true;
            this.update(true);
          }
        }
        handleEvent(e, replay, inChartArea = true) {
          if (replay && this._ignoreReplayEvents) {
            return false;
          }
          this._ignoreReplayEvents = false;
          const options = this.options;
          const lastActive = this._active || [];
          const active = this._getActiveElements(e, lastActive, replay, inChartArea);
          const positionChanged = this._positionChanged(active, e);
          const changed = replay || !helpers_segment._elementsEqual(active, lastActive) || positionChanged;
          if (changed) {
            this._active = active;
            if (options.enabled || options.external) {
              this._eventPosition = {
                x: e.x,
                y: e.y
              };
              this.update(true, replay);
            }
          }
          return changed;
        }
        _getActiveElements(e, lastActive, replay, inChartArea) {
          const options = this.options;
          if (e.type === "mouseout") {
            return [];
          }
          if (!inChartArea) {
            return lastActive;
          }
          const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);
          if (options.reverse) {
            active.reverse();
          }
          return active;
        }
        _positionChanged(active, e) {
          const { caretX, caretY, options } = this;
          const position = positioners[options.position].call(this, active, e);
          return position !== false && (caretX !== position.x || caretY !== position.y);
        }
      };
      __publicField(Tooltip, "positioners", positioners);
      var plugin_tooltip = {
        id: "tooltip",
        _element: Tooltip,
        positioners,
        afterInit(chart, _args, options) {
          if (options) {
            chart.tooltip = new Tooltip({
              chart,
              options
            });
          }
        },
        beforeUpdate(chart, _args, options) {
          if (chart.tooltip) {
            chart.tooltip.initialize(options);
          }
        },
        reset(chart, _args, options) {
          if (chart.tooltip) {
            chart.tooltip.initialize(options);
          }
        },
        afterDraw(chart) {
          const tooltip = chart.tooltip;
          if (tooltip && tooltip._willRender()) {
            const args = {
              tooltip
            };
            if (chart.notifyPlugins("beforeTooltipDraw", {
              ...args,
              cancelable: true
            }) === false) {
              return;
            }
            tooltip.draw(chart.ctx);
            chart.notifyPlugins("afterTooltipDraw", args);
          }
        },
        afterEvent(chart, args) {
          if (chart.tooltip) {
            const useFinalPosition = args.replay;
            if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
              args.changed = true;
            }
          }
        },
        defaults: {
          enabled: true,
          external: null,
          position: "average",
          backgroundColor: "rgba(0,0,0,0.8)",
          titleColor: "#fff",
          titleFont: {
            weight: "bold"
          },
          titleSpacing: 2,
          titleMarginBottom: 6,
          titleAlign: "left",
          bodyColor: "#fff",
          bodySpacing: 2,
          bodyFont: {},
          bodyAlign: "left",
          footerColor: "#fff",
          footerSpacing: 2,
          footerMarginTop: 6,
          footerFont: {
            weight: "bold"
          },
          footerAlign: "left",
          padding: 6,
          caretPadding: 2,
          caretSize: 5,
          cornerRadius: 6,
          boxHeight: (ctx, opts) => opts.bodyFont.size,
          boxWidth: (ctx, opts) => opts.bodyFont.size,
          multiKeyBackground: "#fff",
          displayColors: true,
          boxPadding: 0,
          borderColor: "rgba(0,0,0,0)",
          borderWidth: 0,
          animation: {
            duration: 400,
            easing: "easeOutQuart"
          },
          animations: {
            numbers: {
              type: "number",
              properties: [
                "x",
                "y",
                "width",
                "height",
                "caretX",
                "caretY"
              ]
            },
            opacity: {
              easing: "linear",
              duration: 200
            }
          },
          callbacks: defaultCallbacks
        },
        defaultRoutes: {
          bodyFont: "font",
          footerFont: "font",
          titleFont: "font"
        },
        descriptors: {
          _scriptable: (name) => name !== "filter" && name !== "itemSort" && name !== "external",
          _indexable: false,
          callbacks: {
            _scriptable: false,
            _indexable: false
          },
          animation: {
            _fallback: false
          },
          animations: {
            _fallback: "animation"
          }
        },
        additionalOptionScopes: [
          "interaction"
        ]
      };
      var plugins = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        Colors: plugin_colors,
        Decimation: plugin_decimation,
        Filler: index,
        Legend: plugin_legend,
        SubTitle: plugin_subtitle,
        Title: plugin_title,
        Tooltip: plugin_tooltip
      });
      var addIfString = (labels, raw, index2, addedLabels) => {
        if (typeof raw === "string") {
          index2 = labels.push(raw) - 1;
          addedLabels.unshift({
            index: index2,
            label: raw
          });
        } else if (isNaN(raw)) {
          index2 = null;
        }
        return index2;
      };
      function findOrAddLabel(labels, raw, index2, addedLabels) {
        const first = labels.indexOf(raw);
        if (first === -1) {
          return addIfString(labels, raw, index2, addedLabels);
        }
        const last = labels.lastIndexOf(raw);
        return first !== last ? index2 : first;
      }
      var validIndex = (index2, max) => index2 === null ? null : helpers_segment._limitValue(Math.round(index2), 0, max);
      function _getLabelForValue(value) {
        const labels = this.getLabels();
        if (value >= 0 && value < labels.length) {
          return labels[value];
        }
        return value;
      }
      var CategoryScale = class extends Scale {
        constructor(cfg) {
          super(cfg);
          this._startValue = void 0;
          this._valueRange = 0;
          this._addedLabels = [];
        }
        init(scaleOptions) {
          const added = this._addedLabels;
          if (added.length) {
            const labels = this.getLabels();
            for (const { index: index2, label } of added) {
              if (labels[index2] === label) {
                labels.splice(index2, 1);
              }
            }
            this._addedLabels = [];
          }
          super.init(scaleOptions);
        }
        parse(raw, index2) {
          if (helpers_segment.isNullOrUndef(raw)) {
            return null;
          }
          const labels = this.getLabels();
          index2 = isFinite(index2) && labels[index2] === raw ? index2 : findOrAddLabel(labels, raw, helpers_segment.valueOrDefault(index2, raw), this._addedLabels);
          return validIndex(index2, labels.length - 1);
        }
        determineDataLimits() {
          const { minDefined, maxDefined } = this.getUserBounds();
          let { min, max } = this.getMinMax(true);
          if (this.options.bounds === "ticks") {
            if (!minDefined) {
              min = 0;
            }
            if (!maxDefined) {
              max = this.getLabels().length - 1;
            }
          }
          this.min = min;
          this.max = max;
        }
        buildTicks() {
          const min = this.min;
          const max = this.max;
          const offset = this.options.offset;
          const ticks = [];
          let labels = this.getLabels();
          labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);
          this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
          this._startValue = this.min - (offset ? 0.5 : 0);
          for (let value = min; value <= max; value++) {
            ticks.push({
              value
            });
          }
          return ticks;
        }
        getLabelForValue(value) {
          return _getLabelForValue.call(this, value);
        }
        configure() {
          super.configure();
          if (!this.isHorizontal()) {
            this._reversePixels = !this._reversePixels;
          }
        }
        getPixelForValue(value) {
          if (typeof value !== "number") {
            value = this.parse(value);
          }
          return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
        }
        getPixelForTick(index2) {
          const ticks = this.ticks;
          if (index2 < 0 || index2 > ticks.length - 1) {
            return null;
          }
          return this.getPixelForValue(ticks[index2].value);
        }
        getValueForPixel(pixel) {
          return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
        }
        getBasePixel() {
          return this.bottom;
        }
      };
      __publicField(CategoryScale, "id", "category");
      __publicField(CategoryScale, "defaults", {
        ticks: {
          callback: _getLabelForValue
        }
      });
      function generateTicks$1(generationOptions, dataRange) {
        const ticks = [];
        const MIN_SPACING = 1e-14;
        const { bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds } = generationOptions;
        const unit = step || 1;
        const maxSpaces = maxTicks - 1;
        const { min: rmin, max: rmax } = dataRange;
        const minDefined = !helpers_segment.isNullOrUndef(min);
        const maxDefined = !helpers_segment.isNullOrUndef(max);
        const countDefined = !helpers_segment.isNullOrUndef(count);
        const minSpacing = (rmax - rmin) / (maxDigits + 1);
        let spacing = helpers_segment.niceNum((rmax - rmin) / maxSpaces / unit) * unit;
        let factor, niceMin, niceMax, numSpaces;
        if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
          return [
            {
              value: rmin
            },
            {
              value: rmax
            }
          ];
        }
        numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
        if (numSpaces > maxSpaces) {
          spacing = helpers_segment.niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
        }
        if (!helpers_segment.isNullOrUndef(precision)) {
          factor = Math.pow(10, precision);
          spacing = Math.ceil(spacing * factor) / factor;
        }
        if (bounds === "ticks") {
          niceMin = Math.floor(rmin / spacing) * spacing;
          niceMax = Math.ceil(rmax / spacing) * spacing;
        } else {
          niceMin = rmin;
          niceMax = rmax;
        }
        if (minDefined && maxDefined && step && helpers_segment.almostWhole((max - min) / step, spacing / 1e3)) {
          numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));
          spacing = (max - min) / numSpaces;
          niceMin = min;
          niceMax = max;
        } else if (countDefined) {
          niceMin = minDefined ? min : niceMin;
          niceMax = maxDefined ? max : niceMax;
          numSpaces = count - 1;
          spacing = (niceMax - niceMin) / numSpaces;
        } else {
          numSpaces = (niceMax - niceMin) / spacing;
          if (helpers_segment.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
            numSpaces = Math.round(numSpaces);
          } else {
            numSpaces = Math.ceil(numSpaces);
          }
        }
        const decimalPlaces = Math.max(helpers_segment._decimalPlaces(spacing), helpers_segment._decimalPlaces(niceMin));
        factor = Math.pow(10, helpers_segment.isNullOrUndef(precision) ? decimalPlaces : precision);
        niceMin = Math.round(niceMin * factor) / factor;
        niceMax = Math.round(niceMax * factor) / factor;
        let j = 0;
        if (minDefined) {
          if (includeBounds && niceMin !== min) {
            ticks.push({
              value: min
            });
            if (niceMin < min) {
              j++;
            }
            if (helpers_segment.almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {
              j++;
            }
          } else if (niceMin < min) {
            j++;
          }
        }
        for (; j < numSpaces; ++j) {
          const tickValue = Math.round((niceMin + j * spacing) * factor) / factor;
          if (maxDefined && tickValue > max) {
            break;
          }
          ticks.push({
            value: tickValue
          });
        }
        if (maxDefined && includeBounds && niceMax !== max) {
          if (ticks.length && helpers_segment.almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {
            ticks[ticks.length - 1].value = max;
          } else {
            ticks.push({
              value: max
            });
          }
        } else if (!maxDefined || niceMax === max) {
          ticks.push({
            value: niceMax
          });
        }
        return ticks;
      }
      function relativeLabelSize(value, minSpacing, { horizontal, minRotation }) {
        const rad = helpers_segment.toRadians(minRotation);
        const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 1e-3;
        const length = 0.75 * minSpacing * ("" + value).length;
        return Math.min(minSpacing / ratio, length);
      }
      var LinearScaleBase = class extends Scale {
        constructor(cfg) {
          super(cfg);
          this.start = void 0;
          this.end = void 0;
          this._startValue = void 0;
          this._endValue = void 0;
          this._valueRange = 0;
        }
        parse(raw, index2) {
          if (helpers_segment.isNullOrUndef(raw)) {
            return null;
          }
          if ((typeof raw === "number" || raw instanceof Number) && !isFinite(+raw)) {
            return null;
          }
          return +raw;
        }
        handleTickRangeOptions() {
          const { beginAtZero } = this.options;
          const { minDefined, maxDefined } = this.getUserBounds();
          let { min, max } = this;
          const setMin = (v) => min = minDefined ? min : v;
          const setMax = (v) => max = maxDefined ? max : v;
          if (beginAtZero) {
            const minSign = helpers_segment.sign(min);
            const maxSign = helpers_segment.sign(max);
            if (minSign < 0 && maxSign < 0) {
              setMax(0);
            } else if (minSign > 0 && maxSign > 0) {
              setMin(0);
            }
          }
          if (min === max) {
            let offset = max === 0 ? 1 : Math.abs(max * 0.05);
            setMax(max + offset);
            if (!beginAtZero) {
              setMin(min - offset);
            }
          }
          this.min = min;
          this.max = max;
        }
        getTickLimit() {
          const tickOpts = this.options.ticks;
          let { maxTicksLimit, stepSize } = tickOpts;
          let maxTicks;
          if (stepSize) {
            maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
            if (maxTicks > 1e3) {
              console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
              maxTicks = 1e3;
            }
          } else {
            maxTicks = this.computeTickLimit();
            maxTicksLimit = maxTicksLimit || 11;
          }
          if (maxTicksLimit) {
            maxTicks = Math.min(maxTicksLimit, maxTicks);
          }
          return maxTicks;
        }
        computeTickLimit() {
          return Number.POSITIVE_INFINITY;
        }
        buildTicks() {
          const opts = this.options;
          const tickOpts = opts.ticks;
          let maxTicks = this.getTickLimit();
          maxTicks = Math.max(2, maxTicks);
          const numericGeneratorOptions = {
            maxTicks,
            bounds: opts.bounds,
            min: opts.min,
            max: opts.max,
            precision: tickOpts.precision,
            step: tickOpts.stepSize,
            count: tickOpts.count,
            maxDigits: this._maxDigits(),
            horizontal: this.isHorizontal(),
            minRotation: tickOpts.minRotation || 0,
            includeBounds: tickOpts.includeBounds !== false
          };
          const dataRange = this._range || this;
          const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
          if (opts.bounds === "ticks") {
            helpers_segment._setMinAndMaxByKey(ticks, this, "value");
          }
          if (opts.reverse) {
            ticks.reverse();
            this.start = this.max;
            this.end = this.min;
          } else {
            this.start = this.min;
            this.end = this.max;
          }
          return ticks;
        }
        configure() {
          const ticks = this.ticks;
          let start = this.min;
          let end = this.max;
          super.configure();
          if (this.options.offset && ticks.length) {
            const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
            start -= offset;
            end += offset;
          }
          this._startValue = start;
          this._endValue = end;
          this._valueRange = end - start;
        }
        getLabelForValue(value) {
          return helpers_segment.formatNumber(value, this.chart.options.locale, this.options.ticks.format);
        }
      };
      var LinearScale = class extends LinearScaleBase {
        determineDataLimits() {
          const { min, max } = this.getMinMax(true);
          this.min = helpers_segment.isNumberFinite(min) ? min : 0;
          this.max = helpers_segment.isNumberFinite(max) ? max : 1;
          this.handleTickRangeOptions();
        }
        computeTickLimit() {
          const horizontal = this.isHorizontal();
          const length = horizontal ? this.width : this.height;
          const minRotation = helpers_segment.toRadians(this.options.ticks.minRotation);
          const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 1e-3;
          const tickFont = this._resolveTickFontOptions(0);
          return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
        }
        getPixelForValue(value) {
          return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
        }
        getValueForPixel(pixel) {
          return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
        }
      };
      __publicField(LinearScale, "id", "linear");
      __publicField(LinearScale, "defaults", {
        ticks: {
          callback: helpers_segment.Ticks.formatters.numeric
        }
      });
      var log10Floor = (v) => Math.floor(helpers_segment.log10(v));
      var changeExponent = (v, m) => Math.pow(10, log10Floor(v) + m);
      function isMajor(tickVal) {
        const remain = tickVal / Math.pow(10, log10Floor(tickVal));
        return remain === 1;
      }
      function steps(min, max, rangeExp) {
        const rangeStep = Math.pow(10, rangeExp);
        const start = Math.floor(min / rangeStep);
        const end = Math.ceil(max / rangeStep);
        return end - start;
      }
      function startExp(min, max) {
        const range = max - min;
        let rangeExp = log10Floor(range);
        while (steps(min, max, rangeExp) > 10) {
          rangeExp++;
        }
        while (steps(min, max, rangeExp) < 10) {
          rangeExp--;
        }
        return Math.min(rangeExp, log10Floor(min));
      }
      function generateTicks(generationOptions, { min, max }) {
        min = helpers_segment.finiteOrDefault(generationOptions.min, min);
        const ticks = [];
        const minExp = log10Floor(min);
        let exp = startExp(min, max);
        let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
        const stepSize = Math.pow(10, exp);
        const base = minExp > exp ? Math.pow(10, minExp) : 0;
        const start = Math.round((min - base) * precision) / precision;
        const offset = Math.floor((min - base) / stepSize / 10) * stepSize * 10;
        let significand = Math.floor((start - offset) / Math.pow(10, exp));
        let value = helpers_segment.finiteOrDefault(generationOptions.min, Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision);
        while (value < max) {
          ticks.push({
            value,
            major: isMajor(value),
            significand
          });
          if (significand >= 10) {
            significand = significand < 15 ? 15 : 20;
          } else {
            significand++;
          }
          if (significand >= 20) {
            exp++;
            significand = 2;
            precision = exp >= 0 ? 1 : precision;
          }
          value = Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision;
        }
        const lastTick = helpers_segment.finiteOrDefault(generationOptions.max, value);
        ticks.push({
          value: lastTick,
          major: isMajor(lastTick),
          significand
        });
        return ticks;
      }
      var LogarithmicScale = class extends Scale {
        constructor(cfg) {
          super(cfg);
          this.start = void 0;
          this.end = void 0;
          this._startValue = void 0;
          this._valueRange = 0;
        }
        parse(raw, index2) {
          const value = LinearScaleBase.prototype.parse.apply(this, [
            raw,
            index2
          ]);
          if (value === 0) {
            this._zero = true;
            return void 0;
          }
          return helpers_segment.isNumberFinite(value) && value > 0 ? value : null;
        }
        determineDataLimits() {
          const { min, max } = this.getMinMax(true);
          this.min = helpers_segment.isNumberFinite(min) ? Math.max(0, min) : null;
          this.max = helpers_segment.isNumberFinite(max) ? Math.max(0, max) : null;
          if (this.options.beginAtZero) {
            this._zero = true;
          }
          if (this._zero && this.min !== this._suggestedMin && !helpers_segment.isNumberFinite(this._userMin)) {
            this.min = min === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);
          }
          this.handleTickRangeOptions();
        }
        handleTickRangeOptions() {
          const { minDefined, maxDefined } = this.getUserBounds();
          let min = this.min;
          let max = this.max;
          const setMin = (v) => min = minDefined ? min : v;
          const setMax = (v) => max = maxDefined ? max : v;
          if (min === max) {
            if (min <= 0) {
              setMin(1);
              setMax(10);
            } else {
              setMin(changeExponent(min, -1));
              setMax(changeExponent(max, 1));
            }
          }
          if (min <= 0) {
            setMin(changeExponent(max, -1));
          }
          if (max <= 0) {
            setMax(changeExponent(min, 1));
          }
          this.min = min;
          this.max = max;
        }
        buildTicks() {
          const opts = this.options;
          const generationOptions = {
            min: this._userMin,
            max: this._userMax
          };
          const ticks = generateTicks(generationOptions, this);
          if (opts.bounds === "ticks") {
            helpers_segment._setMinAndMaxByKey(ticks, this, "value");
          }
          if (opts.reverse) {
            ticks.reverse();
            this.start = this.max;
            this.end = this.min;
          } else {
            this.start = this.min;
            this.end = this.max;
          }
          return ticks;
        }
        getLabelForValue(value) {
          return value === void 0 ? "0" : helpers_segment.formatNumber(value, this.chart.options.locale, this.options.ticks.format);
        }
        configure() {
          const start = this.min;
          super.configure();
          this._startValue = helpers_segment.log10(start);
          this._valueRange = helpers_segment.log10(this.max) - helpers_segment.log10(start);
        }
        getPixelForValue(value) {
          if (value === void 0 || value === 0) {
            value = this.min;
          }
          if (value === null || isNaN(value)) {
            return NaN;
          }
          return this.getPixelForDecimal(value === this.min ? 0 : (helpers_segment.log10(value) - this._startValue) / this._valueRange);
        }
        getValueForPixel(pixel) {
          const decimal = this.getDecimalForPixel(pixel);
          return Math.pow(10, this._startValue + decimal * this._valueRange);
        }
      };
      __publicField(LogarithmicScale, "id", "logarithmic");
      __publicField(LogarithmicScale, "defaults", {
        ticks: {
          callback: helpers_segment.Ticks.formatters.logarithmic,
          major: {
            enabled: true
          }
        }
      });
      function getTickBackdropHeight(opts) {
        const tickOpts = opts.ticks;
        if (tickOpts.display && opts.display) {
          const padding = helpers_segment.toPadding(tickOpts.backdropPadding);
          return helpers_segment.valueOrDefault(tickOpts.font && tickOpts.font.size, helpers_segment.defaults.font.size) + padding.height;
        }
        return 0;
      }
      function measureLabelSize(ctx, font, label) {
        label = helpers_segment.isArray(label) ? label : [
          label
        ];
        return {
          w: helpers_segment._longestText(ctx, font.string, label),
          h: label.length * font.lineHeight
        };
      }
      function determineLimits(angle, pos, size, min, max) {
        if (angle === min || angle === max) {
          return {
            start: pos - size / 2,
            end: pos + size / 2
          };
        } else if (angle < min || angle > max) {
          return {
            start: pos - size,
            end: pos
          };
        }
        return {
          start: pos,
          end: pos + size
        };
      }
      function fitWithPointLabels(scale) {
        const orig = {
          l: scale.left + scale._padding.left,
          r: scale.right - scale._padding.right,
          t: scale.top + scale._padding.top,
          b: scale.bottom - scale._padding.bottom
        };
        const limits = Object.assign({}, orig);
        const labelSizes = [];
        const padding = [];
        const valueCount = scale._pointLabels.length;
        const pointLabelOpts = scale.options.pointLabels;
        const additionalAngle = pointLabelOpts.centerPointLabels ? helpers_segment.PI / valueCount : 0;
        for (let i = 0; i < valueCount; i++) {
          const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));
          padding[i] = opts.padding;
          const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);
          const plFont = helpers_segment.toFont(opts.font);
          const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);
          labelSizes[i] = textSize;
          const angleRadians = helpers_segment._normalizeAngle(scale.getIndexAngle(i) + additionalAngle);
          const angle = Math.round(helpers_segment.toDegrees(angleRadians));
          const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
          const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
          updateLimits(limits, orig, angleRadians, hLimits, vLimits);
        }
        scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);
        scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
      }
      function updateLimits(limits, orig, angle, hLimits, vLimits) {
        const sin = Math.abs(Math.sin(angle));
        const cos = Math.abs(Math.cos(angle));
        let x = 0;
        let y = 0;
        if (hLimits.start < orig.l) {
          x = (orig.l - hLimits.start) / sin;
          limits.l = Math.min(limits.l, orig.l - x);
        } else if (hLimits.end > orig.r) {
          x = (hLimits.end - orig.r) / sin;
          limits.r = Math.max(limits.r, orig.r + x);
        }
        if (vLimits.start < orig.t) {
          y = (orig.t - vLimits.start) / cos;
          limits.t = Math.min(limits.t, orig.t - y);
        } else if (vLimits.end > orig.b) {
          y = (vLimits.end - orig.b) / cos;
          limits.b = Math.max(limits.b, orig.b + y);
        }
      }
      function createPointLabelItem(scale, index2, itemOpts) {
        const outerDistance = scale.drawingArea;
        const { extra, additionalAngle, padding, size } = itemOpts;
        const pointLabelPosition = scale.getPointPosition(index2, outerDistance + extra + padding, additionalAngle);
        const angle = Math.round(helpers_segment.toDegrees(helpers_segment._normalizeAngle(pointLabelPosition.angle + helpers_segment.HALF_PI)));
        const y = yForAngle(pointLabelPosition.y, size.h, angle);
        const textAlign = getTextAlignForAngle(angle);
        const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
        return {
          visible: true,
          x: pointLabelPosition.x,
          y,
          textAlign,
          left,
          top: y,
          right: left + size.w,
          bottom: y + size.h
        };
      }
      function isNotOverlapped(item, area) {
        if (!area) {
          return true;
        }
        const { left, top, right, bottom } = item;
        const apexesInArea = helpers_segment._isPointInArea({
          x: left,
          y: top
        }, area) || helpers_segment._isPointInArea({
          x: left,
          y: bottom
        }, area) || helpers_segment._isPointInArea({
          x: right,
          y: top
        }, area) || helpers_segment._isPointInArea({
          x: right,
          y: bottom
        }, area);
        return !apexesInArea;
      }
      function buildPointLabelItems(scale, labelSizes, padding) {
        const items = [];
        const valueCount = scale._pointLabels.length;
        const opts = scale.options;
        const { centerPointLabels, display } = opts.pointLabels;
        const itemOpts = {
          extra: getTickBackdropHeight(opts) / 2,
          additionalAngle: centerPointLabels ? helpers_segment.PI / valueCount : 0
        };
        let area;
        for (let i = 0; i < valueCount; i++) {
          itemOpts.padding = padding[i];
          itemOpts.size = labelSizes[i];
          const item = createPointLabelItem(scale, i, itemOpts);
          items.push(item);
          if (display === "auto") {
            item.visible = isNotOverlapped(item, area);
            if (item.visible) {
              area = item;
            }
          }
        }
        return items;
      }
      function getTextAlignForAngle(angle) {
        if (angle === 0 || angle === 180) {
          return "center";
        } else if (angle < 180) {
          return "left";
        }
        return "right";
      }
      function leftForTextAlign(x, w, align) {
        if (align === "right") {
          x -= w;
        } else if (align === "center") {
          x -= w / 2;
        }
        return x;
      }
      function yForAngle(y, h, angle) {
        if (angle === 90 || angle === 270) {
          y -= h / 2;
        } else if (angle > 270 || angle < 90) {
          y -= h;
        }
        return y;
      }
      function drawPointLabelBox(ctx, opts, item) {
        const { left, top, right, bottom } = item;
        const { backdropColor } = opts;
        if (!helpers_segment.isNullOrUndef(backdropColor)) {
          const borderRadius = helpers_segment.toTRBLCorners(opts.borderRadius);
          const padding = helpers_segment.toPadding(opts.backdropPadding);
          ctx.fillStyle = backdropColor;
          const backdropLeft = left - padding.left;
          const backdropTop = top - padding.top;
          const backdropWidth = right - left + padding.width;
          const backdropHeight = bottom - top + padding.height;
          if (Object.values(borderRadius).some((v) => v !== 0)) {
            ctx.beginPath();
            helpers_segment.addRoundedRectPath(ctx, {
              x: backdropLeft,
              y: backdropTop,
              w: backdropWidth,
              h: backdropHeight,
              radius: borderRadius
            });
            ctx.fill();
          } else {
            ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);
          }
        }
      }
      function drawPointLabels(scale, labelCount) {
        const { ctx, options: { pointLabels } } = scale;
        for (let i = labelCount - 1; i >= 0; i--) {
          const item = scale._pointLabelItems[i];
          if (!item.visible) {
            continue;
          }
          const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));
          drawPointLabelBox(ctx, optsAtIndex, item);
          const plFont = helpers_segment.toFont(optsAtIndex.font);
          const { x, y, textAlign } = item;
          helpers_segment.renderText(ctx, scale._pointLabels[i], x, y + plFont.lineHeight / 2, plFont, {
            color: optsAtIndex.color,
            textAlign,
            textBaseline: "middle"
          });
        }
      }
      function pathRadiusLine(scale, radius, circular, labelCount) {
        const { ctx } = scale;
        if (circular) {
          ctx.arc(scale.xCenter, scale.yCenter, radius, 0, helpers_segment.TAU);
        } else {
          let pointPosition = scale.getPointPosition(0, radius);
          ctx.moveTo(pointPosition.x, pointPosition.y);
          for (let i = 1; i < labelCount; i++) {
            pointPosition = scale.getPointPosition(i, radius);
            ctx.lineTo(pointPosition.x, pointPosition.y);
          }
        }
      }
      function drawRadiusLine(scale, gridLineOpts, radius, labelCount, borderOpts) {
        const ctx = scale.ctx;
        const circular = gridLineOpts.circular;
        const { color, lineWidth } = gridLineOpts;
        if (!circular && !labelCount || !color || !lineWidth || radius < 0) {
          return;
        }
        ctx.save();
        ctx.strokeStyle = color;
        ctx.lineWidth = lineWidth;
        ctx.setLineDash(borderOpts.dash);
        ctx.lineDashOffset = borderOpts.dashOffset;
        ctx.beginPath();
        pathRadiusLine(scale, radius, circular, labelCount);
        ctx.closePath();
        ctx.stroke();
        ctx.restore();
      }
      function createPointLabelContext(parent, index2, label) {
        return helpers_segment.createContext(parent, {
          label,
          index: index2,
          type: "pointLabel"
        });
      }
      var RadialLinearScale = class extends LinearScaleBase {
        constructor(cfg) {
          super(cfg);
          this.xCenter = void 0;
          this.yCenter = void 0;
          this.drawingArea = void 0;
          this._pointLabels = [];
          this._pointLabelItems = [];
        }
        setDimensions() {
          const padding = this._padding = helpers_segment.toPadding(getTickBackdropHeight(this.options) / 2);
          const w = this.width = this.maxWidth - padding.width;
          const h = this.height = this.maxHeight - padding.height;
          this.xCenter = Math.floor(this.left + w / 2 + padding.left);
          this.yCenter = Math.floor(this.top + h / 2 + padding.top);
          this.drawingArea = Math.floor(Math.min(w, h) / 2);
        }
        determineDataLimits() {
          const { min, max } = this.getMinMax(false);
          this.min = helpers_segment.isNumberFinite(min) && !isNaN(min) ? min : 0;
          this.max = helpers_segment.isNumberFinite(max) && !isNaN(max) ? max : 0;
          this.handleTickRangeOptions();
        }
        computeTickLimit() {
          return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
        }
        generateTickLabels(ticks) {
          LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
          this._pointLabels = this.getLabels().map((value, index2) => {
            const label = helpers_segment.callback(this.options.pointLabels.callback, [
              value,
              index2
            ], this);
            return label || label === 0 ? label : "";
          }).filter((v, i) => this.chart.getDataVisibility(i));
        }
        fit() {
          const opts = this.options;
          if (opts.display && opts.pointLabels.display) {
            fitWithPointLabels(this);
          } else {
            this.setCenterPoint(0, 0, 0, 0);
          }
        }
        setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
          this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
          this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
          this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
        }
        getIndexAngle(index2) {
          const angleMultiplier = helpers_segment.TAU / (this._pointLabels.length || 1);
          const startAngle = this.options.startAngle || 0;
          return helpers_segment._normalizeAngle(index2 * angleMultiplier + helpers_segment.toRadians(startAngle));
        }
        getDistanceFromCenterForValue(value) {
          if (helpers_segment.isNullOrUndef(value)) {
            return NaN;
          }
          const scalingFactor = this.drawingArea / (this.max - this.min);
          if (this.options.reverse) {
            return (this.max - value) * scalingFactor;
          }
          return (value - this.min) * scalingFactor;
        }
        getValueForDistanceFromCenter(distance) {
          if (helpers_segment.isNullOrUndef(distance)) {
            return NaN;
          }
          const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
          return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
        }
        getPointLabelContext(index2) {
          const pointLabels = this._pointLabels || [];
          if (index2 >= 0 && index2 < pointLabels.length) {
            const pointLabel = pointLabels[index2];
            return createPointLabelContext(this.getContext(), index2, pointLabel);
          }
        }
        getPointPosition(index2, distanceFromCenter, additionalAngle = 0) {
          const angle = this.getIndexAngle(index2) - helpers_segment.HALF_PI + additionalAngle;
          return {
            x: Math.cos(angle) * distanceFromCenter + this.xCenter,
            y: Math.sin(angle) * distanceFromCenter + this.yCenter,
            angle
          };
        }
        getPointPositionForValue(index2, value) {
          return this.getPointPosition(index2, this.getDistanceFromCenterForValue(value));
        }
        getBasePosition(index2) {
          return this.getPointPositionForValue(index2 || 0, this.getBaseValue());
        }
        getPointLabelPosition(index2) {
          const { left, top, right, bottom } = this._pointLabelItems[index2];
          return {
            left,
            top,
            right,
            bottom
          };
        }
        drawBackground() {
          const { backgroundColor, grid: { circular } } = this.options;
          if (backgroundColor) {
            const ctx = this.ctx;
            ctx.save();
            ctx.beginPath();
            pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
            ctx.closePath();
            ctx.fillStyle = backgroundColor;
            ctx.fill();
            ctx.restore();
          }
        }
        drawGrid() {
          const ctx = this.ctx;
          const opts = this.options;
          const { angleLines, grid, border } = opts;
          const labelCount = this._pointLabels.length;
          let i, offset, position;
          if (opts.pointLabels.display) {
            drawPointLabels(this, labelCount);
          }
          if (grid.display) {
            this.ticks.forEach((tick, index2) => {
              if (index2 !== 0) {
                offset = this.getDistanceFromCenterForValue(tick.value);
                const context = this.getContext(index2);
                const optsAtIndex = grid.setContext(context);
                const optsAtIndexBorder = border.setContext(context);
                drawRadiusLine(this, optsAtIndex, offset, labelCount, optsAtIndexBorder);
              }
            });
          }
          if (angleLines.display) {
            ctx.save();
            for (i = labelCount - 1; i >= 0; i--) {
              const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));
              const { color, lineWidth } = optsAtIndex;
              if (!lineWidth || !color) {
                continue;
              }
              ctx.lineWidth = lineWidth;
              ctx.strokeStyle = color;
              ctx.setLineDash(optsAtIndex.borderDash);
              ctx.lineDashOffset = optsAtIndex.borderDashOffset;
              offset = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);
              position = this.getPointPosition(i, offset);
              ctx.beginPath();
              ctx.moveTo(this.xCenter, this.yCenter);
              ctx.lineTo(position.x, position.y);
              ctx.stroke();
            }
            ctx.restore();
          }
        }
        drawBorder() {
        }
        drawLabels() {
          const ctx = this.ctx;
          const opts = this.options;
          const tickOpts = opts.ticks;
          if (!tickOpts.display) {
            return;
          }
          const startAngle = this.getIndexAngle(0);
          let offset, width;
          ctx.save();
          ctx.translate(this.xCenter, this.yCenter);
          ctx.rotate(startAngle);
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          this.ticks.forEach((tick, index2) => {
            if (index2 === 0 && !opts.reverse) {
              return;
            }
            const optsAtIndex = tickOpts.setContext(this.getContext(index2));
            const tickFont = helpers_segment.toFont(optsAtIndex.font);
            offset = this.getDistanceFromCenterForValue(this.ticks[index2].value);
            if (optsAtIndex.showLabelBackdrop) {
              ctx.font = tickFont.string;
              width = ctx.measureText(tick.label).width;
              ctx.fillStyle = optsAtIndex.backdropColor;
              const padding = helpers_segment.toPadding(optsAtIndex.backdropPadding);
              ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);
            }
            helpers_segment.renderText(ctx, tick.label, 0, -offset, tickFont, {
              color: optsAtIndex.color
            });
          });
          ctx.restore();
        }
        drawTitle() {
        }
      };
      __publicField(RadialLinearScale, "id", "radialLinear");
      __publicField(RadialLinearScale, "defaults", {
        display: true,
        animate: true,
        position: "chartArea",
        angleLines: {
          display: true,
          lineWidth: 1,
          borderDash: [],
          borderDashOffset: 0
        },
        grid: {
          circular: false
        },
        startAngle: 0,
        ticks: {
          showLabelBackdrop: true,
          callback: helpers_segment.Ticks.formatters.numeric
        },
        pointLabels: {
          backdropColor: void 0,
          backdropPadding: 2,
          display: true,
          font: {
            size: 10
          },
          callback(label) {
            return label;
          },
          padding: 5,
          centerPointLabels: false
        }
      });
      __publicField(RadialLinearScale, "defaultRoutes", {
        "angleLines.color": "borderColor",
        "pointLabels.color": "color",
        "ticks.color": "color"
      });
      __publicField(RadialLinearScale, "descriptors", {
        angleLines: {
          _fallback: "grid"
        }
      });
      var INTERVALS = {
        millisecond: {
          common: true,
          size: 1,
          steps: 1e3
        },
        second: {
          common: true,
          size: 1e3,
          steps: 60
        },
        minute: {
          common: true,
          size: 6e4,
          steps: 60
        },
        hour: {
          common: true,
          size: 36e5,
          steps: 24
        },
        day: {
          common: true,
          size: 864e5,
          steps: 30
        },
        week: {
          common: false,
          size: 6048e5,
          steps: 4
        },
        month: {
          common: true,
          size: 2628e6,
          steps: 12
        },
        quarter: {
          common: false,
          size: 7884e6,
          steps: 4
        },
        year: {
          common: true,
          size: 3154e7
        }
      };
      var UNITS = /* @__PURE__ */ Object.keys(INTERVALS);
      function sorter(a, b) {
        return a - b;
      }
      function parse(scale, input) {
        if (helpers_segment.isNullOrUndef(input)) {
          return null;
        }
        const adapter = scale._adapter;
        const { parser, round, isoWeekday } = scale._parseOpts;
        let value = input;
        if (typeof parser === "function") {
          value = parser(value);
        }
        if (!helpers_segment.isNumberFinite(value)) {
          value = typeof parser === "string" ? adapter.parse(value, parser) : adapter.parse(value);
        }
        if (value === null) {
          return null;
        }
        if (round) {
          value = round === "week" && (helpers_segment.isNumber(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, "isoWeek", isoWeekday) : adapter.startOf(value, round);
        }
        return +value;
      }
      function determineUnitForAutoTicks(minUnit, min, max, capacity) {
        const ilen = UNITS.length;
        for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
          const interval = INTERVALS[UNITS[i]];
          const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
          if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
            return UNITS[i];
          }
        }
        return UNITS[ilen - 1];
      }
      function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
        for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {
          const unit = UNITS[i];
          if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {
            return unit;
          }
        }
        return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
      }
      function determineMajorUnit(unit) {
        for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
          if (INTERVALS[UNITS[i]].common) {
            return UNITS[i];
          }
        }
      }
      function addTick(ticks, time, timestamps) {
        if (!timestamps) {
          ticks[time] = true;
        } else if (timestamps.length) {
          const { lo, hi } = helpers_segment._lookup(timestamps, time);
          const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
          ticks[timestamp] = true;
        }
      }
      function setMajorTicks(scale, ticks, map2, majorUnit) {
        const adapter = scale._adapter;
        const first = +adapter.startOf(ticks[0].value, majorUnit);
        const last = ticks[ticks.length - 1].value;
        let major, index2;
        for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
          index2 = map2[major];
          if (index2 >= 0) {
            ticks[index2].major = true;
          }
        }
        return ticks;
      }
      function ticksFromTimestamps(scale, values, majorUnit) {
        const ticks = [];
        const map2 = {};
        const ilen = values.length;
        let i, value;
        for (i = 0; i < ilen; ++i) {
          value = values[i];
          map2[value] = i;
          ticks.push({
            value,
            major: false
          });
        }
        return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map2, majorUnit);
      }
      var TimeScale = class extends Scale {
        constructor(props) {
          super(props);
          this._cache = {
            data: [],
            labels: [],
            all: []
          };
          this._unit = "day";
          this._majorUnit = void 0;
          this._offsets = {};
          this._normalized = false;
          this._parseOpts = void 0;
        }
        init(scaleOpts, opts = {}) {
          const time = scaleOpts.time || (scaleOpts.time = {});
          const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
          adapter.init(opts);
          helpers_segment.mergeIf(time.displayFormats, adapter.formats());
          this._parseOpts = {
            parser: time.parser,
            round: time.round,
            isoWeekday: time.isoWeekday
          };
          super.init(scaleOpts);
          this._normalized = opts.normalized;
        }
        parse(raw, index2) {
          if (raw === void 0) {
            return null;
          }
          return parse(this, raw);
        }
        beforeLayout() {
          super.beforeLayout();
          this._cache = {
            data: [],
            labels: [],
            all: []
          };
        }
        determineDataLimits() {
          const options = this.options;
          const adapter = this._adapter;
          const unit = options.time.unit || "day";
          let { min, max, minDefined, maxDefined } = this.getUserBounds();
          function _applyBounds(bounds) {
            if (!minDefined && !isNaN(bounds.min)) {
              min = Math.min(min, bounds.min);
            }
            if (!maxDefined && !isNaN(bounds.max)) {
              max = Math.max(max, bounds.max);
            }
          }
          if (!minDefined || !maxDefined) {
            _applyBounds(this._getLabelBounds());
            if (options.bounds !== "ticks" || options.ticks.source !== "labels") {
              _applyBounds(this.getMinMax(false));
            }
          }
          min = helpers_segment.isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
          max = helpers_segment.isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;
          this.min = Math.min(min, max - 1);
          this.max = Math.max(min + 1, max);
        }
        _getLabelBounds() {
          const arr = this.getLabelTimestamps();
          let min = Number.POSITIVE_INFINITY;
          let max = Number.NEGATIVE_INFINITY;
          if (arr.length) {
            min = arr[0];
            max = arr[arr.length - 1];
          }
          return {
            min,
            max
          };
        }
        buildTicks() {
          const options = this.options;
          const timeOpts = options.time;
          const tickOpts = options.ticks;
          const timestamps = tickOpts.source === "labels" ? this.getLabelTimestamps() : this._generate();
          if (options.bounds === "ticks" && timestamps.length) {
            this.min = this._userMin || timestamps[0];
            this.max = this._userMax || timestamps[timestamps.length - 1];
          }
          const min = this.min;
          const max = this.max;
          const ticks = helpers_segment._filterBetween(timestamps, min, max);
          this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
          this._majorUnit = !tickOpts.major.enabled || this._unit === "year" ? void 0 : determineMajorUnit(this._unit);
          this.initOffsets(timestamps);
          if (options.reverse) {
            ticks.reverse();
          }
          return ticksFromTimestamps(this, ticks, this._majorUnit);
        }
        afterAutoSkip() {
          if (this.options.offsetAfterAutoskip) {
            this.initOffsets(this.ticks.map((tick) => +tick.value));
          }
        }
        initOffsets(timestamps = []) {
          let start = 0;
          let end = 0;
          let first, last;
          if (this.options.offset && timestamps.length) {
            first = this.getDecimalForValue(timestamps[0]);
            if (timestamps.length === 1) {
              start = 1 - first;
            } else {
              start = (this.getDecimalForValue(timestamps[1]) - first) / 2;
            }
            last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
            if (timestamps.length === 1) {
              end = last;
            } else {
              end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
            }
          }
          const limit = timestamps.length < 3 ? 0.5 : 0.25;
          start = helpers_segment._limitValue(start, 0, limit);
          end = helpers_segment._limitValue(end, 0, limit);
          this._offsets = {
            start,
            end,
            factor: 1 / (start + 1 + end)
          };
        }
        _generate() {
          const adapter = this._adapter;
          const min = this.min;
          const max = this.max;
          const options = this.options;
          const timeOpts = options.time;
          const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));
          const stepSize = helpers_segment.valueOrDefault(options.ticks.stepSize, 1);
          const weekday = minor === "week" ? timeOpts.isoWeekday : false;
          const hasWeekday = helpers_segment.isNumber(weekday) || weekday === true;
          const ticks = {};
          let first = min;
          let time, count;
          if (hasWeekday) {
            first = +adapter.startOf(first, "isoWeek", weekday);
          }
          first = +adapter.startOf(first, hasWeekday ? "day" : minor);
          if (adapter.diff(max, min, minor) > 1e5 * stepSize) {
            throw new Error(min + " and " + max + " are too far apart with stepSize of " + stepSize + " " + minor);
          }
          const timestamps = options.ticks.source === "data" && this.getDataTimestamps();
          for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {
            addTick(ticks, time, timestamps);
          }
          if (time === max || options.bounds === "ticks" || count === 1) {
            addTick(ticks, time, timestamps);
          }
          return Object.keys(ticks).sort((a, b) => a - b).map((x) => +x);
        }
        getLabelForValue(value) {
          const adapter = this._adapter;
          const timeOpts = this.options.time;
          if (timeOpts.tooltipFormat) {
            return adapter.format(value, timeOpts.tooltipFormat);
          }
          return adapter.format(value, timeOpts.displayFormats.datetime);
        }
        format(value, format) {
          const options = this.options;
          const formats = options.time.displayFormats;
          const unit = this._unit;
          const fmt = format || formats[unit];
          return this._adapter.format(value, fmt);
        }
        _tickFormatFunction(time, index2, ticks, format) {
          const options = this.options;
          const formatter = options.ticks.callback;
          if (formatter) {
            return helpers_segment.callback(formatter, [
              time,
              index2,
              ticks
            ], this);
          }
          const formats = options.time.displayFormats;
          const unit = this._unit;
          const majorUnit = this._majorUnit;
          const minorFormat = unit && formats[unit];
          const majorFormat = majorUnit && formats[majorUnit];
          const tick = ticks[index2];
          const major = majorUnit && majorFormat && tick && tick.major;
          return this._adapter.format(time, format || (major ? majorFormat : minorFormat));
        }
        generateTickLabels(ticks) {
          let i, ilen, tick;
          for (i = 0, ilen = ticks.length; i < ilen; ++i) {
            tick = ticks[i];
            tick.label = this._tickFormatFunction(tick.value, i, ticks);
          }
        }
        getDecimalForValue(value) {
          return value === null ? NaN : (value - this.min) / (this.max - this.min);
        }
        getPixelForValue(value) {
          const offsets = this._offsets;
          const pos = this.getDecimalForValue(value);
          return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
        }
        getValueForPixel(pixel) {
          const offsets = this._offsets;
          const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
          return this.min + pos * (this.max - this.min);
        }
        _getLabelSize(label) {
          const ticksOpts = this.options.ticks;
          const tickLabelWidth = this.ctx.measureText(label).width;
          const angle = helpers_segment.toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
          const cosRotation = Math.cos(angle);
          const sinRotation = Math.sin(angle);
          const tickFontSize = this._resolveTickFontOptions(0).size;
          return {
            w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
            h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
          };
        }
        _getLabelCapacity(exampleTime) {
          const timeOpts = this.options.time;
          const displayFormats = timeOpts.displayFormats;
          const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
          const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [
            exampleTime
          ], this._majorUnit), format);
          const size = this._getLabelSize(exampleLabel);
          const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
          return capacity > 0 ? capacity : 1;
        }
        getDataTimestamps() {
          let timestamps = this._cache.data || [];
          let i, ilen;
          if (timestamps.length) {
            return timestamps;
          }
          const metas = this.getMatchingVisibleMetas();
          if (this._normalized && metas.length) {
            return this._cache.data = metas[0].controller.getAllParsedValues(this);
          }
          for (i = 0, ilen = metas.length; i < ilen; ++i) {
            timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));
          }
          return this._cache.data = this.normalize(timestamps);
        }
        getLabelTimestamps() {
          const timestamps = this._cache.labels || [];
          let i, ilen;
          if (timestamps.length) {
            return timestamps;
          }
          const labels = this.getLabels();
          for (i = 0, ilen = labels.length; i < ilen; ++i) {
            timestamps.push(parse(this, labels[i]));
          }
          return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
        }
        normalize(values) {
          return helpers_segment._arrayUnique(values.sort(sorter));
        }
      };
      __publicField(TimeScale, "id", "time");
      __publicField(TimeScale, "defaults", {
        bounds: "data",
        adapters: {},
        time: {
          parser: false,
          unit: false,
          round: false,
          isoWeekday: false,
          minUnit: "millisecond",
          displayFormats: {}
        },
        ticks: {
          source: "auto",
          callback: false,
          major: {
            enabled: false
          }
        }
      });
      function interpolate(table, val, reverse) {
        let lo = 0;
        let hi = table.length - 1;
        let prevSource, nextSource, prevTarget, nextTarget;
        if (reverse) {
          if (val >= table[lo].pos && val <= table[hi].pos) {
            ({ lo, hi } = helpers_segment._lookupByKey(table, "pos", val));
          }
          ({ pos: prevSource, time: prevTarget } = table[lo]);
          ({ pos: nextSource, time: nextTarget } = table[hi]);
        } else {
          if (val >= table[lo].time && val <= table[hi].time) {
            ({ lo, hi } = helpers_segment._lookupByKey(table, "time", val));
          }
          ({ time: prevSource, pos: prevTarget } = table[lo]);
          ({ time: nextSource, pos: nextTarget } = table[hi]);
        }
        const span = nextSource - prevSource;
        return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
      }
      var TimeSeriesScale = class extends TimeScale {
        constructor(props) {
          super(props);
          this._table = [];
          this._minPos = void 0;
          this._tableRange = void 0;
        }
        initOffsets() {
          const timestamps = this._getTimestampsForTable();
          const table = this._table = this.buildLookupTable(timestamps);
          this._minPos = interpolate(table, this.min);
          this._tableRange = interpolate(table, this.max) - this._minPos;
          super.initOffsets(timestamps);
        }
        buildLookupTable(timestamps) {
          const { min, max } = this;
          const items = [];
          const table = [];
          let i, ilen, prev, curr, next;
          for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
            curr = timestamps[i];
            if (curr >= min && curr <= max) {
              items.push(curr);
            }
          }
          if (items.length < 2) {
            return [
              {
                time: min,
                pos: 0
              },
              {
                time: max,
                pos: 1
              }
            ];
          }
          for (i = 0, ilen = items.length; i < ilen; ++i) {
            next = items[i + 1];
            prev = items[i - 1];
            curr = items[i];
            if (Math.round((next + prev) / 2) !== curr) {
              table.push({
                time: curr,
                pos: i / (ilen - 1)
              });
            }
          }
          return table;
        }
        _getTimestampsForTable() {
          let timestamps = this._cache.all || [];
          if (timestamps.length) {
            return timestamps;
          }
          const data = this.getDataTimestamps();
          const label = this.getLabelTimestamps();
          if (data.length && label.length) {
            timestamps = this.normalize(data.concat(label));
          } else {
            timestamps = data.length ? data : label;
          }
          timestamps = this._cache.all = timestamps;
          return timestamps;
        }
        getDecimalForValue(value) {
          return (interpolate(this._table, value) - this._minPos) / this._tableRange;
        }
        getValueForPixel(pixel) {
          const offsets = this._offsets;
          const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
          return interpolate(this._table, decimal * this._tableRange + this._minPos, true);
        }
      };
      __publicField(TimeSeriesScale, "id", "timeseries");
      __publicField(TimeSeriesScale, "defaults", TimeScale.defaults);
      var scales = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        CategoryScale,
        LinearScale,
        LogarithmicScale,
        RadialLinearScale,
        TimeScale,
        TimeSeriesScale
      });
      var registerables = [
        controllers,
        elements,
        plugins,
        scales
      ];
      exports.Ticks = helpers_segment.Ticks;
      exports.defaults = helpers_segment.defaults;
      exports.Animation = Animation;
      exports.Animations = Animations;
      exports.ArcElement = ArcElement;
      exports.BarController = BarController;
      exports.BarElement = BarElement;
      exports.BasePlatform = BasePlatform;
      exports.BasicPlatform = BasicPlatform;
      exports.BubbleController = BubbleController;
      exports.CategoryScale = CategoryScale;
      exports.Chart = Chart;
      exports.Colors = plugin_colors;
      exports.DatasetController = DatasetController;
      exports.Decimation = plugin_decimation;
      exports.DomPlatform = DomPlatform;
      exports.DoughnutController = DoughnutController;
      exports.Element = Element;
      exports.Filler = index;
      exports.Interaction = Interaction;
      exports.Legend = plugin_legend;
      exports.LineController = LineController;
      exports.LineElement = LineElement;
      exports.LinearScale = LinearScale;
      exports.LogarithmicScale = LogarithmicScale;
      exports.PieController = PieController;
      exports.PointElement = PointElement;
      exports.PolarAreaController = PolarAreaController;
      exports.RadarController = RadarController;
      exports.RadialLinearScale = RadialLinearScale;
      exports.Scale = Scale;
      exports.ScatterController = ScatterController;
      exports.SubTitle = plugin_subtitle;
      exports.TimeScale = TimeScale;
      exports.TimeSeriesScale = TimeSeriesScale;
      exports.Title = plugin_title;
      exports.Tooltip = plugin_tooltip;
      exports._adapters = adapters;
      exports._detectPlatform = _detectPlatform;
      exports.animator = animator;
      exports.controllers = controllers;
      exports.elements = elements;
      exports.layouts = layouts;
      exports.plugins = plugins;
      exports.registerables = registerables;
      exports.registry = registry;
      exports.scales = scales;
    }
  });

  // node_modules/chartjs-adapter-moment/dist/chartjs-adapter-moment.js
  var require_chartjs_adapter_moment = __commonJS({
    "node_modules/chartjs-adapter-moment/dist/chartjs-adapter-moment.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(require_moment(), require_chart()) : typeof define === "function" && define.amd ? define(["moment", "chart.js"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.moment, global2.Chart));
      })(exports, function(moment, chart_js) {
        "use strict";
        function _interopDefaultLegacy(e) {
          return e && typeof e === "object" && "default" in e ? e : { "default": e };
        }
        var moment__default = /* @__PURE__ */ _interopDefaultLegacy(moment);
        const FORMATS = {
          datetime: "MMM D, YYYY, h:mm:ss a",
          millisecond: "h:mm:ss.SSS a",
          second: "h:mm:ss a",
          minute: "h:mm a",
          hour: "hA",
          day: "MMM D",
          week: "ll",
          month: "MMM YYYY",
          quarter: "[Q]Q - YYYY",
          year: "YYYY"
        };
        chart_js._adapters._date.override(typeof moment__default["default"] === "function" ? {
          _id: "moment",
          // DEBUG ONLY
          formats: function() {
            return FORMATS;
          },
          parse: function(value, format) {
            if (typeof value === "string" && typeof format === "string") {
              value = moment__default["default"](value, format);
            } else if (!(value instanceof moment__default["default"])) {
              value = moment__default["default"](value);
            }
            return value.isValid() ? value.valueOf() : null;
          },
          format: function(time, format) {
            return moment__default["default"](time).format(format);
          },
          add: function(time, amount, unit) {
            return moment__default["default"](time).add(amount, unit).valueOf();
          },
          diff: function(max, min, unit) {
            return moment__default["default"](max).diff(moment__default["default"](min), unit);
          },
          startOf: function(time, unit, weekday) {
            time = moment__default["default"](time);
            if (unit === "isoWeek") {
              weekday = Math.trunc(Math.min(Math.max(0, weekday), 6));
              return time.isoWeekday(weekday).startOf("day").valueOf();
            }
            return time.startOf(unit).valueOf();
          },
          endOf: function(time, unit) {
            return moment__default["default"](time).endOf(unit).valueOf();
          }
        } : {});
      });
    }
  });

  // site/views/items-chart.js
  var require_items_chart = __commonJS({
    "site/views/items-chart.js"() {
      var { STORE_KEYS: STORE_KEYS2 } = require_stores();
      var { settings } = require_model2();
      var { today: today2, log, deltaTime, uniqueDates, calculateItemPriceTimeSeries } = require_misc();
      var { __: __2 } = require_browser_i18n();
      var { View } = require_view();
      require_custom_checkbox();
      var moment = require_moment();
      var { Chart, registerables } = require_chart();
      require_chartjs_adapter_moment();
      Chart.register(...registerables);
      var ItemsChart = class extends View {
        constructor() {
          super();
          this.unitPrice = false;
          this.innerHTML = /*html*/
          `
            <div x-id="canvasContainer" class="bg-stone-200 flex flex-col h-[calc(50vh)] p-4 mb-4 mx-auto md:rounded-none md:mb-0 rounded-xl mb-4w ${settings.stickyChart ? "sticky top-0" : ""}">
                <div class="w-full grow">
                    <canvas x-id="canvas" class="bg-white rounded-lg"></canvas>
                    <div x-id="noData" class="hidden flex items-center justify-center h-full">${__2("ItemsChart_Keine Daten ausgew\xE4hlt")}</div>
                </div>
                <div class="filters flex items-center flex-wrap justify-center gap-2 pt-2">
                    <custom-checkbox x-id="sumTotal" x-change x-state label="${__2("ItemsChart_Preissumme Gesamt")}"></custom-checkbox>
                    <custom-checkbox x-id="sumStores" x-change x-state label="${__2("ItemsChart_Preissumme Ketten")}"></custom-checkbox>
                    <custom-checkbox x-id="onlyToday" x-change x-state label="${__2("ItemsChart_Nur heutige Preise")}"></custom-checkbox>
                    <custom-checkbox x-id="percentageChange" x-change x-state label="${__2("ItemsChart_\xC4nderung in % seit")}"></custom-checkbox>
                    <div
                        class="cursor-pointer inline-flex items-center gap-x-1 rounded-full bg-white border border-gray-400 px-2 py-1 text-xs font-medium text-gray-600">
                        <input x-id="startDate" x-change x-state type="date" value="2017-01-01" />
                        -
                        <input x-id="endDate" x-change x-state type="date" value="${today2()}"/>
                    </div>
                </div>
            </div>
        `;
          this.elements.startDate.value = settings.startDate;
          this.setupEventHandlers();
          this.addEventListener("x-change", () => {
            this.render();
          });
        }
        calculateOverallPriceChanges(items, onlyToday, percentageChange, startDate, endDate) {
          if (items.length == 0)
            return { dates: [], changes: [] };
          const getPrice = this.unitPrice ? (o) => o.unitPrice : (o) => o.price;
          if (onlyToday) {
            let sum = 0;
            for (const item of items)
              sum += getPrice(item);
            return [{ date: today2(), price: sum, unitPrice: sum }];
          }
          const dates = uniqueDates(items, startDate, endDate);
          let priceChanges = new Array(dates.length);
          for (let i = 0; i < dates.length; i++) {
            priceChanges[i] = { date: dates[i], price: 0, unitPrice: 0 };
          }
          let numItems = 0;
          items.forEach((product) => {
            const priceScratch = calculateItemPriceTimeSeries(product, percentageChange, startDate, dates);
            if (priceScratch == null)
              return;
            numItems++;
            for (let i = 0; i < priceScratch.length; i++) {
              const price = priceScratch[i];
              priceChanges[i].price += price;
              priceChanges[i].unitPrice += price;
            }
          });
          if (percentageChange) {
            for (let i = 0; i < priceChanges.length; i++) {
              priceChanges[i].price /= numItems;
              priceChanges[i].unitPrice /= numItems;
            }
            for (let i = 0; i < priceChanges.length; i++) {
              priceChanges[i].price = priceChanges[i].price.toFixed(2);
              priceChanges[i].unitPrice = priceChanges[i].unitPrice.toFixed(2);
            }
          }
          return priceChanges;
        }
        renderChart(items, chartType, startDate) {
          const getPrice = this.unitPrice ? (o) => o.unitPrice : (o) => o.price;
          const canvasDom = this.elements.canvas;
          const noData = this.elements.noData;
          if (items.length === 0) {
            canvasDom.classList.add("hidden");
            noData.classList.remove("hidden");
            return;
          } else {
            canvasDom.classList.remove("hidden");
            noData.classList.add("hidden");
          }
          const percentageChange = this.elements.percentageChange.checked;
          const now = performance.now();
          const datasets = items.map((item) => {
            const prices = item.priceHistory;
            const dataset = {
              label: (item.store ? item.store + " " : "") + item.name,
              data: prices.map((price) => {
                return {
                  x: moment(price.date),
                  y: getPrice(price)
                };
              })
            };
            if (settings.chartType == "stepped") {
              dataset.stepped = prices.length >= 2 && prices[0].price != prices[1].price && prices[prices.length - 2].price != prices[prices.length - 1].price ? "after" : "before";
            }
            return dataset;
          });
          log("ItemsChart - Calculating datasets took " + ((performance.now() - now) / 1e3).toFixed(2) + " secs");
          const ctx = canvasDom.getContext("2d");
          let scrollTop = -1;
          if (canvasDom.lastChart) {
            scrollTop = document.documentElement.scrollTop;
            canvasDom.lastChart.destroy();
          }
          let yAxis = {
            ticks: {
              callback: function(value, index, ticks) {
                return value.toLocaleString(navigator.language || "cs-CZ", {
                  minimumFractionDigits: 2,
                  style: "currency",
                  currency: "CZK"
                });
              }
            }
          };
          if (percentageChange) {
            yAxis = {
              title: {
                display: true,
                text: __2("ItemsChart_\xC4nderung in % seit {{date}}", { date: startDate })
              },
              ticks: {
                callback: (value) => {
                  return value + "%";
                }
              }
            };
          }
          canvasDom.lastChart = new Chart(ctx, {
            type: chartType ? chartType : "line",
            data: {
              datasets
            },
            options: {
              layout: {
                padding: 16
              },
              animation: false,
              responsive: true,
              maintainAspectRatio: false,
              scales: {
                x: {
                  type: "time",
                  adapters: {
                    date: moment
                  },
                  time: {
                    unit: "day",
                    displayFormats: {
                      day: "YYYY-MM-D"
                    }
                  },
                  title: {
                    display: true,
                    text: "Date"
                  }
                },
                y: yAxis
              }
            }
          });
          if (scrollTop != -1)
            document.documentElement.scrollTop = scrollTop;
        }
        render() {
          if (!this.model)
            return;
          const start = performance.now();
          const items = this.model.filteredItems;
          const elements = this.elements;
          const onlyToday = this.elements.onlyToday.checked;
          let startDate = this.elements.startDate.value;
          let endDate = this.elements.endDate.value;
          let validDate = /^20\d{2}-\d{2}-\d{2}$/;
          if (!validDate.test(startDate))
            startDate = "2017-01-01";
          if (!validDate.test(endDate))
            endDate = today2();
          const percentageChange = this.elements.percentageChange.checked;
          const itemsToShow = [];
          if (elements.sumTotal.checked && items.length > 0) {
            const now = performance.now();
            itemsToShow.push({
              name: __2("ItemsChart_Preissumme Gesamt"),
              priceHistory: this.calculateOverallPriceChanges(items, onlyToday, percentageChange, startDate, endDate)
            });
            log("ItemsChart - Calculating overall sum total " + ((performance.now() - now) / 1e3).toFixed(2) + " secs");
          }
          if (elements.sumStores.checked && items.length > 0) {
            const now = performance.now();
            STORE_KEYS2.forEach((store) => {
              const storeItems = items.filter((item) => item.store === store);
              if (storeItems.length > 0) {
                itemsToShow.push({
                  name: __2("ItemsChart_Preissumme {{s}}", { s: store }),
                  priceHistory: this.calculateOverallPriceChanges(storeItems, onlyToday, percentageChange, startDate, endDate)
                });
              }
            });
            log("ItemsChart - Calculating overall sum per store took " + ((performance.now() - now) / 1e3).toFixed(2) + " secs");
          }
          items.forEach((item) => {
            if (item.chart) {
              const dates = uniqueDates([item], startDate, endDate);
              const prices = calculateItemPriceTimeSeries(item, percentageChange, startDate, dates).map(
                (price) => percentageChange ? price.toFixed(2) : price
              );
              const priceHistory = [];
              if (!onlyToday) {
                for (let i = 0; i < dates.length; i++) {
                  priceHistory.push({ date: dates[i], price: prices[i], unitPrice: prices[i] });
                }
              } else {
                priceHistory.push({ date: dates[dates.length - 1], price: prices[prices.length - 1], unitPrice: prices[prices.length - 1] });
              }
              const chartItem = {
                name: item.store + " " + item.name,
                priceHistory
              };
              itemsToShow.push(chartItem);
            }
          });
          this.renderChart(itemsToShow, onlyToday ? "bar" : "line", startDate);
          log(`ItemsChart - charted ${itemsToShow.length} items in ${deltaTime(start).toFixed(2)} secs`);
        }
      };
      customElements.define("items-chart", ItemsChart);
    }
  });

  // site/views/items-list.js
  var require_items_list = __commonJS({
    "site/views/items-list.js"() {
      var {
        downloadJSON: downloadJSON2,
        downloadFile,
        dom,
        onVisibleOnce,
        isMobile,
        getBooleanAttribute,
        deltaTime,
        log,
        itemsToCSV,
        numberToLocale
      } = require_misc();
      var { vectorizeItems, similaritySortItems } = require_knn();
      var { stores } = require_stores();
      var { View } = require_view();
      var { ItemsChart } = require_items_chart();
      var { __: __2 } = require_browser_i18n();
      var _ItemsList = class extends View {
        constructor() {
          super();
          this._json = getBooleanAttribute(this, "json");
          this._chart = getBooleanAttribute(this, "chart");
          this._remove = getBooleanAttribute(this, "remove");
          this._add = getBooleanAttribute(this, "add");
          this._updown = getBooleanAttribute(this, "updown");
          this._noSort = getBooleanAttribute(this, "nosort");
          const hideSort = this._noSort ? "hidden" : "";
          this.innerHTML = /*html*/
          `
            <div x-id="options" class="hidden flex flex-col md:flex-row gap-4 px-4 py-2 my-4 justify-between items-center text-sm border rounded-xl md:mt-8 md:rounded-b-none md:mb-0 bg-gray-100 ">
                <div>
                    <div class="flex flex-col md:flex-row gap-2 items-center">
                        <div class="flex flex-row gap-2 items-center">
                            <span x-id="numItemsLabel">${__2("ItemsList_Resultate")}</span><span x-id="numItems"></span>
                            <span>
                                <a x-id="json" class="hidden text-primary font-medium hover:underline" href="">JSON</a>
                                <a x-id="csv" class="hidden text-primary font-medium hover:underline" href="">CSV</a>
                            </span>
                            <custom-checkbox x-id="enableChart" x-change x-state label="${__2("ItemsList_Diagramm")}" class="${this._chart ? "" : "hidden"}"></custom-checkbox>
                        </div>
                        <div class="flex flex-row gap-2 items-center">
                            <label><input x-id="salesPrice" x-change x-state type="radio" name="priceType${_ItemsList.priceTypeId}" checked> ${__2(
            "ItemsList_Verkaufspreis"
          )}</label>
                            <label><input x-id="unitPrice" x-change x-state type="radio" name="priceType${_ItemsList.priceTypeId++}"> ${__2(
            "ItemsList_Mengenpreis"
          )}</label>
                        </div>
                    </div>
                </div>
                <label class="${hideSort}">
                ${__2("ItemsList_Sortieren")}
                    <select x-id="sort" x-change x-state>
                        <option value="price-asc">${__2("ItemsList_Preis aufsteigend")}</option>
                        <option value="price-desc">${__2("ItemsList_Preis absteigend")}</option>
                        <option value="quantity-asc">${__2("ItemsList_Menge aufsteigend")}</option>
                        <option value="quantity-desc">${__2("ItemsList_Menge absteigend")}</option>
                        <option value="store-and-name">${__2("ItemsList_Kette &amp; Name")}</option>
                        <option value="name-similarity" x-id="nameSimilarity" disabled>${__2("ItemsList_Namens\xE4hnlichkeit")}</option>
                    </select>
                </label>
            </div>
            <items-chart x-id="chart" class="hidden"></items-chart>
            <table x-id="itemsTable" class="hidden rounded-b-xl overflow-hidden w-full text-left">
                <thead>
                    <tr class="bg-primary text-white md:table-row uppercase text-sm">
                        <th class="text-center">${__2("ItemsList_Kette")}</th>
                        <th>${__2("ItemsList_Name")}</th>
                        <th x-id="expandPriceHistories" class="cursor-pointer">${__2("ItemsList_Preis")} \u25BC</th>
                        <th></th>
                    </tr>
                </thead>
                <tbody x-id="tableBody" >
                </tbody>
            </table>
        `;
          const elements = this.elements;
          if (this._share)
            elements.shareLink.classList.remove("hidden");
          if (this._json)
            elements.json.classList.remove("hidden");
          if (this._json)
            elements.csv.classList.remove("hidden");
          if (this._chart)
            elements.enableChart.classList.remove("hidden");
          elements.json.addEventListener("click", (event) => {
            event.preventDefault();
            if (!this.model)
              return;
            this.download(this.model.filteredItems, true);
          });
          elements.csv.addEventListener("click", (event) => {
            event.preventDefault();
            if (!this.model)
              return;
            this.download(this.model.filteredItems);
          });
          elements.enableChart.addEventListener("x-change", () => {
            if (elements.enableChart.checked)
              elements.chart.classList.remove("hidden");
            else
              elements.chart.classList.add("hidden");
          });
          this._showAllPriceHistories = false;
          elements.expandPriceHistories.addEventListener("click", () => {
            const showAll = this._showAllPriceHistories = !this._showAllPriceHistories;
            elements.expandPriceHistories.innerText = __2("ItemsList_Preis") + (showAll ? " \u25B2" : " \u25BC");
            elements.tableBody.querySelectorAll(".priceinfo").forEach((el) => showAll ? el.classList.remove("hidden") : el.classList.add("hidden"));
          });
          elements.chart.unitPrice = elements.unitPrice.checked;
          elements.unitPrice.addEventListener("change", () => {
            elements.chart.unitPrice = elements.unitPrice.checked;
            elements.chart.render();
          });
          elements.salesPrice.addEventListener("change", () => {
            elements.chart.unitPrice = elements.unitPrice.checked;
            elements.chart.render();
          });
          this.setupEventHandlers();
          this.addEventListener("x-change", (event) => {
            if (this._ignoreChange) {
              this._ignoreChange = false;
              return;
            }
            this.render();
          });
        }
        set model(model2) {
          super.model = model2;
          this.elements.chart.model = model2;
        }
        get model() {
          return super.model;
        }
        download(items, json) {
          const cleanedItems = [];
          items.forEach((item) => {
            cleanedItems.push({
              store: item.store,
              id: item.id,
              name: item.name,
              category: item.category,
              price: item.price,
              priceHistory: item.priceHistory,
              isWeighted: item.isWeighted,
              unit: item.unit,
              quantity: item.quantity,
              bio: item.bio,
              available: !(item.unavailable ?? false),
              url: stores[item.store].getUrl(item)
            });
          });
          if (json) {
            downloadJSON2("items.json", cleanedItems);
          } else {
            downloadFile("items.csv", itemsToCSV(cleanedItems));
          }
        }
        sort(items) {
          const sortType = this.elements.sort.value;
          if (sortType == "price-asc") {
            if (this.elements.salesPrice.checked)
              items.sort((a, b) => a.price - b.price);
            else
              items.sort((a, b) => a.unitPrice - b.unitPrice);
          } else if (sortType == "price-desc") {
            if (this.elements.salesPrice.checked)
              items.sort((a, b) => b.price - a.price);
            else
              items.sort((a, b) => b.salesPrice - a.salesPrice);
          } else if (sortType == "quantity-asc") {
            items.sort((a, b) => {
              if (a.unit != b.unit)
                return a.unit.localeCompare(b.unit);
              return a.quantity - b.quantity;
            });
          } else if (sortType == "quantity-desc") {
            items.sort((a, b) => {
              if (a.unit != b.unit)
                return a.unit.localeCompare(b.unit);
              return b.quantity - a.quantity;
            });
          } else if (sortType == "store-and-name") {
            items.sort((a, b) => {
              if (a.store < b.store) {
                return -1;
              } else if (a.store > b.store) {
                return 1;
              }
              if (a.name < b.name) {
                return -1;
              } else if (a.name > b.name) {
                return 1;
              }
              return 0;
            });
          } else {
            vectorizeItems(items);
            items = similaritySortItems(items);
          }
          return items;
        }
        highlightMatches(keywords, name) {
          let highlightedName = name;
          for (let i = 0; i < keywords.length; i++) {
            const string = keywords[i];
            const regex = new RegExp(string, "gi");
            highlightedName = highlightedName.replace(regex, "\n$&\r");
          }
          highlightedName = highlightedName.replace(/\n/g, "<strong>").replace(/\r/g, "</strong>");
          return `${highlightedName}`;
        }
        renderItem(item) {
          if (!this._itemTemplate) {
            this._itemTemplate = dom(
              "tr",
              /*html*/
              `
                <td x-id="store" data-label="Kette"></td>
                <td data-label="Name">
                    <div class="flex items-center">
                        <a x-id="name" target="_blank" class="hover:underline" rel="noopener noreferrer nofollow" href=""></a>
                        <small x-id="quantity" class="ml-auto"></small>
                    </div>
                    <table x-id="priceHistory" class="priceinfo hidden" aria-hidden="true">
                    </table>
                </td>
                <td data-label="Preis">
                    <span x-id="price"></span>
                    <span x-id="percentageChange"></span>
                    <span x-id="numPrices"></span>
                    <span class="chevron">\u25BC</span>
                </td>
                <td data-label="Aktionen">
                    <span class="action">
                        <label x-id="chart" class="${this._chart ? "" : "hidden"}">
                            <input x-id="chartCheckbox" type="checkbox" class="hidden peer">
                            <span class="peer-checked:bg-blue-700 btn-action">\u{1F4C8}</span>
                        </label>
                        <input x-id="add" type="button" class="${this._add ? "" : "hidden"} btn-action" value="+">
                        <input x-id="remove" type="button" class="${this._remove ? "" : "hidden"} btn-action" value="-">
                        <input x-id="up" type="button" class="${this._updown ? "" : "hidden"} btn-action" value="\u25B2">
                        <input x-id="down" type="button" class="${this._updown ? "" : "hidden"} btn-action" value="\u25BC">
                    </span>
                </td>
            `
            );
          }
          let price = item.priceHistory[0].price;
          let unitPrice = item.priceHistory[0].unitPrice;
          let prevPrice = item.priceHistory[1] ? item.priceHistory[1].price : -1;
          if (this.model.priceChangesToday) {
            for (let i = 0; i < item.priceHistory.length; i++) {
              if (item.priceHistory[i].date == this.model.priceChangesToday) {
                price = item.priceHistory[i].price;
                unitPrice = item.priceHistory[i].unitPrice;
                prevPrice = item.priceHistory[i + 1].price;
                break;
              }
            }
          }
          let quantity = item.quantity || "";
          let unit = item.unit || "";
          if (quantity >= 1e3 && (unit === "g" || unit === "ml")) {
            quantity = parseFloat((1e-3 * quantity).toFixed(2));
            unit = unit === "ml" ? "l" : "kg";
          }
          let percentageChange = "";
          if (prevPrice != -1) {
            percentageChange = Math.round((price - prevPrice) / prevPrice * 100);
          }
          let showUnitPrice = this.elements.unitPrice.checked;
          let priceUnit = "";
          if (showUnitPrice) {
            if (item.unit === "g")
              priceUnit = " / kg";
            else if (item.unit === "ml")
              priceUnit = " / l";
            else
              priceUnit = " / kus";
          }
          let priceHistory = "";
          let priceBase = 150 / (showUnitPrice ? unitPrice : price);
          for (let i = 0; i < item.priceHistory.length; i++) {
            const date = item.priceHistory[i].date;
            const textBold = this.model.priceChangesToday && this.model.priceChangesToday == date ? "bold" : "";
            const currPrice = showUnitPrice ? item.priceHistory[i].unitPrice : item.priceHistory[i].price;
            const lastPrice = item.priceHistory[i + 1] ? showUnitPrice ? item.priceHistory[i + 1].unitPrice : item.priceHistory[i + 1].price : currPrice;
            const increase = Math.round((currPrice - lastPrice) / lastPrice * 100);
            priceHistory += `
                    <tr>
                        <td class="${textBold}">${date}</td>
                        <td>
                            <div style="width: ${priceBase * currPrice}px"
                                class="${textBold} price-line ${increase > 0 ? "bg-red-500" : "bg-green-500"}">
                                K\u010D ${currPrice.toFixed(2)} ${priceUnit}
                            </div>
                        </td>
                        ${increase > 0 ? `<td class="text-right ${textBold} text-red-500"> + ${increase}%</td>` : increase < 0 ? `<td class="text-right ${textBold} text-green-500"> ${increase}%</td>` : `<td class="text-right ${textBold}"> ${increase}%</td>`}
                    </tr>`;
          }
          let itemDom = this._itemTemplate.cloneNode(true);
          itemDom.setAttribute(
            "class",
            `item group ${stores[item.store]?.color} ${percentageChange > 0 ? "increased" : percentageChange < 0 ? "decreased" : "neutral"}`
          );
          itemDom.setAttribute("x-notraverse", "true");
          const elements = View.elements(itemDom);
          elements.store.innerText = item.store;
          elements.name.href = stores[item.store].getUrl(item);
          elements.name.innerHTML = this.highlightMatches(this.model.lastQueryTokens ?? [], item.name) + (item.unavailable ? " \u{1F480}" : "");
          elements.quantity.innerText = (item.isWeighted ? "\u2696 " : "") + `${quantity} ${unit}`;
          elements.price.innerText = `K\u010D ${Number(showUnitPrice ? unitPrice : price).toFixed(2)} ${priceUnit}`;
          elements.priceHistory.innerHTML = priceHistory;
          elements.percentageChange.classList.add(percentageChange > 0 ? "text-red-500" : percentageChange < 0 ? "text-green-500" : "hidden");
          elements.percentageChange.innerText = `${percentageChange > 0 ? "+" + percentageChange : percentageChange}%`;
          elements.numPrices.innerText = item.priceHistory.length > 1 ? "(" + (item.priceHistory.length - 1) + ")" : "";
          itemDom.querySelectorAll('td[data-label="Preis"]').forEach((priceDom) => {
            priceDom.style["cursor"] = "pointer";
            priceDom.addEventListener("click", (event) => {
              let target = event.target;
              if (!target.classList.contains("chevron")) {
                target = target.querySelector("chevron");
              }
              const pricesDom = priceDom.parentNode.querySelector(".priceinfo");
              if (pricesDom.classList.contains("hidden")) {
                pricesDom.classList.remove("hidden");
                pricesDom.ariaHidden = false;
                if (target)
                  target.innerHTML = "\u25B2";
              } else {
                pricesDom.classList.add("hidden");
                pricesDom.ariaHidden = true;
                if (target)
                  target.innerHTML = "\u25BC";
              }
            });
          });
          if (this._chart) {
            elements.chartCheckbox.checked = item.chart;
            elements.chartCheckbox.addEventListener("change", (event) => {
              item.chart = elements.chartCheckbox.checked;
              if (item.chart && !this.elements.enableChart.checked) {
                this.elements.enableChart.checked = true;
                this.elements.chart.classList.remove("hidden");
              }
              this.elements.chart.render();
              this._ignoreChange = true;
              this.fireChangeEvent();
            });
          }
          if (this.model.items.length != this.model.filteredItems.length) {
            elements.up.classList.add("hidden");
            elements.down.classList.add("hidden");
          }
          elements.add.addEventListener("click", () => {
            if (this._addCallback)
              this._addCallback(item);
          });
          elements.remove.addEventListener("click", () => {
            let index = this.model.items.indexOf(item);
            if (index >= 0)
              this.model.items.splice(index, 1);
            index = this.model.filteredItems.indexOf(item);
            if (index >= 0)
              this.model.filteredItems.splice(index, 1);
            itemDom.remove();
            this.elements.chart.render();
            if (this._removeCallback)
              this._removeCallback(item);
          });
          elements.up.addEventListener("click", () => {
            const index = itemDom.rowIndex - 1;
            if (index === 0)
              return;
            let otherItem = this.model.items[index - 1];
            this.model.items[index - 1] = item;
            this.model.items[index] = otherItem;
            let rowBefore = this.elements.tableBody.rows[index - 1];
            this.elements.tableBody.insertBefore(itemDom, rowBefore);
            if (this._upCallback)
              this._upCallback(item);
          });
          elements.down.addEventListener("click", () => {
            const index = itemDom.rowIndex - 1;
            if (index === this.model.items.length - 1)
              return;
            let otherItem = this.model.items[index + 1];
            this.model.items[index + 1] = item;
            this.model.items[index] = otherItem;
            let rowAfter = this.elements.tableBody.rows[index + 1];
            this.elements.tableBody.insertBefore(rowAfter, itemDom);
            if (this._downCallback)
              this._downCallback(item);
          });
          if (this._showAllPriceHistories)
            elements.priceHistory.classList.remove("hidden");
          return itemDom;
        }
        render() {
          const start = performance.now();
          const elements = this.elements;
          if (!this.model)
            return;
          elements.chart.unitPrice = elements.unitPrice.checked;
          if (this.model.filteredItems.length != 0 && this.model.filteredItems.length <= (isMobile() ? 200 : 1500)) {
            elements.nameSimilarity.removeAttribute("disabled");
          } else {
            elements.nameSimilarity.setAttribute("disabled", "true");
            if (this.model.filteredItems.length != 0 && elements.sort.value === "name-similarity")
              elements.sort.value = "price-asc";
          }
          let items = [...this.model.filteredItems];
          if (this.model.lastQuery && this.model.lastQuery.charAt(0) === "!" && this.model.lastQuery.toLowerCase().indexOf("order by") >= 0) {
            elements.sort.parentElement.classList.add("hidden");
          } else {
            if (!this._noSort) {
              elements.sort.parentElement.classList.remove("hidden");
              items = this.sort(items);
            }
          }
          if (items.length === 0) {
            elements.chart.classList.add("hidden");
            elements.options.classList.add("hidden");
            elements.itemsTable.classList.add("hidden");
          } else {
            if (elements.enableChart.checked)
              elements.chart.classList.remove("hidden");
            elements.options.classList.remove("hidden");
            elements.itemsTable.classList.remove("hidden");
          }
          elements.numItems.innerHTML = numberToLocale(items.length) + (this.model.totalItems > items.length ? " / " + numberToLocale(this.model.totalItems) : "");
          const tableBody = elements.tableBody;
          tableBody.innerHTML = "";
          let i = 0;
          const batches = [];
          let batch = [];
          items.forEach((item) => {
            if (batch.length === 25) {
              batches.push(batch);
              batch = [];
            }
            batch.push(item);
          });
          if (batch.length > 0)
            batches.push(batch);
          const renderBatch = () => {
            const batch2 = batches.shift();
            if (!batch2)
              return;
            let itemDom = null;
            for (const item of batch2) {
              itemDom = this.renderItem(item);
              tableBody.append(itemDom);
            }
            if (itemDom)
              onVisibleOnce(itemDom, renderBatch);
          };
          renderBatch();
          log(`ItemsList - rendering ${items.length} items took ${deltaTime(start).toFixed(4)} secs`);
        }
        set addCallback(callback) {
          this._addCallback = callback;
        }
        set removeCallback(callback) {
          this._removeCallback = callback;
        }
        set upCallback(callback) {
          this._upCallback = callback;
        }
        set downCallback(callback) {
          this._downCallback = callback;
        }
      };
      var ItemsList = _ItemsList;
      __publicField(ItemsList, "priceTypeId", 0);
      customElements.define("items-list", ItemsList);
    }
  });

  // site/views/index.js
  var require_views = __commonJS({
    "site/views/index.js"() {
      require_custom_checkbox();
      require_carts_list();
      require_items_filter();
      require_items_list();
      require_view();
    }
  });

  // site/views/progress-bar.js
  var require_progress_bar = __commonJS({
    "site/views/progress-bar.js"(exports) {
      var ProgressBar2 = class {
        constructor(steps) {
          this.progress = 0;
          this.steps = steps ?? 0;
          this.step = 100 / this.steps;
          this.container = document.querySelector('[x-id="loader"]');
          this.progressBar = this.container.querySelector(".progress-bar");
        }
        setSteps(steps) {
          this.steps = steps;
          this.step = 100 / steps;
        }
        addStep() {
          this.progress += this.step;
          this.progressBar.style.transform = `scaleX(${this.progress / 100})`;
          if (this.progress >= 99) {
            this.finished();
          }
        }
        finished() {
          const element = this.container;
          setTimeout(function() {
            element.classList.add("hidden");
          }, 250);
        }
      };
      exports.ProgressBar = ProgressBar2;
    }
  });

  // site/carts.js
  var { downloadJSON, today } = require_misc();
  var model = require_model2();
  require_views();
  var { __ } = require_browser_i18n();
  var { STORE_KEYS } = require_stores();
  var { ProgressBar } = require_progress_bar();
  var progressBar = new ProgressBar(STORE_KEYS.length);
  function newCart() {
    let name = prompt(__("Carts_Name f\xFCr Warenkorb eingeben:"));
    if (!name || name.trim().length == 0)
      return;
    name = name.trim();
    if (model.carts.carts.some((cart) => cart.name === name)) {
      alert(__("Carts_Warenkorb mit Namen '{{name}}' existiert bereits", { name }));
      return;
    }
    model.carts.add(name);
    location.href = `cart.html?name=${encodeURIComponent(name)}`;
  }
  function isIterable(obj) {
    return typeof obj[Symbol.iterator] === "function";
  }
  function importCart(importedCart) {
    const items = [];
    for (const cartItem of importedCart.items) {
      const item = model.items.lookup[cartItem.store + cartItem.id];
      if (!item)
        continue;
      items.push(item);
    }
    importedCart.items = items;
    const index = model.carts.carts.findIndex((cart) => cart.name === importedCart.name);
    if (index != -1) {
      let newName = importedCart.name;
      while (true) {
        newName = prompt(
          __("Carts_Warenkorb '{{name}}' existiert bereits. Bitte einen anderen Namen f\xFCr den zu importierenden Warenkorb eingeben", {
            name: importedCart.name
          }),
          importedCart.name + today()
        );
        if (!newName || newName.trim().length == 0)
          return;
        newName = newName.trim();
        if (newName != importedCart.name) {
          importedCart.name = newName;
          model.carts.carts.push(importedCart);
          break;
        }
      }
    } else {
      model.carts.carts.push(importedCart);
    }
    model.carts.save();
  }
  function importCarts(importedCarts) {
    if (isIterable(importedCarts)) {
      importedCarts.forEach((cart) => importCart(cart));
    } else {
      importCart(importedCarts);
    }
  }
  (async () => {
    await model.load(() => progressBar.addStep());
    document.querySelector("#carts").model = model.carts;
    document.querySelector("#new").addEventListener("click", () => newCart());
    document.querySelector("#export").addEventListener("click", () => downloadJSON("carts.json", model.carts.carts));
    document.querySelector("#import").addEventListener("click", () => document.querySelector("#fileInput").click());
    document.querySelector("#fileInput").addEventListener("change", function(event) {
      const reader = new FileReader();
      reader.onload = (event2) => {
        const importedCarts = JSON.parse(event2.target.result);
        importCarts(importedCarts);
      };
      reader.readAsText(event.target.files[0]);
    });
  })();
})();
/*! Bundled license information:

alasql/dist/alasql.min.js:
  (*! AlaSQL v4.0.3 build: develop-37eea424 | © 2014-2023 Andrey Gershun & Mathias Wulff | License: MIT *)

moment/moment.js:
  (*! moment.js *)
  (*! version : 2.29.4 *)
  (*! authors : Tim Wood, Iskren Chernev, Moment.js contributors *)
  (*! license : MIT *)
  (*! momentjs.com *)

@kurkle/color/dist/color.cjs:
  (*!
   * @kurkle/color v0.3.2
   * https://github.com/kurkle/color#readme
   * (c) 2023 Jukka Kurkela
   * Released under the MIT License
   *)

chart.js/dist/chunks/helpers.segment.cjs:
  (*!
   * Chart.js v4.3.0
   * https://www.chartjs.org
   * (c) 2023 Chart.js Contributors
   * Released under the MIT License
   *)

chart.js/dist/chart.cjs:
  (*!
   * Chart.js v4.3.0
   * https://www.chartjs.org
   * (c) 2023 Chart.js Contributors
   * Released under the MIT License
   *)

chartjs-adapter-moment/dist/chartjs-adapter-moment.js:
  (*!
    * chartjs-adapter-moment v1.0.1
    * https://www.chartjs.org
    * (c) 2022 chartjs-adapter-moment Contributors
    * Released under the MIT license
    *)
*/
//# sourceMappingURL=carts.js.map
